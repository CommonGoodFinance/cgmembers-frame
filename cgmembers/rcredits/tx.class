<?php
namespace CG;
use CG as r;
use CG\DB as db;
use CG\Backend as be;
use CG\Util as u;

require_once __DIR__ . '/txentry.class';

/**
 * @file
 * rCredits Transaction class (and extension MyTx, which looks at the transaction from one party's view)
 *
 * Note that a transaction has at least two entries, which this class also contains
 */

class Tx {
  const TX_HDR_FIELDS = ['xid', 'type', 'goods', 'initiator', 'initiatorAgent', 'flags',
                         'channel', 'box', 'risk', 'risks', 'reverses', 'created'];
  const INSERT_FIELDS = ['type', 'goods', 'initiator', 'initiatorAgent', 'flags',
                         'channel', 'box', 'risk', 'risks', 'reverses', 'created'];
  const REQUIRED_FIELDS = ['type', 'goods', 'initiator', 'flags', 'entries'];
  const ALLOWED_FIELDS = ['xid', 'type', 'goods', 'initiator', 'initiatorAgent', 'flags',
                          'channel', 'box', 'risk', 'risks', 'reverses', 'created', 'entries'];

  private $properties;
  
  /**
   * Instantiate (construct) a transaction record.
   * @param assoc $info: array of field values for new transaction, must include REQUIRED_FIELD entries,
   *                     but must only include ALLOWED_FIELD entries.
   */
  function __construct($info) {
    u\EXPECT(array_diff(Tx::REQUIRED_FIELDS, array_keys($info)) == [], 'missing fields in Tx::createNew');
    u\EXPECT(array_diff(array_keys($info), Tx::ALLOWED_FIELDS) == [], 'extra fields in Tx::createNew:' .
             print_r(array_diff(array_keys($info), Tx::ALLOWED_FIELDS), true));
    u\EXPECT(count($info['entries']) >= 2, 'transactions must have at least two entries');

    $this->properties = $info;  // OK because array assignment is by copying
    if (!array_key_exists('xid', $this->properties)) { $this->properties['xid'] = 0; }
    if (!array_key_exists('created', $this->properties)) { $this->properties['created'] = time(); };
  }

  /**
   * Return the value of the specified field that is not a simple property of the class.
   * @param string $field: name of field value to get
   * @return the value if it exists, else NULL
   */
  public function __get($f) {
    $x = $this;
    if (array_key_exists($f, $x->properties)) {
      return $x->properties[$f];
    }
    switch ($f) {
    case 'properties':
      return $this->properties;
    default:
      u\EXPECT(FALSE, "unexpected field '$f' requested");
    }
  }

  /**
   * Read an existing transaction record, with its entries.
   * @param xid $xid: transaction record id
   * @return the new instance of Tx
   */
  static function read($xid) {
    u\EXPECT(is_integer($xid));
    
    $DBTX = db_transaction();
    $info = db\get('*', 'r_tx_hdrs', 'xid=:xid', ['xid' => $xid]);
    u\EXPECT($info, "Transaction $xid not found");
    $entries = r\TxEntry::readAll($xid);
    u\EXPECT($entries, "No entries found for transaction $xid");
    unset($DBTX);
    return new Tx($info + ['entries' => $entries]);
  }
  
  /**
   * Save this transaction in the database (header record plus all entries).
   * @return the xid of the transaction
   */
  function insert() {
    $x = $this;
    $DBTX = db_transaction();
    u\EXPECT($x->properties['xid'] == 0, "We're not allowing modification of transactions.");
    $xid = db\insert('r_tx_hdrs', just(Tx::INSERT_FIELDS, $x->properties), 'xid');
    u\EXPECT($xid, "Failed to insert transaction header record");
    foreach ($x->properties['entries'] as $entry) {
      $eid = $entry->insert($xid);
      u\EXPECT($eid, "Failed to insert transaction entry");
    }
    unset($DBTX);
    return $xid;
  }

  /* /\** */
  /*  * Keep track of r, rewards, and committed amounts in the account record */
  /*  * None of these figures is authoritative except 'committed'.  */
  /*  * r and rewards are the sum of the relevant fields in transactions. */
  /*  * @return <success> */
  /*  *\/ */
  /* private function cacheTotals($entries) { */
  /*   global $channel; */

  /*   /\* if (!$a = r\acct($myId)) return FALSE; *\/ */
  /*   $cacheFields = 'balance committed lastTx access'; */
  /*   /\* extract((array) $a->account($cacheFields)); *\/ */
    
  /*   if ($channel != TX_CRON) $access = r\rTime(); // track last transaction or login (just major access) */
    
  /*   foreach ($entries as $entry) { */
  /*     extract(just('uid amount type', $entry)); */
  /*     if (is_null($amount)) { */
  /*       print_r(debug_backtrace()); */
  /*       die('amount is null'); */
  /*     } */
  /*     $a = r\acct($uid); */
  /*     $balance = $a->balance; */
  /*     $balance = round($balance + $amount, 2); */
  /*     $a->update(compact('balance')); */
  /*   } */
    
  /*   return TRUE; */
  /* } */
  
  /* public function risk($bit) {return u\getBit($this->risks, $bit);} */
  /* public function setRisk($bit, $on = TRUE) {$this->setBitx($bit, $on, 'risks');} */

} // end of class x

/* class MyX extends x { */
/*   var $a; */
  
/*   function __construct($xid = [], $entries = [], $a = 0, $save = TRUE) { */
/*     parent::__construct($xid, $entries, $save); */
/*     $this->a = $a; */
/*   }     */

/*   public function __get($f) { */
/*     $x = $this; */

/*     if ($f == 'ray') { */
/*       u\EXPECT((bool) $x->ray0, 'no xray!'); */
/*       foreach (ray('toMe byMe tid otherTid otherUid taking') as $k) $extras[$k] = $x->$k; */
/*       return $x->ray0 + $extras; */
/*     } */
/*     // NO! Makes ...2 fields fail if tx is created from ->ray (as in themX)   if (isset($x->ray0[$f])) return parent::__get($f); */

/*     foreach (ray('a xid banking toMe amount') as $k) $$k = @$x->$k; */
/*     foreach (['amount', 'xid'] as $k) $$k += 0; */
/*     if (substr($f, -1, 1) == '2' and $f = str_replace('2', '', $f)) return $banking ? '' : $x->themX->$f; */
/*     if (strpos($f, 'Purpose') and $f = str_replace('Purpose', 'For', $f)) return $x->$f; */
/*     if ($f == 'banking') return ($x->type == TX_BANK); */
/*     if ($f == 'toMe') return $banking ? ($amount < 0 xor $xid < 0) : $a->isMe($x->payee); */
/*     if ($f == 'fromMe') return $banking ? !$toMe : $a->isMe($x->payer); */
/*     if ($f == 'byMe') return $banking ?: ($x->taking xor !$toMe); */
/*     if ($f == 'reallyToMe') return ($toMe xor $amount < 0); */
/*     if ($f == 'name') return $a->fullName; */

/*     if ($f == 'for' or $f == 'purpose') return $banking // ? */
/*                                           ? ($xid < 0 ? t('bank transfer failed') : ($amount < 0 ? t('from bank') : t('to bank'))) */
/*                                           : ($toMe ? $x->payeeFor : $x->payerFor); */
    
/*     if ($f == 'agent') return $banking // ? */
/*                          ? ($a->co ? '' : $x->payer) */
/*                          : ($toMe ? $x->payeeAgent : $x->payerAgent); */
    
/*     if ($f == 'tid') return ($banking or $a->id < 0) ? $xid : ($toMe ? $x->payeeTid : $x->payerTid); */
/*     if ($f == 'otherTid') return ($banking or $a->id < 0) ? $xid : ($toMe ? $x->payerTid : $x->payeeTid); */
/*     if ($f == 'them' or $f == 'otherUid') return $banking ? 0 : ($toMe ? $x->payer : $x->payee); */
/*     if ($f == 'themAgent') return $banking ? 0 : ($toMe ? $x->payerAgent : $x->payeeAgent); */
/*     if ($f == 'themX') return r\x($x->ray, r\acct($x->them, $x->themAgent)); */
/*     return parent::__get($f); */
/*   } */

/*   /\** */
/*    * Return an appropriate message about the transaction */
/*    * @param string $type: what type of message to return (actor, youDid, theyDid, or reverse) */
/*    * @param string $desc: how much of the description to include: none (''), vague, or full */
/*    * @param bool $withDate: <include the transaction date in the message> */
/*    * @return the message */
/*    *\/ */
/*   public function msg($msgType, $desc = '', $withDate = FALSE) { */
/*     $x = $this; */
/*     foreach (ray('toMe byMe') as $k) $extras[$k] = $x->$k; */
/*     $extras['name'] = r\acct($x->them)->fullName; // r\acct($toMe ? $x->payer : $x->payee)->fullName; */
/*     $extras['description'] = $x->toMe ? $x->payeeFor : $x->payerFor; */

/*     return self::msg0($x->ray + $extras, $msgType, $desc, $withDate); */
/*   } */
  
/*   public static function msg0($tx, $msgType, $purpose = '', $withDate = FALSE) { */
/*     extract(just('name amount toMe byMe goods description created', $tx)); */
    
/*     $youDid = t('paid,received from,received from,repaid,paid,took back from,charged,refunded'); */
/*     $theyDid = t('charged,refunded,paid,took back from,received from,repaid,paid,received from'); */
/*     $reverse = t('request a refund of this charge,reverse this refund,refund this payment,request a reversal of this charge,request a refund of this payment,reverse this refund charge,reverse this charge,request a reversal of this refund'); */
    
/*     $them = $name; */
/*     $neg = (int) ($amount < 0); */
/*     $index = 4 * $byMe + 2 * $toMe + $neg; */

/*     if ($msgType == 'actor') $msgType = $byMe ? 'youDid' : 'theyDid'; */
/*     $types = explode(',', $$msgType); */
/*     $action = $types[$index]; */

/*     if ($msgType == 'reverse') { */
/*       if ($goods == FOR_USD) { */
/*         return in($index, [0,3,4,7]) ? t('request a reversal of this charge') : t('reverse this exchange'); */
/*       } else return $action; */
/*     }  */
    
/*     $msg = $msgType == 'youDid' ? t('You') . ' %action %them' : ('%them %action ' . t('you')); */
/*     $msg .= ' %amount'; */
/*     if ($purpose) { */
/*       if ($purpose == 'full') $purpose = '"' . $description . '"'; */
/*       if ($purpose == 'vague') $purpose = obj(R_WHYS)->$goods; */
/*       $msg .= '|purpose'; */
/*     } */
/*     if ($withDate) $msg .= '|when'; */
/*     list ($amount, $created) = [u\fmtAmt($amount), u\fmtDate($created)]; */
    
/*     return t($msg, compact(ray('action them amount purpose created'))); */
/*   } */

/*   /\** */
/*    * Format and return args for reporting a transaction (old or new) to the current account. */
/*    * Not all returned args are used for any particular type of transaction. */
/*    * Note that templates and tests depend on the names of some of these fields */
/*    * @param acct $a: the account to report to (usually the current account) */
/*    * @param array $tx: the transaction array (including xid) */
/*    * @param int $getBalance: 0=don't get any balances, 1=get my balance and tid, 2=get other party's balance and tid also */
/*    * @param float $shortfall: how much short my balance is, for a transaction (if any) */
/*    * @return assoc array of args */
/*    *\/ */
/*   public function reportArgs($getMyBalance = FALSE, $shortfall = 0) { */
/*     global $channel; */
/*     $x1 = $this; */
/*     $a1 = $x1->a; */
/*     $x2 = $x1->themX; */
/*     $a2 = r\acct($otherUid = $x1->them); */
/*     $tx = $x1->ray0; */
/*     //    $fields = 'data amount goods payer payee payerReward payeeReward toMe payerPurpose payeePurpose payerTid payeeTid created'; */
/*     $fields = 'data amount goods payer payee toMe payerPurpose payeePurpose payerTid payeeTid created'; */
/*     foreach (ray($fields) as $k) $$k = $x1->$k; */
/*     //    extract(just('rebate bonus', $data)); */

/*     $reverses = isset($data['undoes']); */
/*     $role = $toMe ? 'payee' : 'payer'; */
/*     u\both($tx, 'purpose', $toMe, $payeePurpose, $payerPurpose); */
/*     u\both($tx, 'tid', $toMe, @$payeeTid, @$payerTid); // no tid if unconfirmed */
/*     $tofrom = $toMe ? t('from') : t('to'); */
/*     //  $confirmAction = $toMe ? t('charge') : ($channel == TX_POS ? t('credit') : t('pay')); */
/*     $why = ray(R_WHYS)[$goods]; */

/*     If ($amount < 0) { // for POS */
/*       $amount = -$amount; // rephrase as positive */
/*       $tofrom = t('to'); */
/*       //    $confirmAction = $toMe ? t('credit') : t('charge'); */
/*       u\both($tx, 'did', $toMe, $goods == FOR_GOODS ?  t('refunded') : t('credited'), t('charged')); */
/*       //      if (r\isGiveback($payee, $payer, $data)) list ($tx['did'], $a2, $why) = [t('gave'), $a1, t('returning rewards to the community')]; */
/*     } else u\both($tx, 'did', $toMe, $reverses ? t('re-charged') : t('charged'), (($channel == TX_POS and $a1->co) ? t('credited') : t('paid'))); */

/*     ///     debug(compact('tx','toMe','amount','reverses','goods')); */

/*     $amount = u\fmtAmt($amount); */
/*     $short = u\fmtAmt($shortfall); */
/*     if ($getMyBalance) { */
/*       if ($a1->can(B_BUY)) $balance = u\fmtAmt($a1->avail(FOR_GOODS)); */
/*     } */
    
/*     /\*    if ($goods == FOR_GOODS) { */
/*     //    u\both($tx, 'rewardType', $toMe, t('bonus'), t('rebate')); */
/*     //      u\both($tx, 'rewardType', $toMe, t('reward'), t('reward')); */
/*     //      u\both($tx, 'rewardAmount', $toMe, u\fmtAmt(@$payeeReward + 0), u\fmtAmt(@$payerReward + 0)); */
/*     } */
/*     *\/ */
/*     $myName = $a1->fullName; */
/*     $otherName = $a2->fullName; */
/*     $created = u\fmtDate($created0 = $created); */

/*     $success = TRUE; */
/*     foreach (ray('r payer payee') as $one) unset($tx[$one]); // else preempts all subs that start thus */
/*     return compact(ray('created created0 xid role why payerPurpose payeePurpose toMe amount tofrom balance otherUid myName otherName short success')) + $tx; */
/*   } */

/*   /\** */
/*    * Return the last transaction meeting the given criteria, for the given user. */
/*    * Rebates, bonuses, and deleted transactions are ignored */
/*    * @param string $where: the criteria (defaults to 1 = any) */
/*    * @param array $subs: optional substitutions (will be prefixed with colons) */
/*    * @return associative array: the old transaction record (FALSE if none) */
/*    *\/ */
/*   static function lastTx($a, $where = 1, $subs = [], $cache = FALSE) { */
/*     /\* echo "<br>lastTx($a->id, $where, "; *\/ */
/*     /\* print_r($subs); *\/ */
/*     /\* echo ", $cache)"; *\/ */
/*     $basic = "$a->id = e.uid AND t.type>=0"; // make sure it's for this account */
/*     $sql = "SELECT t.xid FROM r_tx_hdrs t JOIN r_entries e ON t.xid = e.xid WHERE ($basic) AND ($where) ORDER BY xid DESC LIMIT 1"; */
/*     ///     debug(compact('where','subs','myid','basic','sql')); */
/*     /\* echo "<br>basic=$basic"; *\/ */
/*     /\* echo "<br>sql=$sql"; *\/ */
/*     $result = db\q($sql, $subs); */
/*     echo "<br>result="; */
/*     print_r($result); */
/*     $result = $result->fetchAssoc(); */
/*     echo "<br>result="; */
/*     print_r($result); */
/*     if (!$result) return FALSE; */
/*     return r\x($result['xid'], $a); */
/*   } */

/*   /\** */
/*    * Determine whether the record can be undone */
/*    * @param assoc $subs: (RETURNED) necessary substitutions, if any, including whatever was already there */
/*    * @return string: the error message (FALSE if the current agent CAN undo it on behalf of the current account) */
/*    *\/ */
/*   function nonoUndo(&$subs = []) { */
/*     $x = $this; */
/*     //    global $mya; */
/*     //    extract(just('amount toMe data payer payee payerTid payeeTid taking', $oldRecord)); */
/*     //    $data = unserialize($data); */
/*     if (@$x->data['undoneBy']) { */
/*       $subs['oldTid'] = $x->toMe ? $x->payeeTid : $x->payerTid; */
/*       return 'already undone'; */
/*     } */

/*     $a1 = r\acct($x->toMe ? $x->payee : $x->payer, $x->a->agentId); */
/*     $a2 = r\acct($x->toMe ? $x->payer : $x->payee); // second account's permissions are irrelevant */
/*     if ($err = r\txPermErr($a1, $a2, $x->toMe, $x->toMe xor $x->amount < 0)) return $err; */

/*     return FALSE; */
/*   } */
  
/* } */

/* /\** */
/*  * Return an existing transaction object or MyX. */
/*  * Call by: */
/*  *   x(info, a) OR x(xid, a) [returns a MyX object] OR */
/*  *   x(info) OR x(xid) */
/*  * @param int $xid: transaction record ID */
/*  * @param int $a: associated account */
/*  * @param assoc $info: initial field values for the transaction, to be created and saved in the database */
/*  *\/ */
/* function x($xid, $a = '') { */
/*   $x = $a ? new MyX($xid, null, $a, FALSE) : new X($xid, null, FALSE); */
/*   return @$x->xid ? $x : FALSE; */
/* } */

class MyTx extends Tx {
  private $uid;
  private $jid;
  
  function __construct($uid, $info, $jid=0) {
    $x = $this;
    $x->uid = $uid;
    $x->jid = $jid;
    parent::__construct($info);
  }

  function __get($f) {
    switch ($f) {
    case 'uid':
      return $this->uid;
    case 'myTid':
      return $this->getMyTid();
    default:
      return parent::__get($f);
    }
  }

  private function getMyTid() {
    $myTid = 0;
    foreach ($this->entries as $entry) {
      if ($entry->uid == $this->uid or $entry->uid == $this->jid) {
        $myTid = max($myTid, $entry->acctTid);
      }
    }
    return $myTid;
  }
  
  /**
   * Read all transactions for a particular user.
   * @param integer $uid: the uid of the user
   * @param timestamp $starting: the starting unix timestamp
   * @param timestamp $ending: the ending unix timestamp
   * @return an array of Txs, all the transactions of that user
   */
  static public function readAll($starting, $ending, $uid, $jid=0) {
    $restrict = ($starting != null and $ending != null) ? "AND (t.created BETWEEN '$starting' AND '$ending')" : "";
    $users = ($jid != 0) ? "uid IN ('$uid', '$jid')" : "uid='$uid'";
    $DBTX = db_transaction();
    $sql = <<< EOF
      SELECT t.*, e.*
      FROM r_tx_hdrs t LEFT JOIN r_entries e USING (xid)
      WHERE (t.xid IN (SELECT DISTINCT xid FROM r_entries WHERE $users))
            $restrict
      ORDER BY e.xid
EOF;
    $result = db\q($sql, []);
    u\EXPECT($result, "Failure reading transactions for user $uid");
    $lastXid = 0;  // no xid should ever be 0
    $txs = [];
    $entries = [];
    foreach ($result as $row) {
      $row = (array)$row;
      if ($row['xid'] != $lastXid) {
        $lastXid = $row['xid'];
        if ($entries != []) {
          $txs[] = new MyTx($uid, just(Tx::TX_HDR_FIELDS, $row) + ['entries' => $entries], $jid);
          $entries = [];
        }
      }
      $entry = new TxEntry(just(r\TxEntry::ENTRY_FIELDS, $row));
      $entries[] = $entry;
    }
    if ($entries != []) { // last one
      $txs[] = new MyTx($uid, just(Tx::TX_HDR_FIELDS, $row) + ['entries' => $entries], $jid);
    }
    unset($DBTX);
    return $txs;
  }
}
