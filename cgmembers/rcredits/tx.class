<?php
namespace CG;
use CG as r;
use CG\DB as db;
use CG\Backend as be;
use CG\Util as u;

require_once __DIR__ . '/txentry.class';

/**
 * @file
 * CG credit Transaction class
 *
 * Note that a transaction has at least two entries, which this class also contains
 */

class Tx {
  const TX_HDR_FIELDS = ['xid', 'goods', 'actorId', 'actorAgentId', 'flags',
                         'channel', 'box', 'goods', 'risk', 'risks', 'reversesXid', 'created'];
  const INSERT_FIELDS = ['goods', 'actorId', 'actorAgentId', 'flags',
                         'channel', 'box', 'goods', 'risk', 'risks', 'reversesXid', 'created'];
  const REQUIRED_FIELDS = ['goods', 'actorId', 'flags'];

  public $xid;
  public $type;
  public $goods;
  public $actorId;
  public $actorAgentId;
  public $flags;
  public $channel;
  public $box;
  public $risk;
  public $risks;
  public $reversesXid;
  public $created;
  public $entries;
  
  /**
   * Instantiate (construct) a transaction record.
   * @param assoc $info: array of field values for new transaction, must include REQUIRED_FIELD entries,
   *                     but must only include ALLOWED_FIELD entries.
   */
  function __construct($info) {
    $missing = array_diff(Tx::REQUIRED_FIELDS, array_keys($info));
    u\EXPECT($missing == [], "missing fields in Tx::createNew: " . print_r($missing, true));

    $this->xid = u\arrayGet($info, 'xid', 0);
    $this->goods = u\arrayGet($info, 'goods', null);
    $this->actorId = u\arrayGet($info, 'actorId', null);
    $this->actorAgentId = u\arrayGet($info, 'actorAgentId', null);
    $this->flags = u\arrayGet($info, 'flags', null);
    $this->channel = u\arrayGet($info, 'channel', null);
    $this->box = u\arrayGet($info, 'box', null);
    $this->risk = u\arrayGet($info, 'risk', null);
    $this->risks = u\arrayGet($info, 'risks', 0);
    $this->reversesXid = u\arrayGet($info, 'reversesXid', null);
    $this->created = u\arrayGet($info, 'created', r\rTime());
    $this->entries = u\arrayGet($info, 'entries', []);
  }

  /**
   * Return the value of the specified field that is not a simple property of the class.
   * @param string $field: name of field value to get
   * @return the value if it exists, else NULL
   */
  public function __get($f) {
    $tx = $this;
    switch ($f) {
    case 'actorEntry': return $this->getActorEntry();
    case 'otherEntry': return $this->payerEntry->uid == $this->actorId ? $this->payeeEntry : $this->payerEntry;
    case 'payerEntry': return $this->getPayerEntry();
    case 'payeeEntry': return $this->getPayeeEntry();
    case 'payerId': return $this->payerEntry->uid;
    case 'payeeId': return $this->payeeEntry->uid;
    case 'otherId': return $this->otherEntry->uid;
    case 'actor': return r\acct($this->actorId);
    case 'actorAmount': return$this->getActorAmount();
    case 'payerAmount': return $this->payerEntry->amount;
    case 'other': return r\acct($this->otherId);
    default:
      u\EXPECT(FALSE, "unexpected field '$f' requested");
    }
  }

  private function getPayerEntry() {
    foreach ($this->entries as $entry) {
      if ($entry->entryType == ENTRY_PAYER) return $entry;
    }
    return null;
  }

  private function getPayeeEntry() {
    foreach ($this->entries as $entry) {
      if ($entry->entryType == ENTRY_PAYEE) return $entry;
    }
    return null;
  }

  private function getActorEntry() {
    foreach ($this->entries as $entry) {
      if ($entry->uid == $this->actorId) return $entry;
    }
    return null;
  }

  public function getAmount($a) {
    $total = 0;
    foreach ($this->entries as $entry) {
      if ($entry->uid == $a->id or $entry->uid == $a->jid) $total += $entry->amount;
    }
    return $total;
  }

  public function getActorAmount() {
    $total = 0;
    foreach ($this->entries as $entry) {
      if ($entry->uid == $this->actorId) $total += $entry->amount;
    }
    return $total;
  }

  public function getMyTid($me) {
    $myTid = 0;
    foreach ($this->entries as $entry) {
      if ($entry->uid == $me->uid or $entry->uid == $me->jid) {
        $myTid = max($myTid, $entry->acctTid);
      }
    }
    return $myTid;
  }

  /**
   * Add some entries to this transaction.
   */
  public function addEntries($entries) {
    $this->entries += array_merge($this->entries, $entries);
  }

  /**
   * Add an entry to this transaction.
   */
  public function addEntry($entry) {
    $this->entries[] = $entry;
  }

  /**
   * Read an existing transaction record, with its entries.
   * @param xid $xid: transaction record id
   * @return the new instance of Tx
   */
  static function read($xid, $where = '1', $subs = []) {
    /* u\EXPECT(is_integer($xid)); */
    
    $DBTX = db_transaction();
    $info = db\get('*', 'r_tx_hdrs', "(xid=:xid) AND $where", $subs + ['xid' => $xid]);
    if (!$info) return FALSE;
    $entries = r\TxEntry::readAll($xid);
    if (!$entries) return FALSE;
    unset($DBTX);
    return new Tx($info + ['entries' => $entries]);
  }
  
  /**
   * Save this transaction in the database (header record plus all entries).
   * @return the xid of the transaction
   */
  function insert($allowModification = FALSE) {
    $tx = $this;
    $DBTX = db_transaction();
    if ($allowModification and $tx->xid != 0) {
      $xid = $tx->xid;
      u\EXPECT(db\updateOrInsert('r_tx_hdrs', just(Tx::TX_HDR_FIELDS, (array)$tx), 'xid'), "failure inserting tx");
    } else {
      u\EXPECT($tx->xid == 0, "We're not allowing modification of transactions.");
      $xid = db\insert('r_tx_hdrs', just(Tx::INSERT_FIELDS, (array)$tx), 'xid');
    }
    u\EXPECT($xid, "Failed to insert transaction header record");
    foreach ($tx->entries as $entry) {
      if (empty($entry->acctTid)) {
        /* print_r(r\acct($entry->uid)); */
        $entry->acctTid = r\acct($entry->uid)->nextTid();
      }
    }
    foreach ($tx->entries as $entry) {
      $eid = $entry->insert($xid);
      u\EXPECT($eid, "Failed to insert transaction entry");
    }
    $this->xid = $xid;
    unset($DBTX);
    return $xid;
  }

  static public function readAll($uids, $starting=null, $ending=null) {
    u\EXPECT([$uids, $starting, $ending], 'array integer integer');
    $restrict = '';
    if ($starting != null) { $restrict .= " AND (t.created >= '$starting')"; }
    if ($ending != null) { $restrict .= " AND (t.created <= '$ending')"; }
    $DBTX = db_transaction();
    $sql = <<< EOF
      SELECT t.*, e.*
      FROM r_tx_hdrs t LEFT JOIN r_entries e USING (xid)
      WHERE (t.xid IN (SELECT DISTINCT xid FROM r_entries WHERE $users)) $restrict
      ORDER BY e.xid
EOF;
    $result = db\q($sql, []);
    u\EXPECT($result, "Failure reading transactions for user(s) " . print_r($uids, true));
    $lastXid = 0;  // no xid should ever be 0
    $txs = [];
    $entries = [];
    foreach ($result as $row) {
      $row = (array)$row;
      if ($row['xid'] != $lastXid) { // start of new transaction
        $lastXid = $row['xid'];
        if ($entries != []) { // there was a transaction in progress
          $txs[] = new Tx(just(Tx::TX_HDR_FIELDS, $row) + ['entries' => $entries]);
          $entries = [];
        }
      }
      $entry = new TxEntry(just(r\TxEntry::ENTRY_FIELDS, $row));
      $entries[] = $entry;
    }
    if ($entries != []) { // last one
      $txs[] = new Tx(just(Tx::TX_HDR_FIELDS, $row) + ['entries' => $entries]);
    }
    unset($DBTX);
    return $txs;
  }

  /**
   * Return the last transaction meeting the given criteria, for the given user.
   * Rebates, bonuses, and deleted transactions are ignored
   * @param array $uids: an array of uids to consider
   * @param string $where: additional criteria (defaults to 1 = any)
   * @param array $subs: optional substitutions (will be prefixed with colons)
   * @return associative array: the old transaction record (FALSE if none)
   */
  static function lastTx($uids, $where = 1, $subs = []) {
    /// debug("lastTx(" . print_r($uids, true) . ", '$where', " . print_r($subs, true) . ")");
    $txHdr = db\get('t.*', 'r_tx_hdrs t JOIN r_entries e USING(xid)',
                    "e.uid IN (:uids) AND $where ORDER BY t.created DESC LIMIT 1",
                    ['uids' => $uids] + $subs);
    if (!$txHdr) return FALSE;
    $xid = $txHdr['xid'];
    $entries = r\TxEntry::readAll($xid);
    if (!$entries) return FALSE;
    return new Tx($txHdr + ['entries' => $entries]);
  }

  /**
   * Format and return args for reporting a transaction (old or new) to the current account.
   * Not all returned args are used for any particular type of transaction.
   * Note that templates and tests depend on the names of some of these fields
   * @param acct $a: the account to report for (usually the current account)
   * @param int $getBalance: 0=don't get any balances, 1=get my balance and tid, 2=get other party's balance and tid also
   * @param float $shortfall: how much short my balance is, for a transaction (if any)
   * @return assoc array of args
   */
  public function reportArgs($me, $getMyBalance = FALSE, $shortfall = 0) {
    global $channel;
    $tx = $this;

    $payerE = $this->payerEntry;
    $payeeE = $this->payeeEntry;

    $amount = ($tx->actorId == $payerE->uid) ? $payerE->amount : $payeeE->amount;
      
    $other = r\acct(($me->isMe($payerE->uid)) ? $payeeE->uid : $payerE->uid);
    
    $banking = be\isBankUid($other->id);
    $toMe = $banking ? ($amount < 0 xor $xid < 0) : $me->isMe($payeeE->uid);
    
    $reverses = !empty($tx->reverses);
    $role = $toMe ? 'payee' : 'payer';
    $purpose = $toMe ? $payeeE->description : $payerE->description;
    $tid = $toMe ? $payeeE->acctTid : $payerE->acctTid;
    $tofrom = $toMe ? t('from') : t('to'); 
    $why = ray(R_WHYS)[$tx->goods];
    if ($getMyBalance and ($me->can(B_BUY))) { $balance = u\fmtAmt($me->avail(FOR_GOODS)); }
    else { $balance = null; }
    
    if ($amount < 0) {
      $amount = 0-$amount;
      $tofrom = t('to');
      $did = $toMe ? (($this->goods == FOR_GOODS) ? t('refunded') : t('credited')) : t('charged');
    } else {
      $did = $toMe ? ($reverses ? t('re-charged') : t('charged'))
        : (($this->channel == TX_POS and $me->co) ? t('credited') : t('paid'));
    }

    $balance = ($getMyBalance and $me->can(B_BUY)) ? $me->avail(FOR_GOODS) : 0;
    
    return ray('created created0 xid role why payerPurpose payeePurpose toMe amount tofrom balance otherUid myName otherName short success did',  // . ' role'
               u\fmtDate($tx->created), $tx->created, $tx->xid, $role, $why, $payerE->description,
               $payeeE->description, $toMe, u\fmtAmt($amount), $tofrom, $balance, $other->id, $me->fullName,
               $other->fullName, u\fmtAmt($shortfall), TRUE, $did);
  }

  /**
   * Determine whether the record can be undone
   * @param assoc $subs: (RETURNED) necessary substitutions, if any, including whatever was already there
   * @return string: the error message (FALSE if the current agent CAN undo it on behalf of the current account)
   */
  function nonoUndo(&$subs = []) {
    //    global $mya;
    //    extract(just('amount toMe data payer payee payerTid payeeTid taking', $oldRecord));
    //    $data = unserialize($data);
    if (db\exists('r_tx_hdrs', 'reversesXid=:xid', ['xid' => $this->xid])) {
      return 'already undone';
    }

    $a1 = r\acct($tx->toMe ? $tx->payeeId : $tx->payerId, $tx->actor->agentId);
    $a2 = r\acct($tx->toMe ? $tx->payerId : $tx->payeeId); // second account's permissions are irrelevant
    if ($err = r\txPermErr($a1, $a2, $tx->toMe, $tx->toMe xor $tx->actorE->amount < 0)) return $err;

    return FALSE;
  }
  
  /* /\** */
  /*  * Keep track of r, rewards, and committed amounts in the account record */
  /*  * None of these figures is authoritative except 'committed'.  */
  /*  * r and rewards are the sum of the relevant fields in transactions. */
  /*  * @return <success> */
  /*  *\/ */
  /* private function cacheTotals($entries) { */
  /*   global $channel; */

  /*   /\* if (!$a = r\acct($myId)) return FALSE; *\/ */
  /*   $cacheFields = 'balance committed lastTx access'; */
  /*   /\* extract((array) $a->account($cacheFields)); *\/ */
    
  /*   if ($channel != TX_CRON) $access = r\rTime(); // track last transaction or login (just major access) */
    
  /*   foreach ($entries as $entry) { */
  /*     extract(just('uid amount type', $entry)); */
  /*     if (is_null($amount)) { */
  /*       print_r(debug_backtrace()); */
  /*       die('amount is null'); */
  /*     } */
  /*     $a = r\acct($uid); */
  /*     $balance = $a->balance; */
  /*     $balance = round($balance + $amount, 2); */
  /*     $a->update(compact('balance')); */
  /*   } */
    
  /*   return TRUE; */
  /* } */
  
  /* public function risk($bit) {return u\getBit($this->risks, $bit);} */
  /* public function setRisk($bit, $on = TRUE) {$this->setBitx($bit, $on, 'risks');} */

} // end of class x

/* class MyX extends x { */
/*   var $a; */
  
/*   function __construct($xid = [], $entries = [], $a = 0, $save = TRUE) { */
/*     parent::__construct($xid, $entries, $save); */
/*     $this->a = $a; */
/*   }     */

/*   public function __get($f) { */
/*     $x = $this; */

/*     if ($f == 'ray') { */
/*       u\EXPECT((bool) $x->ray0, 'no xray!'); */
/*       foreach (ray('toMe byMe tid otherTid otherUid taking') as $k) $extras[$k] = $x->$k; */
/*       return $x->ray0 + $extras; */
/*     } */
/*     // NO! Makes ...2 fields fail if tx is created from ->ray (as in themX)   if (isset($x->ray0[$f])) return parent::__get($f); */

/*     foreach (ray('a xid banking toMe amount') as $k) $$k = @$x->$k; */
/*     foreach (['amount', 'xid'] as $k) $$k += 0; */
/*     if (substr($f, -1, 1) == '2' and $f = str_replace('2', '', $f)) return $banking ? '' : $x->themX->$f; */
/*     if (strpos($f, 'Purpose') and $f = str_replace('Purpose', 'For', $f)) return $x->$f; */
/*     if ($f == 'banking') return ($x->type == TX_BANK); */
/*     if ($f == 'toMe') return $banking ? ($amount < 0 xor $xid < 0) : $a->isMe($x->payee); */
/*     if ($f == 'fromMe') return $banking ? !$toMe : $a->isMe($x->payer); */
/*     if ($f == 'byMe') return $banking ?: ($x->taking xor !$toMe); */
/*     if ($f == 'reallyToMe') return ($toMe xor $amount < 0); */
/*     if ($f == 'name') return $a->fullName; */

/*     if ($f == 'for' or $f == 'purpose') return $banking // ? */
/*                                           ? ($xid < 0 ? t('bank transfer failed') : ($amount < 0 ? t('from bank') : t('to bank'))) */
/*                                           : ($toMe ? $x->payeeFor : $x->payerFor); */
    
/*     if ($f == 'agent') return $banking // ? */
/*                          ? ($a->co ? '' : $x->payer) */
/*                          : ($toMe ? $x->payeeAgent : $x->payerAgent); */
    
/*     if ($f == 'tid') return ($banking or $a->id < 0) ? $xid : ($toMe ? $x->payeeTid : $x->payerTid); */
/*     if ($f == 'otherTid') return ($banking or $a->id < 0) ? $xid : ($toMe ? $x->payerTid : $x->payeeTid); */
/*     if ($f == 'them' or $f == 'otherUid') return $banking ? 0 : ($toMe ? $x->payer : $x->payee); */
/*     if ($f == 'themAgent') return $banking ? 0 : ($toMe ? $x->payerAgent : $x->payeeAgent); */
/*     if ($f == 'themX') return r\x($x->ray, r\acct($x->them, $x->themAgent)); */
/*     return parent::__get($f); */
/*   } */

/*   /\** */
/*    * Return an appropriate message about the transaction */
/*    * @param string $type: what type of message to return (actorId, youDid, theyDid, or reverse) */
/*    * @param string $desc: how much of the description to include: none (''), vague, or full */
/*    * @param bool $withDate: <include the transaction date in the message> */
/*    * @return the message */
/*    *\/ */
/*   public function msg($msgType, $desc = '', $withDate = FALSE) { */
/*     $x = $this; */
/*     foreach (ray('toMe byMe') as $k) $extras[$k] = $x->$k; */
/*     $extras['name'] = r\acct($x->them)->fullName; // r\acct($toMe ? $x->payer : $x->payee)->fullName; */
/*     $extras['description'] = $x->toMe ? $x->payeeFor : $x->payerFor; */

/*     return self::msg0($x->ray + $extras, $msgType, $desc, $withDate); */
/*   } */
  
/*   public static function msg0($tx, $msgType, $purpose = '', $withDate = FALSE) { */
/*     extract(just('name amount toMe byMe goods description created', $tx)); */
    
/*     $youDid = t('paid,received from,received from,repaid,paid,took back from,charged,refunded'); */
/*     $theyDid = t('charged,refunded,paid,took back from,received from,repaid,paid,received from'); */
/*     $reverse = t('request a refund of this charge,reverse this refund,refund this payment,request a reversal of this charge,request a refund of this payment,reverse this refund charge,reverse this charge,request a reversal of this refund'); */
    
/*     $them = $name; */
/*     $neg = (int) ($amount < 0); */
/*     $index = 4 * $byMe + 2 * $toMe + $neg; */

/*     if ($msgType == 'actorId') $msgType = $byMe ? 'youDid' : 'theyDid'; */
/*     $types = explode(',', $$msgType); */
/*     $action = $types[$index]; */

/*     if ($msgType == 'reverse') { */
/*       if ($goods == FOR_USD) { */
/*         return in($index, [0,3,4,7]) ? t('request a reversal of this charge') : t('reverse this exchange'); */
/*       } else return $action; */
/*     }  */
    
/*     $msg = $msgType == 'youDid' ? t('You') . ' %action %them' : ('%them %action ' . t('you')); */
/*     $msg .= ' %amount'; */
/*     if ($purpose) { */
/*       if ($purpose == 'full') $purpose = '"' . $description . '"'; */
/*       if ($purpose == 'vague') $purpose = obj(R_WHYS)->$goods; */
/*       $msg .= '|purpose'; */
/*     } */
/*     if ($withDate) $msg .= '|when'; */
/*     list ($amount, $created) = [u\fmtAmt($amount), u\fmtDate($created)]; */
    
/*     return t($msg, compact(ray('action them amount purpose created'))); */
/*   } */

/*   /\** */
/*    * Format and return args for reporting a transaction (old or new) to the current account. */
/*    * Not all returned args are used for any particular type of transaction. */
/*    * Note that templates and tests depend on the names of some of these fields */
/*    * @param acct $a: the account to report to (usually the current account) */
/*    * @param array $tx: the transaction array (including xid) */
/*    * @param int $getBalance: 0=don't get any balances, 1=get my balance and tid, 2=get other party's balance and tid also */
/*    * @param float $shortfall: how much short my balance is, for a transaction (if any) */
/*    * @return assoc array of args */
/*    *\/ */
/*   public function reportArgs($getMyBalance = FALSE, $shortfall = 0) { */
/*     global $channel; */
/*     $x1 = $this; */
/*     $a1 = $x1->a; */
/*     $x2 = $x1->themX; */
/*     $a2 = r\acct($otherUid = $x1->them); */
/*     $tx = $x1->ray0; */
/*     //    $fields = 'data amount goods payer payee payerReward payeeReward toMe payerPurpose payeePurpose payerTid payeeTid created'; */
/*     $fields = 'data amount goods payer payee toMe payerPurpose payeePurpose payerTid payeeTid created'; */
/*     foreach (ray($fields) as $k) $$k = $x1->$k; */
/*     //    extract(just('rebate bonus', $data)); */

/*     $reverses = isset($data['undoes']); */
/*     $role = $toMe ? 'payee' : 'payer'; */
/*     u\both($tx, 'purpose', $toMe, $payeePurpose, $payerPurpose); */
/*     u\both($tx, 'tid', $toMe, @$payeeTid, @$payerTid); // no tid if unconfirmed */
/*     $tofrom = $toMe ? t('from') : t('to'); */
/*     //  $confirmAction = $toMe ? t('charge') : ($channel == TX_POS ? t('credit') : t('pay')); */
/*     $why = ray(R_WHYS)[$goods]; */

/*     If ($amount < 0) { // for POS */
/*       $amount = -$amount; // rephrase as positive */
/*       $tofrom = t('to'); */
/*       //    $confirmAction = $toMe ? t('credit') : t('charge'); */
/*       u\both($tx, 'did', $toMe, $goods == FOR_GOODS ?  t('refunded') : t('credited'), t('charged')); */
/*       //      if (r\isGiveback($payee, $payer, $data)) list ($tx['did'], $a2, $why) = [t('gave'), $a1, t('returning rewards to the community')]; */
/*     } else u\both($tx, 'did', $toMe, $reverses ? t('re-charged') : t('charged'), (($channel == TX_POS and $a1->co) ? t('credited') : t('paid'))); */

/*     ///     debug(compact('tx','toMe','amount','reverses','goods')); */

/*     $amount = u\fmtAmt($amount); */
/*     $short = u\fmtAmt($shortfall); */
/*     if ($getMyBalance) { */
/*       if ($a1->can(B_BUY)) $balance = u\fmtAmt($a1->avail(FOR_GOODS)); */
/*     } */
    
/*     /\*    if ($goods == FOR_GOODS) { */
/*     //    u\both($tx, 'rewardType', $toMe, t('bonus'), t('rebate')); */
/*     //      u\both($tx, 'rewardType', $toMe, t('reward'), t('reward')); */
/*     //      u\both($tx, 'rewardAmount', $toMe, u\fmtAmt(@$payeeReward + 0), u\fmtAmt(@$payerReward + 0)); */
/*     } */
/*     *\/ */
/*     $myName = $a1->fullName; */
/*     $otherName = $a2->fullName; */
/*     $created = u\fmtDate($created0 = $created); */

/*     $success = TRUE; */
/*     foreach (ray('r payer payee') as $one) unset($tx[$one]); // else preempts all subs that start thus */
/*     return compact(ray('created created0 xid role why payerPurpose payeePurpose toMe amount tofrom balance otherUid myName otherName short success')) + $tx; */
/*   } */

/*   /\** */
/*    * Return the last transaction meeting the given criteria, for the given user. */
/*    * Rebates, bonuses, and deleted transactions are ignored */
/*    * @param string $where: the criteria (defaults to 1 = any) */
/*    * @param array $subs: optional substitutions (will be prefixed with colons) */
/*    * @return associative array: the old transaction record (FALSE if none) */
/*    *\/ */
/*   static function lastTx($a, $where = 1, $subs = [], $cache = FALSE) { */
/*     /\* echo "<br>lastTx($a->id, $where, "; *\/ */
/*     /\* print_r($subs); *\/ */
/*     /\* echo ", $cache)"; *\/ */
/*     $basic = "$a->id = e.uid AND t.type>=0"; // make sure it's for this account */
/*     $sql = "SELECT t.xid FROM r_tx_hdrs t JOIN r_entries e ON t.xid = e.xid WHERE ($basic) AND ($where) ORDER BY xid DESC LIMIT 1"; */
/*     ///     debug(compact('where','subs','myid','basic','sql')); */
/*     /\* echo "<br>basic=$basic"; *\/ */
/*     /\* echo "<br>sql=$sql"; *\/ */
/*     $result = db\q($sql, $subs); */
/*     echo "<br>result="; */
/*     print_r($result); */
/*     $result = $result->fetchAssoc(); */
/*     echo "<br>result="; */
/*     print_r($result); */
/*     if (!$result) return FALSE; */
/*     return r\x($result['xid'], $a); */
/*   } */

/*   /\** */
/*    * Determine whether the record can be undone */
/*    * @param assoc $subs: (RETURNED) necessary substitutions, if any, including whatever was already there */
/*    * @return string: the error message (FALSE if the current agent CAN undo it on behalf of the current account) */
/*    *\/ */
/*   function nonoUndo(&$subs = []) { */
/*     $x = $this; */
/*     //    global $mya; */
/*     //    extract(just('amount toMe data payer payee payerTid payeeTid taking', $oldRecord)); */
/*     //    $data = unserialize($data); */
/*     if (@$x->data['undoneBy']) { */
/*       $subs['oldTid'] = $x->toMe ? $x->payeeTid : $x->payerTid; */
/*       return 'already undone'; */
/*     } */

/*     $a1 = r\acct($x->toMe ? $x->payee : $x->payer, $x->a->agentId); */
/*     $a2 = r\acct($x->toMe ? $x->payer : $x->payee); // second account's permissions are irrelevant */
/*     if ($err = r\txPermErr($a1, $a2, $x->toMe, $x->toMe xor $x->amount < 0)) return $err; */

/*     return FALSE; */
/*   } */
  
/* } */

/* /\** */
/*  * Return an existing transaction object or MyX. */
/*  * Call by: */
/*  *   x(info, a) OR x(xid, a) [returns a MyX object] OR */
/*  *   x(info) OR x(xid) */
/*  * @param int $xid: transaction record ID */
/*  * @param int $a: associated account */
/*  * @param assoc $info: initial field values for the transaction, to be created and saved in the database */
/*  *\/ */
/* function x($xid, $a = '') { */
/*   $x = $a ? new MyX($xid, null, $a, FALSE) : new X($xid, null, FALSE); */
/*   return @$x->xid ? $x : FALSE; */
/* } */

/* class MyTx extends Tx { */
  /* private $uids; */
  
  /* function __construct($uids, $info) { */
  /*   print_r($info); */
  /*   $x = $this; */
  /*   $x->uids = $uids; */
  /*   parent::__construct($info); */
  /* } */

  /* function __get($f) { */
  /*   switch ($f) { */
  /*   case 'uid': */
  /*     return $this->uid; */
  /*   case 'myTid': */
  /*     return $this->getMyTid(); */
  /*   case 'myAmount': */
  /*     return $this->getMyAmount(); */
  /*   default: */
  /*     return parent::__get($f); */
  /*   } */
  /* } */

  
  /* /\** */
  /*  * Read an existing transaction record, with its entries. */
  /*  * @param array $uids: the ids of the users associated with the account */
  /*  * @param xid $xid: transaction record id */
  /*  * @return the new instance of Tx */
  /*  *\/ */
  /* static function readMyTx($uids, $xid, $where = '1', $subs = []) { */
  /*   $DBTX = db_transaction(); */
  /*   $info = db\get('*', 'r_tx_hdrs', "(xid=:xid) AND $where", $subs + ['xid' => $xid]); */
  /*   u\EXPECT($info != false, "Transaction $xid not found"); */
  /*   $entries = r\TxEntry::readAll($xid); */
  /*   u\EXPECT(!is_null($entries), "No entries found for transaction $xid"); */
  /*   unset($DBTX); */
  /*   return new MyTx($uids, $info + ['entries' => $entries]); */
  /* } */
  
  /* /\** */
  /*  * Read all transactions for the accounts specified by the listed uids. */
  /*  * @param array $uids: the uids of the users associated with this account */
  /*  * @param timestamp $starting: the starting unix timestamp */
  /*  * @param timestamp $ending: the ending unix timestamp */
  /*  * @return an array of Txs, all the transactions of those users within those dates */
  /*  *\/ */
/*   static public function readAll($uids, $starting=null, $ending=null) { */
/*     u\EXPECT([$uids, $starting, $ending], 'array integer integer'); */
/*     $restrict = ''; */
/*     if ($starting != null) { $restrict .= " AND (t.created >= '$starting')"; } */
/*     if ($ending != null) { $restrict .= " AND (t.created <= '$ending')"; } */
/*     $DBTX = db_transaction(); */
/*     $sql = <<< EOF */
/*       SELECT t.*, e.* */
/*       FROM r_tx_hdrs t LEFT JOIN r_entries e USING (xid) */
/*       WHERE (t.xid IN (SELECT DISTINCT xid FROM r_entries WHERE $users)) $restrict */
/*       ORDER BY e.xid */
/* EOF; */
/*     $result = db\q($sql, []); */
/*     u\EXPECT($result, "Failure reading transactions for user(s) " . print_r($uids, true)); */
/*     $lastXid = 0;  // no xid should ever be 0 */
/*     $txs = []; */
/*     $entries = []; */
/*     foreach ($result as $row) { */
/*       $row = (array)$row; */
/*       if ($row['xid'] != $lastXid) { // start of new transaction */
/*         $lastXid = $row['xid']; */
/*         if ($entries != []) { // there was a transaction in progress */
/*           $txs[] = new MyTx($uids, just(Tx::TX_HDR_FIELDS, $row) + ['entries' => $entries]); */
/*           $entries = []; */
/*         } */
/*       } */
/*       $entry = new TxEntry(just(r\TxEntry::ENTRY_FIELDS, $row)); */
/*       $entries[] = $entry; */
/*     } */
/*     if ($entries != []) { // last one */
/*       $txs[] = new MyTx($uids, just(Tx::TX_HDR_FIELDS, $row) + ['entries' => $entries]); */
/*     } */
/*     unset($DBTX); */
/*     return $txs; */
/*   } */

/*   /\** */
/*    * Return the last transaction meeting the given criteria, for the given user. */
/*    * Rebates, bonuses, and deleted transactions are ignored */
/*    * @param string $where: the criteria (defaults to 1 = any) */
/*    * @param array $subs: optional substitutions (will be prefixed with colons) */
/*    * @return associative array: the old transaction record (FALSE if none) */
/*    *\/ */
/*   static function lastTx($a, $where = 1, $subs = [], $cache = FALSE) { */
/*     $DBTX = db_transaction(); */
/*     $txHdr = db\get('t.*', 'r_tx_hdrs t JOIN r_entries e USING(xid)', "e.uid='$a->id' AND `type`>=0 AND $where ORDER BY t.created DESC LIMIT 1", $subs); */
/*     if (!$txHdr) return FALSE; */
/*     $xid = $txHdr['xid']; */
/*     $entries = r\TxEntry::readAll($xid); */
/*     if (!$entries) return FALSE; */
/*     unset($DBTX); */
/*     return new MyTx([$a], $txHdr + ['entries' => $entries]); */
/*   } */

/*   /\** */
/*    * Format and return args for reporting a transaction (old or new) to the current account. */
/*    * Not all returned args are used for any particular type of transaction. */
/*    * Note that templates and tests depend on the names of some of these fields */
/*    * @param acct $a: the account to report to (usually the current account) */
/*    * @param array $tx: the transaction array (including xid) */
/*    * @param int $getBalance: 0=don't get any balances, 1=get my balance and tid, 2=get other party's balance and tid also */
/*    * @param float $shortfall: how much short my balance is, for a transaction (if any) */
/*    * @return assoc array of args */
/*    *\/ */
/*   public function reportArgs($getMyBalance = FALSE, $shortfall = 0) { */
/*     global $channel; */
/*     $x1 = $this; */
/*     $a1 = $x1->a; */
/*     $x2 = $x1->themX; */
/*     $a2 = r\acct($otherUid = $x1->them); */
/*     $tx = $x1->ray0; */
/* //    $fields = 'data amount goods payer payee payerReward payeeReward toMe payerPurpose payeePurpose payerTid payeeTid created'; */
/*     $fields = 'data amount goods payer payee toMe payerPurpose payeePurpose payerTid payeeTid created'; */
/*     foreach (ray($fields) as $k) $$k = $x1->$k; */
/* //    extract(just('rebate bonus', $data)); */

/*     $reverses = isset($data['undoes']); */
/*     $role = $toMe ? 'payee' : 'payer'; */
/*     u\both($tx, 'purpose', $toMe, $payeePurpose, $payerPurpose); */
/*     u\both($tx, 'tid', $toMe, @$payeeTid, @$payerTid); // no tid if unconfirmed */
/*     $tofrom = $toMe ? t('from') : t('to'); */
/*   //  $confirmAction = $toMe ? t('charge') : ($channel == TX_POS ? t('credit') : t('pay')); */
/*     $why = ray(R_WHYS)[$goods]; */

/*     If ($amount < 0) { // for POS */
/*       $amount = -$amount; // rephrase as positive */
/*       $tofrom = t('to'); */
/*   //    $confirmAction = $toMe ? t('credit') : t('charge'); */
/*       u\both($tx, 'did', $toMe, $goods == FOR_GOODS ?  t('refunded') : t('credited'), t('charged')); */
/* //      if (r\isGiveback($payee, $payer, $data)) list ($tx['did'], $a2, $why) = [t('gave'), $a1, t('returning rewards to the community')]; */
/*     } else u\both($tx, 'did', $toMe, $reverses ? t('re-charged') : t('charged'), (($channel == TX_POS and $a1->co) ? t('credited') : t('paid'))); */

/* ///     debug(compact('tx','toMe','amount','reverses','goods')); */

/*     $amount = u\fmtAmt($amount); */
/*     $short = u\fmtAmt($shortfall); */
/*     if ($getMyBalance) { */
/*       if ($a1->can(B_BUY)) $balance = u\fmtAmt($a1->avail(FOR_GOODS)); */
/*     } */
    
/* /\*    if ($goods == FOR_GOODS) { */
/*   //    u\both($tx, 'rewardType', $toMe, t('bonus'), t('rebate')); */
/* //      u\both($tx, 'rewardType', $toMe, t('reward'), t('reward')); */
/* //      u\both($tx, 'rewardAmount', $toMe, u\fmtAmt(@$payeeReward + 0), u\fmtAmt(@$payerReward + 0)); */
/*     } */
/*     *\/ */
/*     $myName = $a1->fullName; */
/*     $otherName = $a2->fullName; */
/*     $created = u\fmtDate($created0 = $created); */

/*     $success = TRUE; */
/*     foreach (ray('r payer payee') as $one) unset($tx[$one]); // else preempts all subs that start thus */
/*     return compact(ray('created created0 xid role why payerPurpose payeePurpose toMe amount tofrom balance otherUid myName otherName short success')) + $tx; */
/*   } */
/* } */
