<?php
namespace CG;
use CG as r;
use CG\DB as db;
use CG\Backend as be;
use CG\Util as u;

/**
 * @file
 * rCredits Transaction class (and extension MyX, which looks at the transaction from one party's view)
 *
 * Note that a transaction has at least two entries, which this class also contains
 */

/* define('TX_FLDS', 'serial type amount goods payer payee payerAgent payeeAgent for flags created'); */
define('TX_HDR_FIELDS', 'xid type goods initiator initiatorAgent flags channel box risk risks reverses created');
 
class X {
  var $ray0; // an assoc of all the transaction's fields (including the data field, still serialized)
  var $entries; // an array of the transaction's entries, each entry is an assoc
  
  /**
   * Instantiate (create or retrieve) a transaction record
   * Call by:
   *   new X(info) [saves a new transaction] OR
   *   x(xid) (see the x() function below)
   * @param int xid: the record ID
   * @param assoc $info: initial field values for the transaction, to be created and saved in the database
   * @param bool $save: <save the record in the database>
   */
  function __construct($xid = [], $entries = [], $save = TRUE) {
    if (is_array($xid)) { // creating a new record
      list($this->ray0, $this->entries) = $this->createNew($xid, $entries, $save); // create new record
    } else {
      $this->ray0 = db\get('*', 'r_tx_hdrs', 'xid=:xid', compact('xid'));
      $this->entries = db\q('SELECT * FROM r_entries WHERE xid=:xid', ['xid' => $xid]);
    }
  }    

  /**
   * Return the value of the specified field that is not a simple property of the class.
   * @param string $field: name of field value to get
   * @return the value if it exists, else NULL
   */
  public function __get($f) {
    $x = $this;
    if ($f == 'ray') return $ray0;
    if ($f == 'entries') return $entries;
    if (u\inList($f, TX_FLAGS)) return u\getBit($x->flags, $f);
    if (! array_key_exists($f, $x->ray0)) return NULL;
    return $x->ray0[$f];
  }

  /**
   * Create a new transaction record set in the database (main record plus optional related records).
   * @param assoc $info: array of field values for new transaction
   *   amount: (required) how much to transfer
   *   payer, payee: (required) uids
   *   for: purpose of the transaction OR a simple array (payer's purpose, payee's purpose)
   *   etc.
   * @param bool $save: <save the record in the database>
   * @return an array containing the record assoc (FALSE if saving fails) and an array of entry assocs
   */
  private function createNew($info, $entries, $save) {
    extract($info);
    $xray = $info;
    if (!$save) return [$xray, $entries];
    
    $DBTX = db_transaction();
    $xid = db\insert('r_tx_hdrs', just(TX_HDR_FIELDS, $xray), 'xid');
    if (!$xid) {
      $DBTX->rollback();
      return FALSE;
    }
    $xray['xid'] = $xid;
    $newEntries = [];
    foreach ($entries as $entry) {
      $entry['xid'] = $xid;
      $eid = db\insert('r_entries', $entry, 'id');
      if (!$eid) {
        $DBTX->rollback();
        return FALSE;
      }
      $entry['id'] = $eid;
      $newEntries[] = $entry;
      $this->entries = $newEntries;
    }
    $this->cacheTotals($newEntries);
    return [$xray, $newEntries];
  }

  /*
    private function rewardSetup($serial, $type, $payee, $amount, $for, $created) {
    $payer = $payerAgent = r\acct($payee)->community;
    $payeeAgent = $payee;
    $goods = FOR_USD; // not actually for USD, but certainly not for goods or non-goods, since not an exchange
    
    return $this->setup(compact(ray(TX_FLDS)));
    }
  */
  
  /* /\** */
  /*  * Create a new transaction and set up all the important fields. */
  /*  * @param assoc $info: transaction info. */
  /*  *   amount: (required) how much to transfer */
  /*  *   payer, payee: (required) uids */
  /*  *   for: purpose of the transaction OR a simple array (payer's purpose, payee's purpose) */
  /*  *   etc. */
  /*  * @param array $entries: info about each entry for the transaction */
  /*  * @return both arrays, with some extra field information added */
  /*  *\/ */
  /* private function setup($info, $entries) { */
  /*   global $channel, $boxUser; // through what medium was the transaction requested (web, SMS, etc.), what machine */
  /*   //    $fields = 'type data flags goods amount payer payee payerFor payerAgent payeeAgent created rebate bonus'; */
  /*   //    $fields = 'type data flags goods amount payer payee payerReward payeeReward payerFor payerAgent payeeAgent created'; */
  /*   $fields = 'type goods initiator initiatorAgent flags created'; */
  /*   extract(just($fields . TX_FLAGS, $info)); // flags including offline, short, etc. */
  /*   u\setDft($type, TX_TRANSFER); */
  
  /*   u\setDft($goods, FOR_USD); */
  /*   u\setDft($flags, 0); */
  /*   u\setDft($created, r\rTime()); */
  
  /*   $goods += 0; */
  /*   $box = isset($boxUser) ? $boxUser : 0; */
  /*   //    if (r\isGiveback($payee, $payer, @$data)) $type = TX_GIVEBACK; */
  /*   //    if (!isset($payerReward) and !isset($payeeReward)) extract($this->getRewards($info)); // payerReward and payeeReward */
  
  /*   foreach (ray(TX_FLAGS) as $k) { */
  /*     if (isset($$k)) u\setBit($flags, $k); */
  /*     unset($info[$k]); */
  /*   } */
  
  /*   //    if (isGAME and $payer > 0) $info += ['members' => $a1->members]; */
  
  /*   $newInfo = compact(ray($fields . ' channel box')) + $info; */
  
  /*   // Now work on entries */
  /*   $newEntries = []; */
  /*   foreach ($entries as $entry) { */
  /*     $fields = 'amount uid agentUid description acctTid created'; */
  /*     extract(just($fields, $entry)); // flags including offline, short, etc. */
  
  /*     u\EXPECT(compact(ray('amount uid')), 'float zid'); */
  /*     u\setDft($agentUid, $uid); */
  /*     u\setDft($created, r\rTime()); */
  
  /*     if ($type != TX_BANK and !isset($payerFor)) { */
  /*       u\setDft($description, ray(R_WHYS)[$goods]); */
  /*     } */
  
  /*     $entries[] = compact(ray($fields)) + $entry; */
  /*   } */
  
  /*   return [$info, $entries]; */
  /* } */
  
  /**
   * Return the appropriate reward amounts for the given data.
   *//*
       private static function getRewards($info) {
       extract(just('payer payee amount goods', $info));
       $fields = 'payerReward payeeReward';
       if (@$goods != FOR_GOODS or r\owning($payer, $payee)) {
       return ray($fields, 0, 0); // no rewards for an incestuous tx
       } else return ray($fields, r\reward($payer, $payee, $amount, TRUE), r\reward($payer, $payee, $amount, FALSE));
       }*/
  
  /**
   * Keep track of r, rewards, and committed amounts in the account record
   * None of these figures is authoritative except 'committed'. 
   * r and rewards are the sum of the relevant fields in transactions.
   * @return <success>
   */
  private function cacheTotals($entries) {
    global $channel;

    /* if (!$a = r\acct($myId)) return FALSE; */
    $cacheFields = 'balance committed lastTx access';
    /* extract((array) $a->account($cacheFields)); */
    
    if ($channel != TX_CRON) $access = r\rTime(); // track last transaction or login (just major access)
    
    foreach ($entries as $entry) {
      extract(just('uid amount type', $entry));
      if (is_null($amount)) {
        print_r(debug_backtrace());
        die('amount is null');
      }
      $a = r\acct($uid);
      $balance = $a->balance;
      $balance = round($balance + $amount, 2);
      $a->update(compact('balance'));
    }
    
    return TRUE;
  }
  
  /**
   * Update the saved record in the database with the given data.
   * Call by:
   *   update($info, $just); OR
   *   update($fields, $value1, ...)
   * @param assoc $info: data to update
   * @param string $just: update only these fields (update all if NULL, none if '')
   * @param string $fields: space-delimited list of field names
   * @param mixed $value1 (etc): new values for those fields
   * @return: TRUE if update succeeds, FALSE if update fails
   */
  public function update($info, $entries, $just = NULL) {
    $x = $this;
    if (!is_array($info)) { // second syntax
      $args = func_get_args();
      $keys = ray(array_shift($args));
      u\EXPECT(count($keys) == count($args), 'assoc arg count mismatch');
      return $x->update(array_combine($keys, $args));
    }
    if (isset($just)) $info = just($just, $info);

    if ($flagFields = just(TX_FLAGS, $info)) {
      $flags = isset($info['flags']) ? $info['flags'] : $x->flags;
      foreach ($flagFields as $k => $v) {
        u\setBit($flags, u\consta('b', $k), $v);
        unset($info[$k]);
      }
    }
    //NO! makes themX fail!   foreach ($info as $k => $v) $x->ray0[$k] = $v; // update internal cache
    $info['xid'] = $x->xid; // make sure db\update gets this
    return db\update('r_txs', $info, 'xid');
  }

  /* /\** */
  /*  * Set a field of an old transaction for the user and update their cache. */
  /*  * @param assoc $toChange: $fieldName => $newValue */
  /*  *   $fieldName: the field to update */
  /*  *   $newValue: what to update it to */
  /*  * NOTE: tx data['changes'][time agent][] = [field, oldValue] (this gives a complete history of the transaction) */
  /*  *     (prefixes added to the payerFor or payeeFor fields when changing state will not be included in changes) */
  /*  *\/ */
  /* public function setFields($toChange) { */
  /*   $x = $this; $xid = $x->xid; $xray = $x->ray0; */
  /*   global $mya; */
    
  /*   //    extract(just('data payer payee amount goods payerFor payeeFor payerReward payeeReward created channel', $xray)); */
  /*   extract(just('data payer payee amount goods payerFor payeeFor created channel', $xray)); */
  /*   extract($toChange, EXTR_PREFIX_ALL, 'ch'); */
  /*   $chKeys = array_keys($toChange); */
  /*   $dataRay = unserialize($data); */

  /*   $DBTX = \db_transaction(); */

  /*   if (isset($ch_goods) or isset($ch_amount)) { // financial info changed */
  /*     //      foreach (ray('amount payerReward payeeReward') as $k) $xrayNeg[$k] = -$$k; // negate the transaction and rewards amounts */
  /*     $xrayNeg['amount'] = -$amount; */
  /*     $x->cacheBothTotals([$xrayNeg + $xray]); // subtract old values from cache */

  /*     //      $toChange += $this->getRewards($toChange + $xray); */
  /*     $x->cacheBothTotals([$toChange + $xray]); // cache values for the revised transaction */
  /*   } */

  /*   $agt = $mya->proSe ? '' : (' ' . $mya->agentA->mainQid); // don't record agent if proSe */
  /*   $dataRay['changes'][r\rTime() . $agt] = just($chKeys, $xray); */
  /*   $toChange['data'] = $dataRay; */
  /*   $x->update($toChange); */

  /*   unset($DBTX); // commit */
  /* } */

  /**
   * Set the bit in the given integer bit collection field to the given value.
   * @param int $bit: number of bit to set (0 - 31)
   * @param bool $on: whether to set it ON or OFF
   */
  private function setBitx($bit, $on = TRUE, $field = 'risks') {
    $n = $this->$field;
    u\setBit($n, $bit, $on);
    $this->update($field, $n);
  }
  
  public function risk($bit) {return u\getBit($this->risks, $bit);}
  public function setRisk($bit, $on = TRUE) {$this->setBitx($bit, $on, 'risks');}

} // end of class x

class MyX extends x {
  var $a;
  
  function __construct($xid = [], $entries = [], $a = 0, $save = TRUE) {
    parent::__construct($xid, $entries, $save);
    $this->a = $a;
  }    

  public function __get($f) {
    $x = $this;

    if ($f == 'ray') {
      u\EXPECT((bool) $x->ray0, 'no xray!');
      foreach (ray('toMe byMe tid otherTid otherUid taking') as $k) $extras[$k] = $x->$k;
      return $x->ray0 + $extras;
    }
    // NO! Makes ...2 fields fail if tx is created from ->ray (as in themX)   if (isset($x->ray0[$f])) return parent::__get($f);

    foreach (ray('a xid banking toMe amount') as $k) $$k = @$x->$k;
    foreach (['amount', 'xid'] as $k) $$k += 0;
    if (substr($f, -1, 1) == '2' and $f = str_replace('2', '', $f)) return $banking ? '' : $x->themX->$f;
    if (strpos($f, 'Purpose') and $f = str_replace('Purpose', 'For', $f)) return $x->$f;
    if ($f == 'banking') return ($x->type == TX_BANK);
    if ($f == 'toMe') return $banking ? ($amount < 0 xor $xid < 0) : $a->isMe($x->payee);
    if ($f == 'fromMe') return $banking ? !$toMe : $a->isMe($x->payer);
    if ($f == 'byMe') return $banking ?: ($x->taking xor !$toMe);
    if ($f == 'reallyToMe') return ($toMe xor $amount < 0);
    if ($f == 'name') return $a->fullName;

    if ($f == 'for' or $f == 'purpose') return $banking // ?
                                          ? ($xid < 0 ? t('bank transfer failed') : ($amount < 0 ? t('from bank') : t('to bank')))
                                          : ($toMe ? $x->payeeFor : $x->payerFor);
    
    if ($f == 'agent') return $banking // ?
                         ? ($a->co ? '' : $x->payer)
                         : ($toMe ? $x->payeeAgent : $x->payerAgent);
    
    if ($f == 'tid') return ($banking or $a->id < 0) ? $xid : ($toMe ? $x->payeeTid : $x->payerTid);
    if ($f == 'otherTid') return ($banking or $a->id < 0) ? $xid : ($toMe ? $x->payerTid : $x->payeeTid);
    if ($f == 'them' or $f == 'otherUid') return $banking ? 0 : ($toMe ? $x->payer : $x->payee);
    if ($f == 'themAgent') return $banking ? 0 : ($toMe ? $x->payerAgent : $x->payeeAgent);
    if ($f == 'themX') return r\x($x->ray, r\acct($x->them, $x->themAgent));
    return parent::__get($f);
  }

  /**
   * Return an appropriate message about the transaction
   * @param string $type: what type of message to return (actor, youDid, theyDid, or reverse)
   * @param string $desc: how much of the description to include: none (''), vague, or full
   * @param bool $withDate: <include the transaction date in the message>
   * @return the message
   */
  public function msg($msgType, $desc = '', $withDate = FALSE) {
    $x = $this;
    foreach (ray('toMe byMe') as $k) $extras[$k] = $x->$k;
    $extras['name'] = r\acct($x->them)->fullName; // r\acct($toMe ? $x->payer : $x->payee)->fullName;
    $extras['description'] = $x->toMe ? $x->payeeFor : $x->payerFor;

    return self::msg0($x->ray + $extras, $msgType, $desc, $withDate);
  }
  
  public static function msg0($tx, $msgType, $purpose = '', $withDate = FALSE) {
    extract(just('name amount toMe byMe goods description created', $tx));
    
    $youDid = t('paid,received from,received from,repaid,paid,took back from,charged,refunded');
    $theyDid = t('charged,refunded,paid,took back from,received from,repaid,paid,received from');
    $reverse = t('request a refund of this charge,reverse this refund,refund this payment,request a reversal of this charge,request a refund of this payment,reverse this refund charge,reverse this charge,request a reversal of this refund');
    
    $them = $name;
    $neg = (int) ($amount < 0);
    $index = 4 * $byMe + 2 * $toMe + $neg;

    if ($msgType == 'actor') $msgType = $byMe ? 'youDid' : 'theyDid';
    $types = explode(',', $$msgType);
    $action = $types[$index];

    if ($msgType == 'reverse') {
      if ($goods == FOR_USD) {
        return in($index, [0,3,4,7]) ? t('request a reversal of this charge') : t('reverse this exchange');
      } else return $action;
    } 
    
    $msg = $msgType == 'youDid' ? t('You') . ' %action %them' : ('%them %action ' . t('you'));
    $msg .= ' %amount';
    if ($purpose) {
      if ($purpose == 'full') $purpose = '"' . $description . '"';
      if ($purpose == 'vague') $purpose = obj(R_WHYS)->$goods;
      $msg .= '|purpose';
    }
    if ($withDate) $msg .= '|when';
    list ($amount, $created) = [u\fmtAmt($amount), u\fmtDate($created)];
    
    return t($msg, compact(ray('action them amount purpose created')));
  }

  /**
   * Format and return args for reporting a transaction (old or new) to the current account.
   * Not all returned args are used for any particular type of transaction.
   * Note that templates and tests depend on the names of some of these fields
   * @param acct $a: the account to report to (usually the current account)
   * @param array $tx: the transaction array (including xid)
   * @param int $getBalance: 0=don't get any balances, 1=get my balance and tid, 2=get other party's balance and tid also
   * @param float $shortfall: how much short my balance is, for a transaction (if any)
   * @return assoc array of args
   */
  public function reportArgs($getMyBalance = FALSE, $shortfall = 0) {
    global $channel;
    $x1 = $this;
    $a1 = $x1->a;
    $x2 = $x1->themX;
    $a2 = r\acct($otherUid = $x1->them);
    $tx = $x1->ray0;
    //    $fields = 'data amount goods payer payee payerReward payeeReward toMe payerPurpose payeePurpose payerTid payeeTid created';
    $fields = 'data amount goods payer payee toMe payerPurpose payeePurpose payerTid payeeTid created';
    foreach (ray($fields) as $k) $$k = $x1->$k;
    //    extract(just('rebate bonus', $data));

    $reverses = isset($data['undoes']);
    $role = $toMe ? 'payee' : 'payer';
    u\both($tx, 'purpose', $toMe, $payeePurpose, $payerPurpose);
    u\both($tx, 'tid', $toMe, @$payeeTid, @$payerTid); // no tid if unconfirmed
    $tofrom = $toMe ? t('from') : t('to');
    //  $confirmAction = $toMe ? t('charge') : ($channel == TX_POS ? t('credit') : t('pay'));
    $why = ray(R_WHYS)[$goods];

    If ($amount < 0) { // for POS
      $amount = -$amount; // rephrase as positive
      $tofrom = t('to');
      //    $confirmAction = $toMe ? t('credit') : t('charge');
      u\both($tx, 'did', $toMe, $goods == FOR_GOODS ?  t('refunded') : t('credited'), t('charged'));
      //      if (r\isGiveback($payee, $payer, $data)) list ($tx['did'], $a2, $why) = [t('gave'), $a1, t('returning rewards to the community')];
    } else u\both($tx, 'did', $toMe, $reverses ? t('re-charged') : t('charged'), (($channel == TX_POS and $a1->co) ? t('credited') : t('paid')));

    ///     debug(compact('tx','toMe','amount','reverses','goods'));

    $amount = u\fmtAmt($amount);
    $short = u\fmtAmt($shortfall);
    if ($getMyBalance) {
      if ($a1->can(B_BUY)) $balance = u\fmtAmt($a1->avail(FOR_GOODS));
    }
    
    /*    if ($goods == FOR_GOODS) {
    //    u\both($tx, 'rewardType', $toMe, t('bonus'), t('rebate'));
    //      u\both($tx, 'rewardType', $toMe, t('reward'), t('reward'));
    //      u\both($tx, 'rewardAmount', $toMe, u\fmtAmt(@$payeeReward + 0), u\fmtAmt(@$payerReward + 0));
    }
    */
    $myName = $a1->fullName;
    $otherName = $a2->fullName;
    $created = u\fmtDate($created0 = $created);

    $success = TRUE;
    foreach (ray('r payer payee') as $one) unset($tx[$one]); // else preempts all subs that start thus
    return compact(ray('created created0 xid role why payerPurpose payeePurpose toMe amount tofrom balance otherUid myName otherName short success')) + $tx;
  }

  /**
   * Return the last transaction meeting the given criteria, for the given user.
   * Rebates, bonuses, and deleted transactions are ignored
   * @param string $where: the criteria (defaults to 1 = any)
   * @param array $subs: optional substitutions (will be prefixed with colons)
   * @return associative array: the old transaction record (FALSE if none)
   */
  static function lastTx($a, $where = 1, $subs = [], $cache = FALSE) {
    /* echo "<br>lastTx($a->id, $where, "; */
    /* print_r($subs); */
    /* echo ", $cache)"; */
    $basic = "$a->id = e.uid AND t.type>=0"; // make sure it's for this account
    $sql = "SELECT t.xid FROM r_tx_hdrs t JOIN r_entries e ON t.xid = e.xid WHERE ($basic) AND ($where) ORDER BY xid DESC LIMIT 1";
    ///     debug(compact('where','subs','myid','basic','sql'));
    /* echo "<br>basic=$basic"; */
    /* echo "<br>sql=$sql"; */
    $result = db\q($sql, $subs);
    echo "<br>result=";
    print_r($result);
    $result = $result->fetchAssoc();
    echo "<br>result=";
    print_r($result);
    if (!$result) return FALSE;
    return r\x($result['xid'], $a);
  }

  /**
   * Determine whether the record can be undone
   * @param assoc $subs: (RETURNED) necessary substitutions, if any, including whatever was already there
   * @return string: the error message (FALSE if the current agent CAN undo it on behalf of the current account)
   */
  function nonoUndo(&$subs = []) {
    $x = $this;
    //    global $mya;
    //    extract(just('amount toMe data payer payee payerTid payeeTid taking', $oldRecord));
    //    $data = unserialize($data);
    if (@$x->data['undoneBy']) {
      $subs['oldTid'] = $x->toMe ? $x->payeeTid : $x->payerTid;
      return 'already undone';
    }

    $a1 = r\acct($x->toMe ? $x->payee : $x->payer, $x->a->agentId);
    $a2 = r\acct($x->toMe ? $x->payer : $x->payee); // second account's permissions are irrelevant
    if ($err = r\txPermErr($a1, $a2, $x->toMe, $x->toMe xor $x->amount < 0)) return $err;

    return FALSE;
  }
  
}

/**
 * Return an existing transaction object or MyX.
 * Call by:
 *   x(info, a) OR x(xid, a) [returns a MyX object] OR
 *   x(info) OR x(xid)
 * @param int $xid: transaction record ID
 * @param int $a: associated account
 * @param assoc $info: initial field values for the transaction, to be created and saved in the database
 */
function x($xid, $a = '') {
  $x = $a ? new MyX($xid, null, $a, FALSE) : new X($xid, null, FALSE);
  return @$x->xid ? $x : FALSE;
}
