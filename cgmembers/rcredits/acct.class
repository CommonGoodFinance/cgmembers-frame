<?php
namespace CG;
use CG as r;
use CG\DB as db;
use CG\Backend as be;
use CG\Util as u;
use CG\Web as w;
use CG\Admin as a;

/**
 * @file
 * %PROJECT Account class
 */

define('SSN_TIMEOUT_MSG', t('No data returned from ssnLookup'));
 
class Acct {
  public $id; // the account's record id
  public $agentId; // record id (in the agent's regional server) of whoever is acting on behalf of the account
  //  var $mainQid; // nearly alphabetic representation of id, id, and region for external queries
  public $qo; // qid object
  
  private static $perms = []; // permissions for all acct objects, indexed by id and agent
  public static $rs = []; // account records for all acct objects, indexed by id
  
  /**
   * Instantiate (create or retrieve) a member account for transactions and/or contact
   * @param mixed $info (either assoc or array):
   *   (1) an assoc: initial field values for the account, to be created in the database, including at least one of the following:
   *     'uid' the record id
   *     'phone' is contact phone (in standard +ddddddddddd format) OR
   *     'number' is cell phone (in standard +ddddddddddd format -- use for phone also) OR
   *     'email' is email address
   *     (This function assumes that the field values not sufficient to identify an existing user)
   *   (2) a flat array of user table IDs: [uid, agent] where uid is the main account and agent is the agent's id
   */
  function __construct($info = []) {
    if (!is_numeric(key($info))) { // u\isAssoc($info)) { // specifying field values
      $this->createNew($info); // create new db record
    } else {
      list($this->id, $this->agentId) = $info;
    } // called from r\acct()
    $this->qo = r\qo($this->id, $this->proSe ? '' : $this->agentId);
  }    

  /**
   * Create a new account record in the database.
   * @param assoc $info: array of field values for new account (only fullName is required)
   */
  private function createNew($info) {
    extract($info);

    extract(u\exactly('email fullName legalName flags state zip created country number uid region', $info,
                      [ strtolower(u\randomString(10, 'word')) . '@' . EMAILX, null, null, 0, null, null, r\rTime(), US_COUNTRY_ID, null, null, null ]));
    extract(u\exactly('community', $info, r\communityUid($zip)));
    extract(u\exactly('login', $info, $created));
    extract(u\exactly('access', $info, $login));
    extract(u\exactly('phone', $info, $number));
    extract(u\exactly('name', $info, r\uniqueName($fullName, $info)));

    if (!empty($phone)) $phone = u\fmtPhone($phone, '+n');
    
    $co = ($flags & u\bit(B_CO));

    if (!empty($state) and !is_numeric($state)) { // allow state abbrevs within US
      $state = db\get('id', 'r_states', 'abbreviation=:state and country_id=:US_COUNTRY_ID', compact('state'));
    }
                                     
    $stepsDone = $uid == 1 ? [] : r\stepsDone0();
    foreach (ray($co ? 'proxies connect ssn' : 'company relations') as $k) unset($stepsDone[$k]);

    if (empty($uid) and empty($region)) $region = empty($zip) ? -r\region($country, $state, $zip) : -r\uidRegion($community);

    $record = @compact('uid', 'name');
    
    $DBTX = db_transaction();
    $uid = r\regionalInsert('users', 'uid', $record, $region);
    u\EXPECT($uid != 0, 'zero regionalinsert');
    if (!$co) {
      extract(u\exactly('cardCode', $info, r\cardCode(r\qid($uid))));
    }
    extract(u\exactly('emailCode', $info, r\cardCode(r\qid($uid))));
    
    //    if (isset($number)) $success = SMS\create($number, $uid);

    list ($this->id, $this->agentId) = array($uid, $uid); // finish creating the object

    self::$rs[$this->id] = (object) $record;

    foreach (ray('number region') as $k) unset($info[$k]);
    u\preray(@compact(ray('phone email pass fullName legalName flags state community created login access emailCode cardCode stepsDone')), $info); // things we may have added or changed
    $result = $this->update($info); // this is a lot easier to do after saving the record

    unset($DBTX); // commit
  }

  /**
   * Setup acct variables, returning FALSE on error.
   * @param id/qid $id: the account's record id or qid (DEFAULT to myid)
   * @param id/qid $agent: the agent's record id or qid (DEFAULT to same as $id)
   * @param string $error: (RETURNED) the error message, if any
   * @param bool $test: <this is only a test, do not die on error>
   * @return [$id, $agent] where id and agent are actual record IDs
   */
  public static function viable($id00, $agent0='', &$error='', $test = TRUE) {
    /* print_r("viable($id00, $agent0,?,$test)"); */
    if (is_numeric($id00) and is_numeric($agent0)) return [$id00, $agent0];
    $id0 = $id00;
    if (strpos($id0, AGT_MARK)) list ($id0, $agentCode) = explode(AGT_MARK, $id0); // new company qid format

    if ($error = u\EXPECT(compact(ray('id0 agent0')), 'zid|qid|assoc empty|id|qid', $test)) return FALSE;
    if ($error = u\EXPECT((bool) $id0, 'null uid in new r\Acct()', $test)) return FALSE;
    //    if ($error = u\EXPECT(!(strpos($id0, R_AGENT_MARK) and $agent0), 'agent already specified in qid', $test)) return FALSE;
    list ($id, $agent) = u\isZid($id0) ? [$id0, $agent0 ?: $id0] : r\qo($id00, $agent0)->ia; // handle

    if (u\isQid($agent0)) {
      list ($agent, $zot) = r\qo($agent0)->ia;
      if ($error = u\EXPECT($agent == $zot, 'agent agent not allowed', $test)) return FALSE;
    }
    $got = (bool) self::getRecord($id); // read the record into cache
    if ($error = u\EXPECT($got, 'That account does not exist.', $test)) return FALSE; // don't use t() here (many calls)
    if (isset($agentCode)) $agent = r\qo($id0 . AGT_MARK . $agentCode)->agent; // new company qid format

    if ($error = u\EXPECT($id and $agent, "Missing acct property: [$id, $agent]", $test)) return FALSE;
    return [$id, $agent];
  }
  
  private static function getRecord($uid, $reread = FALSE) {
    /* print_r("getRecord($uid, $reread)"); */
    if (@self::$rs[$uid] and !$reread) return self::$rs[$uid];
    if (!$row = db\get('*', 'users', compact('uid'))) { // no such record here
      if (TRUE) return FALSE; // not foreign either
      // contact other server here, for a subset of the record
    }
    return self::$rs[$uid] = (object) $row;
  }

  /**
   * Read in the account record, if we haven't yet.
   * This function should be called before any reference to self::$rs[$this->id] (except in contructor).
   * @param bool $force: reread even if we already have an account record (used only externally)
   */
  public function reread($force = FALSE) {
    if (!@self::$rs[$this->id] or $force) self::getRecord($this->id, TRUE);
  }
  
  /**
   * Return the value of the specified field that is not a simple property of the acct class.
   * This function reads the account record from the database if it hasn't been read yet.
   * Many of these fields are slightly tweaked fields from the users table (for example, unserialized or decrypted).
   * @param string $field: name of field value to get
   * @return the value if it exists, else NULL
   */
  public function __get($field) {
    global $mya, $pwV;
    $this->reread(); // make sure record has been read in

    // The following fields are always only for the current user
    switch ($field) {
    case 'balance':  // special case, it's the same in both
      return db\get('balance', 'users', 'uid=:id', ['id' => $this->id]);
    case 'lastTx':
      return $this->lastTx();
    }
      
    if (u\starts($field, 'o_')) { // ignore joinedness of the account, if it is joint ("own" account)
      $field = substr($field, 2);
    } elseif (u\starts($field, 'j_')) { // concatenate joint fields
      $field = substr($field, 2);
      return $this->o($field) . ($this->jid ? ' & ' . $this->jA->o($field) : '');
    } else { // tests for field must precede tests for jid or slave (else loop)
      if (in($field, JOINT_FLDS) and $this->jid) return round($this->o($field) + $this->jA->o($field), 2); // sum joint fields
      if (in($field, MASTER_FLDS) and $this->slave) return $this->jA->o($field); // master only
    }

    // From here down, everything should be for "own" account
    $nick = $this->getNick($field);
    if ($nick == 'can') return $this->can(u\consta('b', $field));
    if ($nick == 'rel') return $this->proSe ? NULL : $this->relFld($field);
    if ($nick == 'coy') return $this->co ? $this->coFld($field) : NULL;
    if ($nick == 'ctt' and $field != 'cttyA') return $this->cttyA->can(u\consta('b', substr($field, 4))); // ctty bit
    
    if ($field == 'mainQid') return $this->qo->mainQid;
    if ($field == 'isAdmin2') return (bool) ($this->agentA->flags & u\bit(B_ADMIN2)); // not ->can() included by cAdmin etc. (see note in can())
    //    if ($field == 'email') return strpos($this->mail, '@') ? $this->mail : u\decry('P', $this->mail);
    //    if ($field == 'phone') return u\starts($ph = @self::$rs[$this->id]->phone, '+') ? $ph : u\decry('P', $ph);
    if ($field == 'email') return u\decryIf('P', @self::$rs[$this->id]->email);
    if ($field == 'phone') return u\decryIf('P', @self::$rs[$this->id]->phone);
    if ($field == 'phoneDash') return u\fmtPhone($this->phone, '-');
    if ($field == 'st') return r\realState($this->state, $this->country);
    if ($field == 'agentA') return r\acct($this->agentId);
    if ($field == 'proSe') return ($this->id == $this->agentId);
    if ($field == 'qid') return $this->qo->qid;
    if ($field == 'bestName') return $this->shortName ?: $this->fullName;
    if ($field == 'isCtty') return ($this->id < 0); // or ($this->id == $this->community); (regions are communities too)
    if ($field == 'isRegion') return (substr($this->name, -1, 1) == '.');
    if ($field == 'cttyA') return r\acct($this->community);
    if ($field == 'region') return r\uidRegion($this->id);
    if ($field == 'regionA') return r\acct($this->region);
    if ($field == 'regionName') return ($regionA = $this->regionA) ? $regionA->fullName : (PROJECT . ' ' . db\get('name', 'r_regions r INNER JOIN r_states s ON s.abbreviation=r.st', 's.country_id=:US_COUNTRY_ID AND r.region=:reg', ['reg' => $this->qo->region]));
    if ($field == 'url') return ($this->isRegion ? '' : strtr($this->fullName, [PROJECT=>'', ' '=>'']) . $this->st . '.') . CG_DOMAIN; // applies only to communities (->cttyUrl)
    if ($field == 'legalNameDpy') return str_replace('_', ' ', $this->legalName); // for u\parseName of names like Jay di_Fiori
    if ($field == 'owns') return !$this->risk('rents');
    if ($field == 'creditLine') return -$this->floor;
    if ($field == 'closed') return ($this->activated and !$this->ok); // data[newAccount] has new qid, if any
    if ($field == 'hasBank') return $this->risk('hasBank');
    if ($field == 'balDpy') return $this->balance - $this->partRounds; // always display balance without partial roundups
    if ($field == 'lowSecurity') return u\n2ai(substr($this->created, -5, 5), 3); // result is 3 chars long
    if ($field == 'inviteCode') return $this->mainQid . $this->lowSecurity;
    if ($field == 'slave') return ($jid = $this->jid and $jid < $this->id); // slave in a joint account
    if ($field == 'jA') return $this->jid ? r\acct($this->jid) : NULL;
    if ($field == 'masterA') return $this->slave ? $this->jA : $this;
    if ($field == 'helperA') return $this->helper ? r\acct($this->helper) : '';
    if ($field == 'iclubid') return $this->state == 1020 ? db\get('uid', 'users', ':IS_CO AND (community=:ctty OR 1) AND :IS_ICADMIN', ray('ctty', $this->community)) : NULL; // investment club uid
    if ($field == 'isIClub') return ($this->iclubid == $this->id);
    if ($field == 'prefsSet') return !is_null($this->o_minimum); // preferences have been set at least once
    if ($field == 'hasCustomers') return db\exists('r_relations', 'main=:id AND :IS_CUSTOMER', ['id' => $this->id]);
    if ($field == 'superAdmin') return ($this->agentId == 1) ?: (u\test() and $this->admin and $this->agentA->name == 'abeone');
    if ($field == 'bankInfo') return (!$routing = substr($this->bankAccount, 4, 9)) ? NULL
                                : db\get('*', 'r_banks', 'route=:routing', compact('routing'));
    if ($field == 'tempPhotoFilename') return r\pic("$this->mainQid.jpg");
      
    if (isset(self::$rs[$this->id]->$field)) { // actual database field?
      $result = @self::$rs[$this->id]->$field; // returns NULL if field not set
    } else $result = $this->getSpecial($field); // set up caches for aggregate field and get value

    if ($nick == 'raw') return $result;
    if ($field == 'hasPhoto') return db\exists('r_photos', 'uid=:id', ['id' => $this->id]);
    if ($field == 'photo') return ($result = db\get('photo', 'r_photos', 'uid=:id', ['id' => $this->id])) ? u\decry('H', $result) : '';
    if ($field == 'changes') {
      $rows = db\rows('*', 'r_changes', 'uid=:id', ['id' => $this->id]);
      foreach ($rows as $i => $row) {
        foreach (ray('oldValue newValue') as $k) if ($type = u\crypted($row->$k)) $rows[$i]->$k = u\decry($type, $row->$k);
      }
      return $rows;
    }
    if ($field == 'balance') {
      /* $this->reread(true); */
      return db\get('balance', 'users', 'uid=:id', ['id' => $this->id]);
    }
    if (in($field, 'data secure vsecure') and !is_array($result)) { // special not yet arrayed
      if (!$result) return [];
      if ($field != 'data') $result = u\decry('S', $result);
      return (self::$rs[$this->id]->$field = unserialize($result));
    }

    return $result;
  }

  /**
   * Return the 3-character field prefix, if any, and remove it from the field name.
   */
  private function getNick(&$field) {
    $nick = substr($field, 0, 3); // possibly meaningful prefix (ctt if the prefix is ctty)
    if (in($nick, 'can raw rel coy') and $field != 'rawChanges') {
      $field = lcfirst(substr($field, 3));
      return $nick;
    }
    if (in($field, REL_FLDS . ' ' . REL_FLAGS)) return 'rel';
    if (in($field, CO_FLDS)) return 'coy';
    if (in($field, B_LIST . ' ' . B_CTTY_BITS)) return 'can';
    return $nick;
  }

  /**
   * Cache the set of special fields of which the given field is a member.
   * @param mixed $field: possibly special field name (data/secure)
   * @return the field value
   */
  private function getSpecial($field) {
    foreach (ray('data secure vsecure') as $k) {
      if ($this->special($field, strtoupper($k))) {
        ///        u\EXPECT(is_array($this->$k) or !$this->$k, 'special field not ray: ' . print_r($this->$k, 1) . ' isarray:' . is_array($this->$k));
        //        if ($set = $this->$k ?: []) u\preray($set, self::$rs[$this->id]); // cache the special field
        $set = $this->$k ?: []; // special field $k gets cached by call to $this->$k
        $result = @$set[$field];
        if ($k == 'vsecure' and u\crypted('V', $result)) $result = u\decry('V', $result);
        return $result; // must be separate line from $this->set (PHP bug)
      }
    }
    return NULL;
  }
  
  /**
   * Say whether the given field(s) is/are the specified kind of special.
   * @param mixed $fields: array or space-delimited list of fields (one or more)
   * @param string $specialType: name of space-delimited list of special fields of a certain type.
   * @return <at least one of $fields is in the $specialType list>
   */
  private function special($fields, $specialType) {
    $specials = constant("{$specialType}_FLDS");
    return is_array($fields) ? (bool) array_intersect($fields, ray($specials))
      : (strpos($fields, ' ') === FALSE ? u\inList($fields, $specials) // be efficient, if just one field
         : (bool) array_intersect(ray($fields), ray($specials)));
  }

  /**
   * Return the value of a company field.
   */
  private function coFld($k) {
    if (!$this->co) return NULL;
    $subs = ray('uid', $this->id);
    if (!$info = db\get('*', 'r_company', 'uid=:uid', $subs)) {
      db\insert('r_company', $subs, 'uid');
      return @$subs[$k]; // NULL unless $k is 'uid'
    } else return $info[$k];
  }
  
  /**
   * Set one or more company fields
   */
  private function setCo($info) {db\updateOrInsert('r_company', $info + ['uid' => $this->id], 'uid');}
  
  /**
   * Return the value of a relationship field for this compound account.
   */
  private function relFld($k) {
    if ($this->proSe) return NULL;
    if (in($k, REL_FLAGS)) {
      $flags = r\relation('flags', $this->id, $this->agentId);
      return u\getBit($flags, u\consta('b', $k));
    } else return r\relation($k, $this->id, $this->agentId); // not $this->qid because it depends on otherNum
  }
  
  /**
   * Set a relation field.
   */
  public function setRel($info) {
    u\EXPECT(!$this->proSe, 'setting relation on proSe');
    if (!is_array($info)) $info = rayy(func_get_args());

    if ($set = just(REL_FLAGS, $info)) {
      $flags = $this->relFld('flags') + 0;
      foreach ($set as $k => $v) {
        u\setBit($flags, $k, $v);
        unset($info[$k]);
      }
      u\preray(compact('flags'), $info);
    }
    if ($reid = $this->relfld('reid')) {
      return db\updateOrInsert('r_relations', $info + ['reid' => $reid], 'reid');
    } else $this->newRelation($info + ray('other', $this->agentId));
  }      
  
  /**
   * Activate the account.
   * @param int $helper: account record ID of account that invited this one
   */
  public function activate($helper) {
    u\EXPECT($mya = r\acct() and $mya->cAdmin, 'should be ctty admin'); // only ctty admin can approve an account

    $DBTX = \db_transaction();
    u\EXPECT($helper, 'no helper!');
    $this->update(compact('helper')); // must precede welcome message
    $this->setBit(B_OK, TRUE, TRUE); // must precede welcome message
    $this->setBit(B_NONUDGE, FALSE, TRUE);
    
    if ($firstTime = !$this->activated) { // first time activation
      //      u\EXPECT($this->superAdmin, 'initial activation is only for superadmin');
      $this->update('activated', time() - 1); // must precede update of vsecure, so it gets V-encrypted
      $this->update('vsecure', $this->vsecure); // hyper-encrypt
      $this->eachPartner(function($coA, $zot, $custCode) { // tell partner: account is activated
          if ($api = $coA->api()) u\post($api, ray('partnerCode qid op name', $coA->emailCode, $this->mainQid, 'complete', $this->fullName));
        });
      $inviterName = @$this->helperA->fullName;
      $subs = compact('inviterName');
      $msg = 'approved';
      if (!$this->confirmed) $msg .= ($helper > 1 ? '|must confirm' : '|in person');
      r\message($this->id, $msg, $subs + ['youName' => $this->fullName]);
    }

    if ($firstTime and !$this->co) { // no bonus or helper bonus for a company signing up
      if ($this->ssnData['CGerror'] and !$this->risk('ssnOff') and !$this->risk('dobOff')) $this->setRisk('ssnOff'); // make SURE this bit gets set (might not if admin signs the person up

      if (!$this->helperA->co and !$this->helperA->superAdmin) { // no helper bonus for company referral or help by superAdmin (cAdmin is okay) [don't require $this->confirmed]
        $fullName = $this->fullName;
        $helped = db\count('users', ':IS_OK AND NOT :IS_CO AND helper=:hId', ray('hId', $this->helper)) + 0;
        if ($helped == ORGANIZER_GRANT_MIN) {
          //            r\message($this->helper, 'organizer grant', ['_a' => w\atag('/community/grant')]);
          list ($name, $topic) = [$this->helperA->fullName, t('eligible')];
          r\tellAdmin('eligible for grant', compact(ray('name topic')));
        }
      }
    }
    
    unset($DBTX); 
  }

  /**
   * Set the company categories.
   */
  function setCategories($cats) {
    $DBTX = db_transaction();
    db\q('DELETE FROM r_user_industries WHERE uid=:id', ray('id', $this->id)); // out with the old
    foreach ($cats as $iid) db\insert('r_user_industries', ray('uid iid', $this->id, $iid));
    unset($DBTX); // commit
  }  
  
  /**
   * Handle joint field request (for example $this->j_r)
   * @param string $field: normal name of field to get for both members of the joint account (if it is joint)
   * @return if joint: the sum or concatenation of the member account values, otherwise just the normal value
   *//*
       private function jGet($field) {
       if (!$jid = $this->jid) return $this->$field;
       if (in_array($field, ray(MASTER_FLDS))) return $this->masterA->$field;
       $j = u\nn(r\acct($jid)->$field, 0); // use 0 if other value is null
       return is_numeric($j) ? round($j + $this->$field, 2) : ($this->$field . " & $j"); // assume $ for numeric fields
       }*/

  /**
   * Return a printable (scrambled) invitation card code or gift coupon code 
   * @param int $iCode: sequence number (0 to 35^3-1)
   */
  public function iCardCode($iCode = 0) {
    list ($region, $tail) = $this->qo->parse();

    $b = u\lpad(decbin(u\a2n($region)), ILEN_REGION);
    ///  debug("b=$b region=$region tail=$tail security=$this->lowSecurity iCode=$iCode");
    $b .= u\lpad(decbin(u\a2n($tail)), ILEN_TAIL);
    ///  debug("b=$b region=$region tail=$tail security=$this->lowSecurity iCode=$iCode");
    $b .= u\lpad(decbin(u\ai2n($this->lowSecurity)), ILEN_SECURITY);
    ///  debug("b=$b region=$region tail=$tail security=$this->lowSecurity iCode=$iCode");
    $b = u\rotateBits($b, ($iCode + 1) * (bindec(substr(R_INVITE_KEY, 0, 31)) % strlen($b)));
    ///  debug("b=$b region=$region tail=$tail security=$this->lowSecurity iCode=$iCode");
    $b = u\xorBits($b, substr(R_INVITE_KEY, -strlen($b)));
    ///  debug("b=$b region=$region tail=$tail security=$this->lowSecurity iCode=$iCode");
    return u\n2ai(bindec(substr($b, 0, ILEN_DIV)), 5) . u\n2ai(bindec(substr($b, ILEN_DIV)), 5) . u\n2ai($iCode, -1);
  }

  /**
   * Return the entire account object or just certain fields.
   * @param string $just: space-delimited list of fields to return (all raw fields, if empty)
   * @param bool $own: <return just the account's own field values, even if it is a joint account> (always true if $just == '')
   * Note: the returned object does not include uid -- haven't figured out why.
   */
  public function account($just = '', $own = TRUE) {
    $this->reread(); // make sure we have read the record from the db
    if (!$just) return @self::$rs[$this->id];

    foreach (ray($just) as $k) $res[$k] = $own ? $this->o($k) : $this->$k;
    return (object) $res;
  }

  public static function _clear() {self::$perms = self::$rs = [];}
  
  /**
   * Return the next available uid in the specified region.
   */
  public static function nextId($region = '') {
    u\EXPECT($region <= 0, 'non-negative region in nextId');
    return r\newUid(-($region ?: r\serverUid()));
  }
  
  /**
   * Update the saved record in the database with the given data. For joint accounts, update partner too.
   * Call by:
   *   update($info); OR
   *   update($fields, $value1, ...)
   * @param assoc $info: data to update
   * @param string $fields: space-delimited list of field names
   * @param mixed $value1 (etc): new values for those fields
   * @return: TRUE if update succeeds, FALSE if update fails
   */
  public function update($info) {
    if (!is_array($info)) $info = rayy(func_get_args());
    
    u\EXPECT(!isset($info['savings']), 'archaic savings field');
    //    if ($jid = $this->jid and $jInfo = just(MASTER_FLDS . ' savings', $info)) {
    if ($this->jid and $jInfo = just(MASTER_FLDS, $info)) {
      list ($a2, $a1) = u\order($this->slave, $this, $this->jA); // set $a1 master, $a2 slave

      $jInfo2 = array_fill_keys(ray(MASTER_FLDS), 0);
      unset($jInfo2['achMin']); // no change to slave achMin
      $a2->update1($jInfo2);
      
      //      $a2->update1(MASTER_FLDS, FALSE, '', '', FALSE, @$jInfo['achMin'] ?: $a1->achMin, 0, 0, 0); // not much for slave
      //      $this->updateSavings($jInfo, $a1 == $this ? $a2->rewards : $a1->rewards); // update savings in master
      $a1->update1($jInfo);
      //      if (!$info = justNOT(MASTER_FLDS . ' savings', $info)) return TRUE; // fall through if something else to update
      if (!$info = justNOT(MASTER_FLDS, $info)) return TRUE; // fall through if something else to update
    }
    //    } else $this->updateSavings($info, 0); // update savings in proSe account
    return $this->update1($info);
  }

  /**
   * Interpret requested update of savings as a change to the savingsAdd field (for testing).
   * @param assoc $info: (MODIFIED) fields and values to update
   * @param numeric $slaveRewards: rewards in slave account, if any
   *//*
       private function updateSavings(&$info, $slaveRewards) {
       if (isset($info['savings'])) {
       $rewards = (@$info['rewards'] ?: $this->rewards) + $slaveRewards;
       $info['savingsAdd'] = $info['savings'] - $rewards; // may be negative in official CGCs
       unset($info['savings']);
       }
       }*/
  
  /**
   * Update the account record in the database (with no special treatment of joint accounts).
   */
  public function update1($info) { // public only for testing
    global $mya;
    if (!is_array($info)) $info = rayy(func_get_args());

    foreach ($bits = just(B_LIST, $info) as $k => $v) {$this->setBit($k, $v); unset($info[$k]);}
    foreach (just(REL_FLDS . ' ' . REL_FLAGS, $info) as $k => $v) {$this->setRel($k, $v); unset($info[$k]);}
    if ($coFlds = just(CO_FLDS, $info)) {$this->setCo($coFlds); $info = justNOT(CO_FLDS, $info);}

    //    if ($this->ok) $info += $this->recordChanges(justNOT(B_LIST, $info)); // record changes if member is active
    if ($this->activated) $this->recordChanges(justNOT(B_LIST, $info)); // record changes if member is (or was) active
    foreach (just('hasBank', $info) as $k => $v) {$this->setRisk($k, $v); unset($info[$k]);}

    if (isset($info['photo'])) {
      if ($info['photo']) { // setting photo
        db\updateOrInsert('r_photos', ['uid' => $this->id, 'photo' => u\cry('H', $info['photo'])], 'uid');
      } else db\q('DELETE FROM r_photos WHERE uid=:uid', ['uid' => $this->id]);
      unset($info['photo']);
    }
    foreach (ray(PSECURE_FLDS) as $k) if (isset($info[$k])) $info[$k] = u\cry('P', $info[$k]);
    //    if (isset($info['phone'])) $info['phone'] = u\cry('P', $info['phone']);
    if (isset($info['pass']) and $info['pass'] !== '') $info['pass'] = r\passHash($info['pass']);
    u\preray($info, self::$rs[$this->id]); // cache the new field values (before doing special fields)
    
    foreach (ray('data secure vsecure') as $special) {
      if (isset($info[$special])) {
        $sFlds = $info[$special]; // can be '' for no data
      } elseif ($sFlds = just(constant(strtoupper($special) . '_FLDS'), $info)) {
        $sFlds += $this->$special;
      } else continue;
      if ($special == 'vsecure' and $this->activated and $sFlds) foreach ($sFlds as $k => $v) {
          if (!u\crypted('V', $v)) $sFlds[$k] = u\cry('V', $v); // hyper-encrypt when activated (when auto-access to EIN no longer needed). This and recordChanges are the ONLY places we do u\cry('V', ) !!
        }
      self::$rs[$this->id]->$special = $sFlds;
      $sFlds = serialize($sFlds);
      $info[$special] = ($special == 'data' or !$sFlds) ? $sFlds : u\cry('S', $sFlds);
    }
    /*    
          if (isset($info['data'])) {
          $info['data'] = serialize($info['data']);
          } elseif ($data = just(DATA_FLDS, $info)) $info['data'] = serialize($data += $this->data);

          if (($set = isset($info['secure'])) or $sFlds = just(SECURE_FLDS, $info)) { // serialize and encrypt
          //  			if ($v = @$sFlds['ssnData']) $sFlds['ssnData'] = serialize($v);
          $sec = $set ? ($info['secure'] ?: []) : ($sFlds + ($this->secure ?: []));
          $info['secure'] = u\cry('S', serialize($sec));
          }

          if (($set = isset($info['vsecure'])) or $sFlds = just(VSECURE_FLDS, $info)) { // serialize and encrypt
          $vsec = $set ? ($info['vsecure'] ?: []) : ($sFlds + ($this->vsecure ?: []));
          if ($this->activated) foreach ($sFlds as $k => $v) $vsec[$k] = u\cry('V', $v); // hyper-encrypt when activated 
          $info['vsecure'] = u\cry('S', serialize($vsec));
          }
    */	

    $info = justNOT(SECURE_FLDS . ' ' . VSECURE_FLDS . ' ' . DATA_FLDS, $info); // don't pass these
    return $info ? db\update('users', $info + ['uid' => $this->id], 'uid') : TRUE;
  }

  /**
   * Record memorable changes being made to an account record.
   * @param assoc $info: all changes being made
   */
  private function recordChanges($info) {
    global $mya;
    $newChanges = justNOT(R_HIDE_CHANGES, $info); // see if there are any changes to remember
    foreach ($newChanges as $field => $v) {
      $ak = $this->$field;
      if ($v == $ak or (is_numeric($v) and is_numeric($ak) and $v + 0 == $ak + 0)) continue; // don't record if no change

      $oldValue = $this->cryIf($field, '' . $this->$field, TRUE);
      $newValue = $this->cryIf($field, '' . $v);
      $record = ray('uid created field oldValue newValue changedBy', $this->uid, time(), $field, $oldValue, $newValue, $mya ? $mya->agentId : 0);
      db\insert('r_changes', $record); // add a r_changes record for each changed field
    }
  }

    
  //        unset($newChanges[$k]);
  //      } // else $newChanges[$k] = $ak; // @self::$rs[$this->id]->$k;
  //    }
    
  //    if (!$newChanges) return [];
  
  //     $changes = $this->changes; // must precede ->rawChanges
  // //    $encrypted = u\starts($this->rawChanges, CRYPT_FLAG);
  // //    for ($k = r\rTime(); isset($changes[$k]); $k++);
  //     $time = r\rTime();
  //     if (isset($changes[$time])) {
  //       $changes[$time] += $newChanges;
  //     } else u\preray([$time => $newChanges], $changes); // put the new changes first
  //     $changes = serialize($changes);
  // //    if ($encrypted or just(SECURE_FLDS, $newChanges)) 
  // 		$changes = u\cry('S', $changes);

  //    foreach ($newChanges as $k => $v) {  // add a r_changes record for each changed field
  /*      $record = [ 'uid' => $this->uid,
          'created' => r\rTime(),
          'field' => $k,
          'oldValue' => u\cry('S', '' . $this->$k),
          'newValue' => u\cry('S', '' . $v),
          'changedBy' => $this->agentId ]; */
    
  //    return compact('changes');
	
  /**
   * Encrypt if appropriate
   */
  private function cryIf($k, $v, $old = FALSE) {
    foreach (ray('psecure vsecure secure') as $secure) {
      list ($type, $flds) = [ucfirst($secure[0]), constant(strtoupper($secure) . '_FLDS')];
      if (in($k, $flds)) {
        if ($old and $type == 'V') $v = @$this->vsecure[$k]; // special case for possibly already-encrypted, inaccessible vsecure value
        return u\crypted($type, $v) ? $v : u\cry($type, $v);
      }
    }
    return $v;
  }
		
  
  //  public function isNonprofit() {return (bool) ($this->coFlags & u\bit(CO_NONPROFIT));}
  
  /**
   * Create a new relationship record for the current account (as "main") relating to some agent.
   * NOTE: Assume no other company agent for this company is trying to create a relation at the same time.
   * @param assoc $info: field values
   * @return: the record ID of the new relationship record
   */
  function newRelation($info) {
    u\EXPECT($info['other'] or @$info['data'], 'missing other in new relation'); // placeholder for "other" ok if there's data
    foreach (ray(REL_FLAGS) as $k) if (isset($info[$k])) {
      u\setBit($info['flags'], $k, $info[$k]);
      unset($info[$k]);
    }
    //      $info[$k] = (int) @$info[$k];
    $info['created'] = time();
    return r\regionalInsert('r_relations', 'reid', $info + ['main' => $this->id], -$this->region);
  }

  /**
   * Create an agent number for the account's relation, if it's a relational account and doesn't have one yet.
   */
  public function setAgentNum() {
    if ($this->proSe or r\qo($this->qid)->agentCode) return;
    $otherNum = db\max('otherNum', 'r_relations', 'main=:main', ['main' => $this->id]) + 1;
    $this->setRel(compact('otherNum'));
    return $otherNum;
  }

  /**
   * Say whether the wanted transaction proof is really wrong, not just a delayed transaction with a cardcode that got changed.
   * @param string $proof: tx proof supplied by the app
   * @param string $wanted: proof we expected
   * @param int $created: transaction creation date/time
   * @return <the proof is really wrong>
   */
  public function badOldProof($proof, $wanted, $created) {
    $codeName = $this->proSe ? 'cardCode' : 'cardCode2';
    $code = $this->agentA->$codeName;
    //    $changes = $this->agentA->changes;
    $changes = db\rows('*', 'r_changes', 'uid=:id AND field=:fld AND created>:dt', ray('id fld dt', $this->agentId, $codeName,$created));

    foreach ($changes as $ch) if (u\hash(str_replace($code, u\decry('S', $ch->oldValue), $wanted)) == $proof) return false;

    return true;
  }

  /**
   * Return the account's name and qid, with a link to a fuller description.
   */
  public function linkedDesc() {
    global $base_url;
    $qid = "<a href=\"$base_url/change-account/acct=$this->mainQid&page=summary\">$this->mainQid</a>";
    return "$this->fullName ($qid)";
  }
  
  /**
   * Set the bit in the flags field to the given value.
   * @param int $bit: number of bit to set (0 - 31)
   * @param bool $on: whether to set it ON or OFF
   * @return <successful>
   * @see also self::can()
   */
  public function setBit($bit, $on = TRUE) {

    if (!is_numeric($bit)) $bit = u\consta('b', $bit);
    $res = $this->setBitx($bit, $on, 'flags'); 
    if (@self::$perms[$id][$this->agentId]) {
      self::$perms[$id][$this->agentId][$bit] = $on;
    } // else can gets refreshed automatically next time can() is called
    return $res;
  }
  
  // public function refreshCan() {self::$perms[$this->id] = NULL;} // UNUSED force redo in can()

  /**
   * Set the current account being managed (must be static so we can set account to empty)
   * @param acct $a: the account to manage
   * @return: the account (FALSE if $a is empty)
   */
  public static function setDefault($a) {
    global $mya, $channel, $box; 
    global $user;
    if (empty($user)) $user = (object) ['uid' => $a ? $a->id : 0]; // probably needed only for rWeb login form testing
    if ($a and $a != $mya and !$a->admin2) { // admin access doesn't count
      $access = r\rTime();
      if ($channel == TX_WEB) $login = $access;
      $lastip = $_SERVER['REMOTE_ADDR'];
      $a->update(@compact('login', 'access', 'lastip'));
    }
    if (@$a->ok) r\ipok($a->id, $box); // box is not very important
    return $mya = $a;
  }

  /**
   * Return a filename for the back of invitation cards (to print)
   */
  public function invitationBack() {
    $forCG = ($this->id == CGID and $this->superAdmin);
    $filename = ($this->co and !$forCG) ? 'InvitationCardsBackCo.pdf' : 'InvitationCardsBack.pdf';
    return 'http://cg4.us/doc/' . $filename;
  }

  /**
   * Return the amount not available, including draws from related accounts, depending on the purpose.
   * If there are fees for drawing from a related account, they are added to the amount needed.
   * If the account has permission to cash out while serving as an ATM their rewards amount will not limit them.
   * @param int $goods: (does not default, to make sure we know what we're doing)
   *   FOR_GOODS or FOR_NONGOODS: the amount of credit available for a purchase 
   *     (including credit lines)
   *   FOR_USD: the amount of credit available to trade for cash or US Dollars
   *     (not including credit lines and rewards)
   * @param float $need: the amount needed
   * @param bool $get: if true then draw from other accounts as needed, then say whether there is enough
   *                   if false (the default) just check and say whether we could get enough
   * @param acct $actor: account of the individual or company initiating the transaction
   * @return how much short this account is, of what's needed
   */
  public function shortfall($goods, $need = 0, $get = FALSE, $actor = NULL) {
    global $channel;
    // don't allow companies to spend rewards unless they have ATM permission and are exchanging r for USD
    if ($this->co and COMPANY_FREEZE and $this == $actor and $this->coCan(CO_ATM) and $goods == FOR_USD)
      $goods = FOR_GOODS;
    $avail = $this->avail($goods);
    if ($avail >= $need) return 0; // plenty without drawing from other accounts

    if ($get) {
      $avail += $this->draw(($this->refill ? $this->minimum : 0) + $need - $this->balance);
    } else {
      $avail += $this->canDraw();
    }
    return max(0, $need - $avail); 
  }
  
  /**
   * Return how much is available in this account for the given operation, without drawing on other accounts.
   * @param int $goods: purpose of the potential expenditure - see r\Acct::shortfall())
   * Do NOT take into account any advances from bank account (that would confuse the member's understanding of their credit line)
   */
  public function avail($goods = FOR_GOODS) {
    // no going into debt without permission
    if ($this->can(B_DEBT) and !$this->cttyA->noneg and $goods != FOR_USD) $floor = $this->floor;
    else $floor = max($this->floor, 0);

    return round($this->balance - $floor, 2);
  }
  
  /**
   * Return the amount this account can draw from other accounts.
   * Repairs the B_DRAWS bit if all such relations have ended.
   */
  private function canDraw() {
    if (!$this->can(B_DRAWS)) return FALSE;
    list($avail, $count) = $this->drawSourcesSummary();
    if ($count == 0) $this->setBit(B_DRAWS, FALSE); // doesn't really have any drawable accounts
    return $avail;
  }
  
  /**
   * Return a count of accounts we can draw from, and how much we can draw
   * @return ['avail'=>avail, 'count'=>count]
   */
  private function drawSourcesSummary() {
    return db\get("SUM(balance-IF(u.:IS_DEBT, floor, GREATEST(floor, 0))) AS avail, COUNT(*) as count",
                  "users u INNER JOIN r_relations r ON r.main=u.uid",
                  "r.other IN (:id, :jid) AND r.:IS_DRAW AND u.jid<>:id",
                  ['id' => $this->id, 'jid' => $this->jid ?: -1]);
  }
  
  /**
   * Return rows of accounts to draw from.
   * @return an array of records, each of which has uid and avail
   */
  private function drawSources() {
    $sql = <<< X
      SELECT u.uid, (balance-IF(u.:IS_DEBT, floor, GREATEST(floor, 0))) AS avail
      FROM users u INNER JOIN r_relations r ON r.main=u.uid
      WHERE r.other IN (:id, :jid) AND r.:IS_DRAW AND u.jid<>:id
X;
    return db\q($sql, ray('id jid', $this->id, $this->jid ?: -1));
  }
  
  /**
   * Draw the wanted amount from other accounts, usually to make a purchase and maintain a non-negative balance.
   * @param float $need: the amount wanted
   * @param string $why: purpose of transfer
   * @return float: the amount drawn
   */
  public function draw($need, $why = '') {
    if (!$this->can(B_DRAWS)) return 0;
    list ($from, $to, $auto) = array(t(' from '), t(' to '), t('automatic transfer'));
    $left = $need; // how much left to be drawn
    ///   debug(compact(ray('type need from to auto left id fields sql')));
    $q = $this->drawSources();
    foreach ($q as $row) {
      extract(u\exactly('uid avail', $row, 0));
      $amount = round(min($left, $avail), 2);
      ///      debug(compact('row','avail','amount','left','need','id'));
      if ($amount > 0) {
        list ($fromQid, $toQid) = [r\qid($uid), $this->mainQid];
        list ($payerId, $payeeId) = [$uid, $this->id];
        $for = [$auto . $to . $toQid, $auto . $from . $fromQid];
        list($message, $subs) = be\transfer('draw', $this, r\acct($uid), $amount, $for, FOR_NONGOODS);
        if ($subs['success']) $left -= $amount;
        if ($left <= 0) break;
      }
    }
    $msg = $left == $need ? 'cannot draw' : 'drew';
    $msg = tr($msg, 'amount', u\fmtAmt($need - $left));
    r\notify($this->id, tr($msg, ['why'=>$why]));

    return round($need - $left, 2);
  }

  /**
   * Set or return the proxy for the person
   */
  public function proxy($priority = 1, $proxy = NULL) {
    $subs = ['person' => $this->id, 'priority' => $priority];
    if (empty($proxy))
      return db\get('proxy', 'r_proxies', 'person=:person AND priority=:priority', $subs);
    db\q('DELETE FROM r_proxies WHERE person=:person AND priority=:priority', $subs);
    $subs['proxy'] = $proxy;
    db\insert('r_proxies', $info);
  }

  /**
   * Return the company's description.
   * @param bool $subtle: <make the categories a subtle last line>
   */
  public function coDesc($subtle = FALSE) {
    $uid = $this->id;
    $desc = u\parseUp($this->description);

    $sql = <<<EOF
      SELECT i.iid, i.industry FROM r_industries i 
      INNER JOIN r_user_industries ui ON ui.iid=i.iid 
      WHERE ui.uid=:uid ORDER BY i.industry
EOF;
    $cats = db\q($sql, compact('uid'))->fetchAllKeyed();
    $cats = empty($cats) ? '' : ($subtle
                                 ? ('<h3>Categories:</h3>' . join('<br>', $cats))
                                 : (t('Categories: ') . join(', ', $cats)) );
    
    return "$desc<br>$cats";    
  }
  
  /**
   * Mark two accounts joined (a joint account)
   * @param acct $b: the other account
   * Note we cannot split rewards and floor because they are recalculated in cron.
   */
  function join($b) {
    $fields = ray(MASTER_NUMERIC_FLDS);

    $DBTX = \db_transaction();
    foreach ([$this, $b] as $i => $ai) {
      $aj = $i == 0 ? $b : $this; // the other account
      $ai->update('jid', $aj->id);
      /* NO! bankAccount is available only to regional admins
         if (!$ai->o_hasBank and $aj->o_hasBank) {
         $ai->update('bankAccount last4bank', $aj->o_bankAccount, $aj->o_last4bank);
         $ai->setRisk('hasBank');
         } */
      //      $ai->setBit(B_JOINED);
      foreach ($fields as $k) $$k = @$$k + $ai->o($k);
    }
		
    $this->masterA->setBit(B_REFILL, $this->o_refill or $b->o_refill);
    $achMin = max($this->o_achMin, $b->o_achMin); // one of the $fields
    $minimum = $this->o_minimum + $b->o_minimum;
    $this->update(compact($fields)); // this sets master numeric fields to the sums, slave fields to zero
    unset($DBTX);
  }
  
  /**
   * Remove all joins and join requests, except with the specified account record ID (if any).
   * @param acct $except: the joined account record ID for which NOT to delete join requests
   */
  function unjoinAllBut($except = FALSE) {
    $sql = 'UPDATE r_relations SET permission=:manage WHERE permission=:joint AND main=:id';
    $subs = ray('manage joint id', r\perm(B_MANAGE), r\perm(B_JOINT), $this->id);

    $DBTX = \db_transaction();
    if ($jid = $this->jid AND $jid != $except) { // unravel a consummated join
      $b = r\acct($jid); // ignore param (actual joined account will be unjoined and any join requests zapped)
      foreach ([$this, $b] as $ai) {
        $ai->update1('jid minimum', 0, max($this->o_minimum, $b->o_minimum));
        /* $ai->cacheOk(); // make sure each account is left with its proper cached amounts */
        //        $ai->setBit(B_JOINED, FALSE);
      }
      list ($a1, $a2) = u\order($b->o_balance > $this->o_balance, $b, $this);
      if ($a1->ok and $a2->ok) { // no need to settle with closed or not-yet-open account
        $amount = round(($a1->o_balance - $a2->o_balance) / 2, 2);
        ///      debug("amount=$amount a1=$a1->id bal=$a1->o_balance a2=$a2->id bal=$a2->o_balance");
        if ($amount > 0) $a1->pay($a2, $amount, t('joint account settlement'), FOR_USD, ray('force', 1));
      }
    } elseif ($except) {
      $sql .= ' AND other<>:except';
      $subs += compact('except');
    }
    
    db\logSql(compact(ray('sql subs')));
    db\q($sql, $subs); // zap one or more joins (or requested joins) for this account
    unset($DBTX);
  }

  /**
   * De-activate the account for reasons of security or data integrity.
   * @param string $why: the reason for suspending (to tell member and staff)
   */
  public function suspend($why = '') {
    $this->setBit(B_OK, FALSE); // suspend the account
    if ($why) {
      r\message($this->id, 'account suspended', compact('why'));
      $notes = u\fmtDate() . ': ' . t('account suspended') . " $why\n" . @$this->notes;
      $this->update(compact('notes'));
      r\tellAdmin('account suspended', ray('uid fullName why', $this->id, $this->fullName, $why));
    }      
  }
  
  /**
   * Return an auxiliary filename for the account.
   * @param bool $ideal: return the ideal normal name, even if the file does not exist (default FALSE)
   * @return: the relative file path (relative to Drupal)
   */
  public function photoFilename($ideal = FALSE) {
    return ($ideal or $this->hasPhoto)
      ? r\pic(@"$this->id-$this->cardCode.jpg") // @ for testing
      : ($this->co ? R_DFT_PICTURE_WIDE : R_DFT_PICTURE);
  }
  
  public function cardCode() {
    $field = $this->proSe ? 'cardCode' : 'cardCode2';
    return $this->agentA->$field;
  }

  /**
   * Create an rCard security code for the given account (either for an individual or a company agent).
   * @param acct $a: the account
   */
  function makeCardCode($newCode = '') {

    $qid = $this->qid;
    $aA = $this->agentA;
    $field = $this->proSe ? 'cardCode' : 'cardCode2';
    if ($aA->$field) r\badCard($qid, $aA->$field, t('making new card for %nm', 'nm', $this->fullName)); // (don't mark previous code bad if none)
//    if ($oldCode = $aA->$field) db\insert('r_bad', ray('qid code created', $qid, $oldCode, time()), 'created');
    $aA->update($field, $newCode ?: r\cardCode($qid)); // resave the secure fields
  }
    
  /**
   * Add a date stamp and agent's initials to the given note (before updating the notes field with it).
   */
  public function stampNote($note) {
    $rep = strtolower(u\initials(r\agent()->legalName) ?: 'WS');
    //    $date = str_replace('-', '', u\fmtDate());
    $date = u\fmtDate();
    return "$date  $rep: $note\n";
  }

  /**
   * Mark a membership step as completed.
   * @param string $step: a named step (see R_STEPS)
   * @param assoc $details: any details to report to the staff
   * @param bool $done: whether to set the step done or not done
   * @return the next step (FALSE if none)
   */
  function stepDone($step, $done = TRUE, $details = []) {

    $stepsDone = $this->stepsDone;

    if (!@$stepsDone[$step]) { // unless already done
      //      if ($done) r\tellAdmin(t('Step completed: ') . strtoupper($step), $details, $this->id);
    } // elseif (!$this->cAdmin) r\tellAdmin(t('Settings changed: ') . strtoupper($step), $details, $this->id);
   
    $stepsDone[$step] = $done;
    $this->update(compact('stepsDone'));
    if (!$nextStep = $this->nextStep()) {
      r\tellCO(t('New Member (%name)', ['name' => $this->fullName]));
      $this->setBit(B_MEMBER);
      //    r\membershipEvent($this, 'member');
      $this->update('tickle', time());
    }
    return $nextStep;
  }
  
  /**
   * Return the next step to do.
   */
  function nextStep() {
    $steps = $this->stepsDone ?: []; // don't change the real data ([] for admin)
    foreach ($steps as $step => $done) if (!$done) return $step;
    return FALSE;
  }

  /**
   * Go to the next step
   * @param string $stepDone: the step just completed, if any
   * @param string $msg: message to display if account is already a member (defaults to "info saved")
   * @param string $msg: (RETURNED) a status message to display, if any 
   * @return the url of the next account-setup step ('', if no step)
   */
  public function nextStepUrl($stepDone = '', &$msg = NULL, $info = []) {

    
    if ($stepDone) u\setDft($msg, 'info saved');
    if ($this->closed) return '';
    if ($this->ok) return $stepDone == '' ? '' : "settings/$stepDone"; // "going" to current page makes tests work
    
    /*    if ($this->member) {
          if ($stepDone) $nextStep = $stepDone; else return 'summary';
          } else { */
    $nextStep = $stepDone ? $this->stepDone($stepDone, TRUE, $info) : $this->nextStep();
    if (!$nextStep) {
      $approval = $this->co ? 'company approval' : 'individual approval';
      // fails with sysadmin as helper  if (!$this->confirmed) $approval .= '|' . t('must be confirmed', 'inviterName', @$this->helperA->fullName);
      
      if (!$stepDone) $msg = "setup complete|$approval|join thanks"; // show on display, not on done
      return 'summary'; // go nowhere if not completing a step
    } elseif (!$this->member) $msg .= '|step completed';

    $steps = ray(R_STEPS);
    return $this->member ? '' : ($steps[$nextStep] ?: "settings/$nextStep");
  }

  /**
   * Check SSN secretly during a signup step (normally on the verify step as soon as we get federalId, unless already verified)
   */
  public function verifySsnInBackground() {if (!$this->ssnData) w\jsx('get-ssn');}

  /**
   * Decrypt and/or fix the bankAccount in a USD/rCredits exchange record.
   *//*
       public function fixTxBankAccount(&$bankAccount, $txid) {

       $ba1 = $bankAccount = ($pw2 = @$_COOKIE['pw2']) ? u\decrypt($ba0 = $bankAccount, 0, $pw2) : '';
       if (substr($bankAccount, 0, 2) <> 'US' and ($ba2 = $bankAccount = $this->bankAccount) and $pw2) { // bank account got screwed up somehow -- probably double-encrypted (happened again 12/7/2017 7:27am and 12/21/2017 10:05. Fixed?)
       r\tellAdmin('screwed up bank account', ray('who ba0 ba1 ba2 hex0', $this->fullName, $ba0, $ba1, $ba2, bin2hex($ba0)));
       db\update('r_usd', ray('txid bankAccount', $txid, u\crypt($bankAccount, 0, $pw2)), 'txid');
       w\say(t('fixed bankAccount for %name txid #%txid', 'name txid', $this->fullName, $txid));
       }
       }
     */
  
  /**
   * Create a once-use password and return it.
   * @param string $name: login identifier (email, account record ID, or shortname) -- not used on production server
   * @return the once-use password
   */
  function oneTimePass($name) {
    global $base_url;

    //  $pass = strtolower(u\nonce()); // not a hash, easy to remember and type
    $verifying = !$this->stepDone['verify'];
    $pass = u\randomString($verifying ? 3 : R_CODE_LEN, $verifying ? 'upper' : 'word'); // use
    ///  /**/ if (isDEV or (NOT_PRODUCTION and time() - $this->created < HOUR_SECS)) \drupal_set_message('Link: ' . "<a href='$base_url/reset/id=$name&code=$pass'>reset</a>");
    $expires = r\rTime() + HOUR_SECS * R_SIGNIN_HOURS;
    $this->update('oneTimePass', compact('pass', 'expires'));
    return $pass;
  } 

  /**
   * Say whether the password is acceptable.
   * @param string $password: the password supplied by the user
   * @param string $passFieldName: password field name (none if using only oneTimePass)
   * @param string $err: (RETURNED) the error message, if any
   * @return <password is good>
   */
  function passwordOkay($password, $passFieldName = '', &$err = '') {

    if (@$this->oneTimePass) {
      extract(just('pass expires', $this->oneTimePass));
      if ($password == @$pass) return ($this->admin or r\rTime() < @$expires) ?: !($err = 'pass expired');
    }

    require_once DRUPAL_ROOT . '/includes/password.inc';
    $hash = \_password_crypt('sha512', $password, $this->$passFieldName);
    return ($hash and $this->$passFieldName == $hash) ?: (!$err = 'bad login');
  }
  
  public function stepsRemaining() {

    $steps = $this->stepsDone ?: [];
    $dones = array_sum($steps);
    return count($steps) - $dones;
  }
  
  /**
   * Return the Community Admin's account record ID.
   */
  function cAdminUid() {
    return db\get('uid', 'users', 'community=:ctty AND :IS_CADMIN', ray('ctty', $this->community));
  }
  
  /**
   * Return the community admin's contact info.
   */
  function cAdminContact() {
    if (!$id = $this->cAdminUid()) return t('(no Community Admin)');
    $cAdmin = r\acct($id);
    return "$cAdmin->fullName - $cAdmin->email";
  }
  
  /**
   * Return an assoc of individual (or joint) account statistics.
   * @return [returnMo, return, cttyBeneMo, cttyBene]
   * OUT OF DATE and NOT CURRENTLY USED
   */
  public function j_stats() {

    $fields = 'returnMo return cttyBeneMo cttyBene';
    if (!$this->member or $this->isCtty) return ray($fields, 0, 0, 0, 0);
    
    $stats = ($stats = $this->stats) ? unserialize($stats) : [];

    if ($jid = $this->jid) {
      $j = r\acct($jid);
      $jstats = ($jstats = $j->stats) ? unserialize($jstats) : [];
      foreach ($stats as $k => $v) {
        $jv = $jstats[$k];
        $stats[$k] = u\abbreviates('avg', $k) ? ($v + $jv) / 2 : ($v + $jv);
      }
      $created = round(($this->created + $j->created) / 2);
    } else $created = $this->created;
    
    extract($stats);
    $years = round((strtotime('today') - strtotime('today', $created)) / DAY_SECS) * DAY_SECS / YEAR_SECS;
    // rounding is to assure consistency for tests, despite daylight savings time changes
    $returnMo = @$avgBalPastMo > 0 ? 
      number_format(100 * 12 * @$extraPastMo / $avgBalPastMo, 1)
      : (@$benePastMo + @$extraPastMo > 0 ? '&infin;' : number_format(100 * R_INFLATION_RATE, 1));
    $return = ($years > 0 and @$avgBalEver > 0) ? 
      number_format(100 * @$extraEver / $avgBalEver / $years, 1)
      : (@$extraEver > 0 ? '&infin;' : number_format(100 * R_INFLATION_RATE, 1));
    $cttyBeneMo = u\fmtAmt(@$giftsPastMo + max(0, @$bankedPastMo) + @$benePastMo * (1 + R_CC_RATE / 100));
    ///    debug(compact(ray('giftsEver bankedEver beneEver')));
    $cttyBene = u\fmtAmt(@$giftsEver + max(0, @$bankedEver) + @$beneEver * (1 + R_CC_RATE / 100) + r\cttyPaidEver($this->community) / (@$pAccts ?: 1));

    return compact(ray($fields));
  }

  /**
   * Return the rough business structure of a company, as required by Dwolla.
   */
  function businessStructure() {
    u\EXPECT($this->co, 'not a company');
    return $this->coCan(CO_CORPORATION) ? 'Corporation' : ($this->coCan(CO_PARTNERSHIP) ? 'Partnership' : 'SoleProprietorship');
  }
   
  /**
   * Return an SMS number for the account.
   * @return: the number or null if none
   */
  public function smsNumber() {  
    $id = $this->id;
    return db\get('code', 'r_boxes', "uid=:id AND code REGEX '+[:digit:]{7,15}'", compact('id')); // was status=:SMS_PRIMARY
  }

  /**
   * Return the total waiting to be credited as a transfer FROM (or if negative result, TO) the member's bank.
   * @param numeric $combinable: (RETURNED) how much is waiting and checks haven't been printed yet (incoming only)
   */
  public function waitingFromBank(&$combinable = 0) {
    $id = ($jid = $this->jid) ? "$this->id,$jid" : $this->id;
    extract(db\q("SELECT SUM(amount) AS amt, SUM(IF(deposit OR amount<0, 0, amount)) AS combinable FROM r_usd WHERE payee IN ($id) AND NOT completed")->fetchAssoc());
    return $amt;
  }
	
  public function advances() {
    $id = ($jid = $this->jid) ? "$this->id,$jid" : $this->id;
    return db\sum('amount', 'r_usd', "payee IN ($id) AND amount>0 AND :NOW-created<:DAY_SECS*:R_USDTX_DAYS");
  }
   
  /**
   * Transfer funds to an account from a connected bank account or drawable Common Good account.
   * Always bring the balance up to balance up to zero or (if autorefill is yes) the target balance PLUS the requested amount.
   * Called for investments, gifts, invoice payment, and autorefills. So the only way to stay negative is not to do any of these.
   * @param numeric $amount: the amount needed
   * @param string $why: purpose of transfer
   * @return the transaction number (FALSE if failure)
   */
  public function getFunds($amount, $why) {

    if ($amount <= 0) return FALSE;
    if ($this->hasBank) {
      $waiting = $this->waitingFromBank($combinable);
      //			$target = $this->refill ? $this->minimum : 0;
      //			$amount += max(0, $target - $waiting);
      if ($this->refill) $amount = max($this->achMin - $combinable, round(R_ACHMIN * ceil($amount / R_ACHMIN)));
      return $this->bank($amount, $why);
    } else return $this->draw($amount, $why);
  }

  /**
   * Transfer funds to or from a connected bank account.
   * @param numeric $amount0: the amount to transfer FROM or (if negative) TO the bank
   * @param string $why: purpose of transfer
   *                     (RETURNED) message about transfer
   * @param assoc $tx: forced field values, if any (when reversing an unsuccessful request)
   * @return the transaction number (FALSE if failure)
   */
  public function bank($amount, &$why = '', $tx = []) {
    global $channel;
    $amount0 = $amount; // remember original amount requested
		

    $payee = $this->id;
    $bankAccount = @$this->vsecure['bankAccount']; // already-encrypted bank account (@ is for testing)
    if ($tx) extract($tx);
    //    u\setDft($tid, r\getUsdTid($payee));
    $okNow = ($amount < 0 or $this->bankOk); // "okay to create the request NOW"
    if (!$okNow) $this->verifyBank();
    u\setDft($created, $okNow ? NOW : NOW + DAY_SECS);
    u\setDft($completed, ($amount < 0 or $this->bankOk) ? $created : 0);

    $DBTX = \db_transaction();

    if ($txid = $this->combineUsdTx($amount, $completed)) { // modify existing tx
      db\update('r_usd', compact(ray('txid amount completed bankAccount')), 'txid');
    } else {
      //      if (isGAME) $tx += ['members' => $this->members];
      $txid = db\insert('r_usd', $tx += compact(ray('amount payee created completed bankAccount channel')), 'txid');
      u\EXPECT((bool) $txid, 'saving usd record');
    }

    if ($amount0 < 0) { // outgoing - tell staff to transfer the funds using ACH or check
      /* $this->update('balance', $this->o_balance + $amount0); */
      if ($txid > 0) r\tellAdmin(t('outgoing bank transfer'), ['amount' => -$amount0]);
    } elseif ($completed) $this->completeUsdTx(0, $amount0, TRUE);

    unset($DBTX);
    
    $msg = 'banked';
    if ($amount0 > 0) $msg .= '|bank tx number' . ($completed ? '|available now' : '');
    $action = $amount0 < 0 ? t('deposit to') : t('draw from');
    $msg = tr($msg, ray('action amount checkNum', $action, u\fmtAmt(abs(@$amount0)), $txid));
    r\notify($this->id, $why = tr($msg, compact('why')));

    return $txid;
  }
	
  /**
   * Return information about a same-direction request to combine with.
   * @param numeric $amount: amount requested
   *                         (RETURNED) amount, modified as appropriate
   * @param int $completed: desired completion date (NULL if none)
   * @param int $completed: (RETURNED) completion date of new or modified request (0 if not yet)
   * @return $txid transaction ID of transaction to modify (FALSE if none)
   */
  private function combineUsdTx(&$amount, &$completed) {

    if (!$this->bankOk) return FALSE;
    if ($amount > 0 and $amount + $this->advances() - $this->balance > -$this->floor) $completed = 0; // only 0 if bringing in beyond credit line
    $where = 'payee=:id AND amount>0 AND NOT deposit AND NOT completed';
    if ($res = db\get('txid,amount AS oldAmount', 'r_usd', $where, ray('id', $this->id))) {
      extract($res);
      $amount += $oldAmount;
    } else $txid = FALSE;
    return $txid;
  }

  /**
   * Create a zero USD transfer record to verify the bank account.
   */
  public function verifyBank($channel = TX_SYS, $amount = 0) {
    list ($bankAccount, $payee) = [@$this->vsecure['bankAccount'], $this->id];
    if (db\exists('r_usd', compact(ray('amount payee bankAccount')))) return; // already being verified
    for ($txid = 1; $txid < 999999; $txid++) { // actual transfers start sometime after 999,999
      if (db\exists('r_usd', 'txid=:txid', compact('txid'))) continue;
      if ($txid = db\insert('r_usd', compact(ray('txid amount payee bankAccount channel')), 'txid')) break;
    }
    u\EXPECT($txid, 'ran out of low txids');
  }			

  /**
   * Automatically cashout accounts that choose to, leaving average weekly gross (over past 6 months) in the account. Weekly gross is figured as -6/26th of the floor (because there are 26 weeks in 6 months and floor is based on 1/6 of 6 months' gross).
   */
  public function cashout() {

    $waiting = $this->waitingFromBank($combinable); // net amount already requested from bank (if any)
    if ($waiting > 0) return; // no cashout if waiting to bring some in
    $cashout = round($this->balance - -$this->floor * 6 / 26 + $waiting, -1); // (waiting is negative)
    if ($cashout < R_ACHMIN) return;
    if (!$this->bank(-$cashout, $zot)) return;
  }
  
  /**
   * Mark an incoming USD transfer complete, update cache, and report.
   * @param int $txid: the transfer record ID (if empty, no need to mark it complete)
   * @param numeric $amount: transfer amount from bank to CG (positive)
   * @param bool $automatic: <transfer was created automatically>
   * @return <success>
   */
  public function completeUsdTx($txid, $amount, $automatic) {

    
    $DBTX = \db_transaction();

    if ($txid) { // unless transfer is already marked complete
      $realAmt = db\get('amount', 'r_usd', 'txid=:txid', compact('txid'));
      if ($amount != $realAmt) r\tellAdmin(t('bad completeUsdTx amt'), compact(ray('txid amount realAmt automatic')));
      if (!db\update('r_usd', ['txid'=>$txid, 'completed'=>r\rTime()], 'txid')) return FALSE;
    }
    
    //    $this->update('r', $this->o_r + $amount);
    /* $this->update('balance', $this->o_balance + $amount); */
    unset($DBTX);
    
    $transfer = $automatic ? t('automatic transfer') : t('transfer');
    $amount = u\fmtAmt($amount);
    r\notify($this->id, 'transfer complete', compact('transfer', 'amount'));
    //    if (!$this->can(B_BONA)) r\message($this->id, 'account funded');
    return TRUE;
  }

  /**
   * Suggest autorrefills or a higher minimum, etc. (because of a failed purchase).
   * This might make sense to use on the WEB interface also (just change the $channel line below), but the message would need to be added AFTER the basic error message.
   */
  public function suggestAuto() {

    global $channel; if (!in_array($channel, [TX_POS])) return;
		
    $web = ($channel == TX_WEB);

    if (!$web) $msg[] = 'you were short';
    $msg[] = $this->hasBank ? ($this->refill ? 'suggest higher target' : 'suggest refills') : 'how to fund';

    /*		
		$suggested0 = max(R_ACHMIN, (R_SUGGEST_BUMP * $this->minimum) ?: 100);
		$suggested = u\fmtAmt($suggested0);
		$_a1 = $this->makeDo('min', $suggested0);
    */	
		
    if ($this->secret) {
      $_aSecret = $web ? w\atag('/settings/preferences') : $this->makeDo('nosecret');
      $msg[] = 'be not secretive';
    }
    if (!$this->debt and $this->floor < 0) {
      $_aDebt = $web ? w\atag('/settings/preferences') : $this->makeDo('debtok');
      $msg[] = 'try debt';
    }
		
    $msg = join('|', $msg);
    $args = @compact(ray('suggested _a1 _aSecret _aDebt'));
    if ($web) return t($msg, $args); else r\notify($this->id, $msg, $args);
  }
	
  /**
   * Return the next suggested date, type, and description to contact this member for a standard checkin.
   * @param mixed $done: <asking because a checkin was just completed> or "activate"
   * @return [$type, $date] or ['', 0, ''] if none
   *   $type: a one-word call type
   *   $date: the suggested date
   */
  public function nextTickle($done = FALSE) {


    $now = time();
    $activate = ($done . '' == 'activate');
    if ($activate) {
      list ($done, $activated) = ['', $now];
    } else {
      if (!$this->member) {
        if ($this->nonudge or $now - $this->created < HOUR_SECS) return ['', 0];
        return [@$this->federalId ? 'setup' : 'pre', max(0, $this->created)];
      } elseif (!$this->ok) return ['activate', $now];
      $activated = max($this->activated, strtotime('1/1/2013')); // max is for testing
    }
    
    if ($this->signupCo) $signupCo = w\signupCoDisplay($this->signupCo) . ',';
    $daysIn = ($now - $activated) / DAY_SECS; // how many days after activation are we
    $tickleDaysIn = $this->tickle ? ($this->tickle - $activated) / DAY_SECS : 0; // how many days after activation to tickle

    if ($activate or ($tickleDaysIn < 90 and $daysIn < ($done ? 8 : 90))) { // not welcoming if wrong time or done at right time
      $when = $activated + (($this->giftsDesc() and !$this->cttyA->isRegion) ? TICKLE_WELCOME : TICKLE_DELAYED) * DAY_SECS;
      return ['welcome', $when];
    }
    $yearsIn = max(1, round($daysIn / 365.25));
    if ($done and abs($yearsIn * 365.25 - $daysIn < 30)) $yearsIn++;
    return ['annual', strtotime("+$yearsIn years", $activated)]; // Annual
    // if (($daysIn + 30) mod 365 < 2 * 30) 
    //return [0, ''];
  }

  /**
   * Return a description of the members gift history. The total gifts include first planned gift, if none completed yet.
   * @param string $period: (RETURNED) frequency of latest gift
   * @param string $totalGifts: (RETURNED) total gifts with no mention of latest
   * @return: description of gifts (FALSE if none)
   */
  public function giftsDesc(&$period = '', &$totalGifts = '') {

    $gift = '';
    /* A gift is a transaction where one entry refers to the member and another entry refers to CG. */
    $sql = <<< EOF
      SELECT r.created AS recurStart, r.amount AS recurAmt, r.period, h.honor, h.honored,
             t.created AS lastGiftDate, e2.amount AS lastGift 
      FROM r_recurs r
           LEFT OUTER JOIN r_honors h ON r.payer=h.uid
           JOIN r_entries e1 ON r.payer=e1.uid
           LEFT OUTER JOIN r_tx_hdrs t USING(xid)
           JOIN r_entries e2 ON e2.xid=t.xid AND e2.uid=r.payee
           LEFT OUTER JOIN r_tx_hdrs tRev ON tRev.reversesXid=t.xid
      WHERE (r.payer = :id) AND (r.payee = :CGID) AND (e1.uid = :id) AND (e2.uid = :CGID) AND
            t.:IS_GIFT AND tRev.xid IS NULL AND t.reversesXid IS NULL ORDER BY t.created DESC LIMIT 1
EOF;
    $results = db\q($sql, ['id' => $this->id]);
    if ($results->rowCount() == 0) { return FALSE; }
    extract($results->fetchAssoc());
    if ($period) {
      $period = u\arrayGet(ray(OFTENS), 'period', '');
      $recurAmt = u\fmtAmt($recurAmt);
      $recurStart = u\fmtDate($recurStart, TRUE);
      $gift = "<%b>$recurAmt</b> $period";
    }
    $gift = u\unite($gift, t('Last: %lastGift (%lastGiftDate)', 'lastGift lastGiftDate',
                             u\fmtAmt($lastGift), u\fmtDate($lastGiftDate, TRUE)),
                    ', ');
    if (!is_null($honored)) {
      $gift = u\unite($gift, u\honorDesc($honor) . $honored, ', ');
    }

    $amt = $this->totalGifts();
    $totalGifts = ($amt) ? u\fmtAmt($amt) : null;
    if (!is_null($totalGifts)) {
      $totalGifts = t('<%b>%totalGifts</b> to date', compact('totalGifts'));
    }
    $totalGifts .= trim(($this->roundup ? t(' +<%b>roundups</b>') : '') .
                        ($this->crumbs > 0 ? t(' +<%b>%crumbs% crumbs</b>', 'crumbs', $this->crumbs * 100) : ''));
    foreach (ray('totalGifts gift') as $k) $$k = tr($$k, '_b', 'b class="positive"'); // must do to each, not together

    return u\unite($totalGifts, $gift, ', ');
  }

  /**
   * Return a link to a "no signin required" action.
   * Omit $life only for a forever link not specific to a particular account
   * @param string $op: what to do (REQUIRED)
   * @param numeric $v: an amount or identifier
   * @param int $life: number of seconds until link expires (link gets invalidated after doing operation once)
   * @param assoc $info: other parameters (sql, subs, etc.)
   * @return <a> tag guts for a clickable link that will do something without requiring the member to sign in
   *    makeDo0 returns just the url (for form action, for example)
   * @see also r\Web\rdo()
   */
  function makeDo0($op, $v = NULL, $life = WEEK7_SECS, $info = []) {
    //  extract($data = rayy(func_get_args()) ?: $data);
    extract($info);
    $info += compact('op');
    if (!is_null($v)) $info += compact('v');
    
    if (@$life) {
      $data = ray('uid expires data', $this->id, r\rTime() + $life, serialize($info));
      $info = ray('op', db\insert('r_do', $data, 'doid')); // (preliminary) op is r_do record ID
    } else $info += ['mo'=>rdoMonth()]; // remember month, in case we need to know when link was created

    return BASE_URL . "/do/" . r\makeDoCode($info);
  }
  function makeDo($op, $v = NULL, $life = WEEK7_SECS, $info = []) {
    return 'a href="' . $this->makeDo0($op, $v, $life, $info) . '"';
  }
  
  /**
   * Set the bit in the given integer bit collection field to the given value.
   * If the requested bit is too high, "2" (or more) gets appended to the collection name
   * @param int $bit: number of bit to set (0 - 30)
   * @param bool $on: whether to set it ON or OFF
   * @return <successful>
   */
  public function setBitx($bit, $on = TRUE, $field = 'flags') {
    if ($bit > B_MAX) $field .= 1 + floor($bit / (B_MAX + 1));
    $n = $this->$field;
    u\setBit($n, $bit, $on);
    return $this->update($field, $n);
  }

  /**
   * Set the bit (identified by number or name) in the "risks" integer bit collection field.
   * @param mixed $bit: number of bit to set (0 - 31) or name of bit
   * @param bool $on: whether to set it ON or OFF
   */
  public function setRisk($bit, $on = TRUE) {$this->setBitx($this::riskBit($bit), $on, 'risks');}
    
  public function risk($bit) {return u\getBit($this->risks, $this::riskBit($bit));}
  
  /**
   * Return the bit number for risk bit name.
   * @param mixed $bit: the bit name or number
   * @return the bit number
   */
  private static function riskBit($bit) {
    if (is_numeric($bitName = $bit)) return $bit;
    $acctRiskBits = array_flip(array_keys(ray(K_ACCT_RISKS)));
    $txRiskBits = array_flip(array_keys(ray(K_TX_RISKS)));
    return is_numeric($bit = @$acctRiskBits[$bitName]) ? $bit : $txRiskBits[$bitName];
  }
  
  //  private static function flagBit($bit) {return is_numeric($bit) ? $bit : u\consta('b', $bit);}
  public function coCan($bit = NULL) {return u\getBit($bit <= B_MAX ? $this->coFlags : $this->coFlags2, $bit);}
  public function setCoBit($bit, $on = TRUE) {$this->setBitx($bit, $on, 'coFlags');}
  
  public function setCoCans($cans) {
    $coFlags = $this->coFlags;
    for ($i = 0; $i < 2 * APP_CAN_BITS; $i++) {
      $bit = u\bit(APP_CANS + $i);
      $coFlags = isset($cans[$i]) ? ($coFlags | $bit) : ($coFlags & ~$bit);
    }
    $this->update(compact('coFlags'));
  }

  /**
   * Set all account risk bits at once (called from formSummary for community admins)
   * @param array $values: numeric array of bit values (eg [3 => 3, 5 => 5])
   */
  public function setRisks($values) {
    $risks = $this->risks;
    $riskBits = array_values(just(K_ACCT_RISKS_EDITABLE, array_flip(array_keys(ray(K_ACCT_RISKS))))); // editable risk bits
    foreach ($riskBits as $bit) u\setBit($risks, $bit, isset($values[$bit]));
    $this->update(compact('risks')); // update all at once, for efficiency
  }
  
  /**
   * Set all appropriate bits in the flags field (called from formSummary for community admins)
   * @param array $values: numeric array of bit values (eg [3 => 3, 5 => 5])
   */
  public function setBits($values) {

    u\setDft($values, []); // fails in arg list (dunno why)
    $flags = $this->flags;
    foreach ($this->adminables() as $bitName) { // set all these on or off
      //      if (substr($bitName, 0, 1) == 'u') continue; // lowercase u means undefined
      $bit = u\consta('b', $bitName);
      $on = isset($values[$bit]); // isset because bit 0 is 0 when checked
      u\setBit($flags, $bit, $on);
    }
    $this->update(compact('flags'));
  }  

  /**
   * Say whether another active account has the same address
   */
  public function dupAddr() {

    if (!$address = $this->address) return FALSE;
    $q = db\q('SELECT uid FROM users WHERE :IS_OK AND uid<>:id AND zip=:zip', ray('id zip', $this->id, $this->zip));
    while ($row = $q->fetchAssoc()) if (r\acct($row['uid'])->address = $address) return TRUE;
    return FALSE;      
  }

  /**
   * Change the account's community.
   * @param int $newCtty: the new community uid
   * @param bool $retro: (UNUSED) <change rewards transactions retroactively>
   * @param string $err: (RETURNED) the error message, if any
   * @return <success>
   */   
  public function changeCtty($newCtty, $retro = FALSE, &$err = '') {

    if (!db\exists('users', 'uid<1 AND uid=:newCtty', compact('newCtty'))) return !$err = 'bad ctty';
    
    //    $DBTX = \db_transaction();
    $this->update('community', $newCtty);
    //    if ($retro) db\q('UPDATE r_txs SET payer=:newCtty WHERE payee=:myid AND type IN (:TX_REWARDS)', ray('newCtty myid', $newCtty, $this->id));
    //    unset($DBTX);
    return TRUE;
  }

  /**
   * Set the account's latitude and longitude.
   * For example: eachA(function ($a) {$a->setLocus();}, 'latitude=0 AND longitude=0');
   *
   * Choices for geocoding services:
   * https://api.opencagedata.com/geocode/v1/json?q=ADDRESS&key=API_KEY (free for up to 2,500 a day)
   * https://maps.googleapis.com/maps/api/geocode/json?address=ADDRESS&key=API_KEY (we are not signed up yet, 0.5c each)
   * https://geocoding.geo.census.gov/geocoder/locations/onelineaddress?format=json&benchmark=Public_AR_Current&address=ADDRESS (no API_KEY needed, but fails 7% of the time and no way to approximate the address)
   */
  public function setLocus($lat = NULL, $lon = NULL) {
    if (u\test()) return; // doesn't work on DEV machine yet
    $a = $this;
    if (!is_null($lat)) return $a->update('latitude longitude', $lat, $lon);
    
    $params = ray('q key', "$a->address, $a->city, " . r\realState($a->state), GEOCODE_KEY);
//    $params = ray('street city state', $a->address, $a->city, r\realState($a->state)); // US Census
    if (!$res = file_get_contents($url = GEOCODE_URL . http_build_query($params))) return r\tellAdmin(t('setLocus <%a>failed</a>', '_a', w\atag($url)));
    $res = json_decode($res);
    if (!$coods = @$res->results[0]->geometry) {
      $a->setRisk('addrOff');
      return r\tellAdmin(t('setLocus <%a>returned</a> no match', 'a', w\atag($url)));
    }
/*    if (!$matches = (array) @$res->result->addressMatches) return r\tellAdmin(t('setLocus <%a>returned</a> no matches', 'a', w\atag($url))); // US Census
    $coods = @$matches[0]->coordinates;
    $coods = [$coods->y, $coods->x];
    */
    $a->update('latitude longitude', $coods->lat, $coods->lng);
  }    
   
  /**
   * Say whether this settings/agent has the permission.
   * @param int $bit: the permission in question (DEFAULT B_READ)
   */
  public function can($bit = B_READ) {

    if ($bit <= B_MAX) { // ordinary bits
      $can = (bool) ($this->flags & (1 << $bit)); // these are easy. be efficient.
      if (in($bit, [B_ADMIN2, B_CADMIN2, B_CADMIN, B_ADMIN])) {
        if ($this->id == 1) return TRUE; // this didn't use to be necessary (9/20/2017)
        if (!$this->proSe) return ($aa = $this->agentA and $aa->can($bit)); // admin permissions are for agent instead (in tests, agent sometimes doesn't exist)
        if (!$can and $bit < (R_ADMIN_CAN_MANAGE_CTTYS ? B_ADMIN : B_CADMIN)) return $this->can($bit + 1); // not this admin bit, maybe the next higher? IMPORTANT NOTE: this gives cAdmin2 Admin2 permission, so always use ->isAdmin2 rather than ->admin2 unless you WANT cAdmin2 to have the permission in question
      }
      return $can;
    }

    if ($bit == B_CTTYUP) return $this->cttyA->up;

    if ($bit == B_BANK) return $this->hasBank; // might get set after getCans() is called
    if ($bit == B_CLOSED) return $this->closed;
    $cans = @self::$perms[$this->id][$this->agentId] ?: $this->getCans($bit);
    return $cans[$bit];
  }

  /**
   * Set up permissions (::$perms) if we haven't yet
   * @return the permissions array for this account
   */
  private function getCans($bit) {

    $aa = $this->agentA;
    $id = $this->id;
    
    $cans[B_PERSON] = !$this->can(B_CO);
    if ($id == 1) $cans[B_ADMIN] = TRUE;

    $perm = $this->closed ? B_READ
      : ($this->proSe ? B_MANAGE
         : (($aa->can(B_CADMIN) and $this->community == $aa->community) ? B_MANAGE : 0) );
      
    if (!$perm) $perm = max(B_RELATED + $this->permission,
                            ($aa->can(B_ADMIN2) or ($aa->can(B_CADMIN2) and $this->community == $aa->community)) ? B_READ : 0);
      
    for ($i = B_RELATED; $i <= B_MANAGE; $i++) $cans[$i] = ($i <= $perm); // set all, even the false ones

    if (!$this->can(B_OK)) $cans[B_SELL] = $cans[B_BUY] = FALSE; // (read here kills acct dropdown)

    //    if (!$this->can(B_MEMBER)) $cans[B_BUY] = FALSE; // no spending even the SIGNUP GIFT for non-members
    
    if ($aa->can(B_ADMIN) and R_ADMIN_CAN_MANAGE_CTTYS) { // temporary extra power, until communities are independent
      $cans[B_READ] = $cans[B_SCAN] = $cans[B_SELL] = $cans[B_BUY] = $cans[B_MANAGE] = TRUE;
    }
    $cans[B_DEV] = (isDEV or $aa->can(B_ADMIN)); // used in menu system for tests page, etc.
    //    if ($cans[B_MANAGING_CTTY] = ($aa->can(B_CADMIN) and $id == $this->community)) $cans[B_BUY] = TRUE;
    $cans[B_MANAGING_CTTY] = ($aa->can(B_CADMIN) and $id == $this->community);
    
    ksort($cans); // easier to debog
    return self::$perms[$id][$this->agentId] = $cans;
  }

  /**
   * Encrypt the highly sensitive data private key for a new regional admin's sign-in form.
   * @param string $vKey: key text (PEM-formatted or not) or file path with key text
   *   If $vKey is omitted, get it from the current administrator
   *   WARNING: This function invalidates an admin's flash drive sign-in form.
   * @return the encrypted private key (vKeyE), encrypted with the account's own password (vKeyPw).
   */
  public function makeVKeyE($vKey = '') {

    if (!$vKey = u\unfmtKey($vKey) and !$vKey = r\vKey()) return t('No private key given or available.');
    $this->update('vKeyPw', $vKeyPw = openssl_random_pseudo_bytes(32));
    if (isDEV) \setV('vKeyPw', $vKeyPw); // otherwise this gets lost during testing
    $vKeyE = u\cry('R', $vKey, FALSE, $vKeyPw);
    ///		debug('pwLen=' . strlen($vKeyPw) . ' vkELen=' . strlen($vKeyE));
    //	  r\setCryptCook('vKeyE', $vKeyE); // NO! (admin should sign out after calling with $vKey arg, to test it)
    return u\b64encode($vKeyE); // ready for signin form on flash drive
  }
	
  /**
   * Call a function for each co-branding partner for whom the current account is a customer.
   * @param function(coA, custA, custCode) $func: the function to call, with three parameters:
   *   coA: company account
   *   custA: customer account
   *   custCode: the company's identifier for the customer
   */
  public function eachPartner($func) {
    $sql = 'SELECT main, code FROM r_relations WHERE other=:id AND :IS_CUSTOMER ORDER BY code';
    $res = q($sql, ['id' => $this->id])->fetchAllKeyed();
    foreach ($res as $main => $code) $func(r\acct($main), $this, $code);
  }
  
  /**
   * Return specified account's profile picture, with markup
   * @param bool $unique: should the markup force reloading the image
   * @return: markup to display the account's picture (with a default image if none or not permitted)
   * Use result with DRUPAL_ROOT . $result OR $base_url . $result
   */
  public function photoHtml($small = FALSE, $unique = FALSE) {

    return '<div id="user-picture"><img src="' . $this->photoSrc($small, $unique) . '" alt="profile picture" /></div>';
  }
  
  /**
   * Return src attribute for specified account's profile picture, no markup, just the src
   * @param bool $unique: should the markup force reloading the image
   * @return: value for the src attribute to display the account's picture (with a default image if none or not permitted)
   * Use result with DRUPAL_ROOT . $result OR $base_url . $result
   */
  public function photoSrc($small = FALSE, $unique = FALSE) {

    global $base_url;
    if ($unique) $unique = '&t=' . r\rTime();
    $thing = $small ? 'icon' : 'photo';
    $qid = $this->co ? "qid=$this->mainQid" : '';
    //    if (!$this->co) $qid .= "/$this->cardCode";
    return "$base_url/account-photo/$qid$unique";
  }
  
  /**
   * Get and store SSN verification from 3rd party (in the background).
   * ssn step is marked done if all of the following are true:
   * . supplied last name (dba or legal) matches
   * . at least one other piece of name (dba or legal) matches, that has at least 4 letters
   * . birth date matches
   * . person is not dead
   * @param bool $force: redo search
   * @return the data
   */
  public function ssnCheck($force = FALSE) {

    if ($this->federalId == '000000000') return t('Nonmember SSN.');
    if (!@$this->federalId) return t('No SSN yet.');
    if ($this->federalId == '999999999') return t('SSN is a test.');
    //    if (u\isEncrypted($this->federalId)) return t('SSN available only to superAdmin');
    if (@$this->ssnData and !u\starts(@$this->ssnData[SSN_ERR_INDEX], SSN_TIMEOUT_MSG) and !$force) return $this->ssnData;
    
    $max = 5;
    for ($i = 0; $i < $max; $i++) {
      if ($ssnData0 = u\ssnLookup($this->federalId) and !strpos($ssnData0, 'RequestTimedOutException')) break;
    }
    if ($i == $max) return $this->ssnErr(SSN_TIMEOUT_MSG . t(' on %max tries.', compact('max')));

    $xml = simplexml_load_string($ssnData0);
    $json = json_encode($xml);
    $ssnData = json_decode($json, TRUE);
    if (!is_array($d = $ssnData['searchResults']) or $ssnData['ResultCount'] + 0 <= 0) { // 0 for tests, <=0 for failure
      /**/    return $this->ssnErr(t('No SSN data available: ') . print_r($ssnData0, 1));
    }
    unset($ssnData['searchResults']['ssn']); // has first 5 digits of SSN -- don't store it
    $this->update(compact('ssnData'));
    if (@$d['deathsearchresults']) return $this->ssnErr(t('The person is dead (?).'), $ssnData);
    
    list ($first1, $last1, $mid1) = u\parseName($this->fullName, TRUE);
    list ($first2, $last2, $mid2) = u\parseName($this->legalName, TRUE);
    foreach (ray('first1 last1 first2 last2') as $k) $$k = strtolower($$k);
    
    $Ls = $Fs = $DOBs = [];
    $names = @$d['ssnnames']['ssnname'];
    if (@$names['lastname']) $names = [$names]; // handle case of just one name
    
    foreach ($names as $one) {
      $one = (object) $one;
      $name = u\ssnName($one, $F, $M, $L);
      $Ls[] = strtolower($L);
      if (strlen($F) > 1) $Fs[] = strtolower($F);
      if ($M) foreach (explode(' ', strtolower($M)) as $F) {
          if (strlen($F) > 1) $Fs[] = $F;
        }
      if (@$one->dob) $DOBs[] = strtotime($one->dob);
    }
    
    if (!array_intersect([$last1, $last2], $Ls)) return $this->ssnErr(t('Last name does not match.'), $ssnData);
    if (!array_intersect([$first1, $first2, $mid1, $mid2], $Fs)) return $this->ssnErr(t('First name does not match.'), $ssnData);

    if ($DOBs) {
      if (!in($this->dob, $DOBs)) return $this->ssnErr(t('bad birthdate'), $ssnData);
    } else {
      $this->ssnErr(t('Cannot verify birthdate'), $ssnData);
      $this->setRisk('dobOff'); // nothing to compare, so don't ask member to retype dob
    }
    
    $this->stepDone('ssn');
    return $this->ssnData;
  } 
    
  /**
   * Try to transfer funds from payer to payee for a pre-approved payment.
   * @param int $payeeId: record ID of recipient -- expected to be an active account, 
   *   but payer can be a not-yet-activated account (to be invoiced) for gifts to CG
   * @param numeric $amount: payment amount
   * @param string $desc: description of payment
   * @param assoc $data: extra data for transaction or invoice
   * @return TRUE if the funds were successfully transferred (otherwise the payer is invoiced).
   */
  public function payApproved($payeeId, $amount, $desc, $data = []) {
    $payee = r\acct($payeeId);
    u\EXPECT($payee->ok, 'inactive recipient');
    if ($payeeId != CGID or $this->activated) u\EXPECT($this->ok, 'inactive payer'); // not-yet-active accounts can be invoiced for gifts to CG

    if ($this->ok) {
      list ($msg, $args) = $this->pay($payee, $amount, $desc, $goods, $data);
      if (u\arrayGet($args, 'success', FALSE)) return TRUE;
    }
    $data['status'] = TX_APPROVED;
    list ($msg, $args) = $payee->invoice($this, $amount, $desc, $data);
    return FALSE;
  }

  /**
   * Return the account's total gifts to the Common Good.
   */
  function totalGifts() {
    return db\sum('e1.amount', 'r_tx_hdrs t JOIN r_entries e1 USING(xid) JOIN r_entries e2 USING(xid) JOIN r_tx_hdrs tRev ON t.xid=tRev.reversesXid',
                  'e1.uid=:payerId AND e2.uid=:CGID AND t.:IS_GIFT AND tRev.xid IS NULL AND t.reversesXid IS NULL',
                  [ 'payerId' => $this->id ]);
  }
  
  /**
   * Set ssnData to an error message and maybe more
   * @param string $s: the error message
   * @param assoc $ssnData: whatever ssn Data we received from the lookup service
   */
  public function ssnErr($s, $ssnData = []) {
    $this->update('ssnData', $res = $ssnData + [SSN_ERR_INDEX => $s]);
    return $res;
  }
  
  public function isMe($uid) {return ($uid == $this->id or $uid == $this->jid);}
  public function codeHash() {return u\hash($this->cardCode());}
  public function o($k) {return $this->{'o_' . $k};}
  public function api($etc = '') {return $this->website ? tr(CO_API_URL, 'website etc', $this->website, $etc) : '';}
  public function lastTx($where = 1, $subs = []) { return r\Tx::lastTx([$this->id, $this->jid], $where, $subs); }
  public function lastTxDesc() {return ($tx = $this->lastTx) ? t(' (Last tx: %dt)', 'dt', u\fmtDate($tx[3], TRUE)) : '';}
  public function firstCo() {return db\get('fullName', 'r_relations r INNER JOIN users u ON r.main=u.uid', 'r.permission>0 AND r.other=:id AND u.:IS_CO ORDER BY r.created LIMIT 1', ['id' => $this->id]);}
  public function adminables() {
    $res = ray(B_ADMINABLE . ($this->admin ? ' admin2' : '') . ($this->superAdmin ? ' admin' : ''));
    return array_values($this->isCtty ? array_intersect($res, ray(B_CTTY_BITS)) : array_diff($res, ray(B_CTTY_BITS)));
  }
  public function pay($a2, $amt, $for, $goods, $extra = []) {return be\transfer('payment', $this, $a2, $amt, $for, $goods, $extra);}
  public function charge($a2, $amt, $for, $goods, $extra = []) {return be\transfer('charge', $this, $a2, $amt, $for, $goods, $extra);}
  public function invoice($a2, $amt, $for = NULL, $goods, $extra = []) {return be\invoice($this, $a2, $amt, $for, $goods, $extra);}

  public function nextTid() {
    $maxTid = db\get('MAX(acctTid)', 'r_entries', 'uid in (:uids)', ['uids' => [$this->id, $this->jid]]);
    /// debug("maxTid is $maxTid");
    if (empty($maxTid)) $maxTid = 0;
    return 1 + $maxTid;
  }
} // end of class

/**
 * Return an account object for the described account.
 * call by:
 *   r\acct()       (returns current account)
 *   r\acct($uid)
 *   r\acct($main, $agent)
 *   r\acct($main, $agent, $error)
 *   r\acct($email)
 * @param int $uid: account uid
 * @param int $main: main account uid
 * @param int $agent: agent uid
 * @param string $email: email address for the account
 * @param string $error: error message, if any
 * @return the appropriate account object (FALSE if none)
 */
function acct($uid = '', $agent = '', &$error = '') {
  u\EXPECT(!is_array($uid), 'array uid'); // otherwise hangs (at least for a drupal field array)
  global $mya; // use this ONLY in this class file
  if (!$uid) return $mya ?: (!$error = 'There is no current account.');
  if (strpos($uid, '@')) {
    $uid = db\get('uid', 'users', 'email=:email ORDER BY :IS_CO', ['email' => u\cry('P', $uid)]);
  } elseif (FALSE and preg_match('/[0-9]( |-|\\)) ?[0-9]{4}/', $uid)) {
    $uid = db\get('uid', 'users', 'phone=:phone ORDER BY :IS_CO', ['phone' => u\cry('P', u\fmtPhone($uid, '+n'))]);
  }
  //  if (!$ua = r\Acct::viable($uid, $agent, $error, TRUE)) return FALSE;
  if (!$ua = r\Acct::viable($uid, $agent, $error, TRUE)) return FALSE;
  return new r\Acct($ua); // the only place we call new r\Acct() with a flat array (meaning an existing account)
}

/**
 * Return an account object for the agent of the given account.
 */
function agent($uid = '') { $a = r\acct($uid); return $a ? $a->agentA : NULL; }
