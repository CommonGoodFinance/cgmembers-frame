<?php
namespace rCredits;
use \rCredits\API as api;
use \rCredits\Util as u;

/**
 * @file
 * rCredits Account class
 */

class acct {
  var $id; // the account's record id
  var $region; // the account region's record id
  var $agent; // record id (in the agent's regional server) of whoever is acting on behalf of the account
  var $agentRegion; // record id of agent's region (on this server)
  private static $records = array(); // account records for all acct objects, indexed by id
  
  /**
   * Instantiate an account.
   * @param id/qid $id: the account's record id (can this be a community?) OR
   * @param id/qid $agent: the agent's record id on this server OR the foreign agent's qid
   * @param assoc $info: the member's account record (considered partial until ->id is there)
   */
  function __construct($id, $agent = '', $info = array()) {
    list($this->id, $this->agent, $this->region, $this->agentRegion) = acct::ok($id, $agent, $zot, FALSE);
    self::$records[$this->id] = (object) $info;
  }    

  /**
   * Setup acct variables, returning FALSE on error.
   */
  public static function ok($id, $agent0='', &$error='', $test = TRUE) {
  if ($test) {echo(print_r(compact('id','agent0'),1)); }
    if ($error = u\expect(compact(u\ray('id agent0')), 'id|qid empty|id|qid', $test)) {echo(print_r(compact('id','agent0'),1)); die("error=$error id=$id agent0=$agent0 test=$test");}
    if ($error = u\expect(compact(u\ray('id agent0')), 'id|qid empty|id|qid', $test)) return FALSE;
    list ($id, $agent, $region) = u\is_id($id) ? array($id, $agent0, server_uid()) : ruid($id);
    if ($agent0) {
      if ($error = u\expect(($id == $agent), 'agent already specified in qid', $test)) return FALSE;
    } else $agent = $id; // proSe (account is acting on its own behalf)
    if (u\is_qid($agent0)) {
      list ($agent, $zot, $agentRegion) = ruid($agent0);
      if ($error = u\expect($agent == $zot, 'agent agent not allowed', $test)) return FALSE;
    } else $agentRegion = server_uid();
    return array($id, $agent, $region, $agentRegion);
  }
  
  public function __get($field) {
//    if (!@$this->record[$field] and !@$this->record['id']) { // don't read if we have partial data (typically full_name)
      if ($this->region != server_uid()) { // foreign
        // contact other server here, for the record
      } else self::$records[$this->id] = \user_load($this->id); // domestic (use Drupal's caching)
//    }
    u\expect(array_key_exists($field, self::$records[$this->id]));
    return self::$records[$this->id]->$field;
  }
  
  public function update($info) {
    if (!@self::$records[$this->id]->uid) self::$records[$this->id] = \user_load($this->id);
    foreach ($info as $field => $value) {
      if ($field != 'uid') self::$records[$this->id]->$field = $value;
    }
    $info['uid'] = $this->id;
    return \drupal_write_record('users', $info, 'uid');
  }
  
  public function proSe() {return ($this->id == $this->agent);}  
  public function exo() {return qid($this->id, u\n2a(-$this->region, 3), 3);}
  function hasBit($bit) {return (bool) ($this->flags & $bit);}
  
  public function setBit($bit) {
    $flags = ($this->flags | $bit);
    $this->update(compact('flags'));
  }
}
