<?php
namespace rCredits;
use rCredits as r;
use rCredits\Backend as be;
use rCredits\Util as u;
use rCredits\Testing as t;

/**
 * @file
 * rCredits Account class
 */

class acct {
  var $id; // the account's record id
  var $regionId; // the account region's record id
  var $agentId; // record id (in the agent's regional server) of whoever is acting on behalf of the account
  var $agentRegion; // record id of agent's region (on this server)
  var $mainQid; // nearly alphabetic representation of id, id, and region for external queries
  private static $perms = array(); // permissions for all acct objects, indexed by id and agent
  private static $records = FALSE; // account records for all acct objects, indexed by id
  
  /**
   * Instantiate (create or retrieve) a member account for transactions and/or contact
   * Call by:
   *   new acct(info) OR
   *   acct(uid, agent) (see the acct() function below)
   * @param assoc $info: initial field values for the account, to be created and saved in the database, including at least one of the following:
   *   'uid' the record id
   *   'phone' is contact phone (in standard +ddddddddddd format) OR
   *   'number' is cell phone (in standard +ddddddddddd format -- use for phone also) OR
   *   'email' is email address
   *   UNUSED (because it's hard to verify): 'website' is website address
   *   (This function assumes that the info is not sufficient to identify an existing user)
   * @param id/qid $id: the account's record id (can this be a community?) (DEFAULT to cuid)
   * @param id/qid $agent: the agent's record id on this server OR the foreign agent's qid (DEFAULT to same as $id)
   */
  function __construct($id = array(), $agent = '') {
    if (is_array($info = $id)) { // referring to existing db record
      $this->createNew($info); // create new db record
    } else list($this->id, $this->agentId, $this->regionId, $this->agentRegion) = acct::ok($id, $agent, $zot, FALSE);

//    if ($this->id > 0) $this->mainQid = qid($this->id, u\n2a(-$this->regionId, 3), 3); // no qids for communities and regions!
    if ($this->id > 0) $this->mainQid = quid($this->id, $this->id, $this->regionId); // no qids for communities and regions!
  }    

  /**
   * Create a new account record in the database.
   * @param assoc $info: array of field values for new account
   */
  private function createNew($info) {
    extract($info, EXTR_PREFIX_ALL, 'my');   
    if (isset($my_number) and !isset($my_phone)) $my_phone = $my_number;
    if (isset($my_phone)) $phone = u\formatPhone($my_phone, '+n');
    
    $status = TRUE;
    $mail = $init = @$my_mail ?: (@$my_email ?: '');
    if (@$my_pass) {
      require_once DRUPAL_ROOT . '/includes/password.inc';
      $pass = \user_hash_password(trim($my_pass));
    }
    $short_name = @$my_fullName ? u\shortName($my_fullName) : '';
    $name =  @$my_name ?: (@$short_name ?: tempName($info));
    $fullName = @$my_fullName ?: $info['name'];
    $flags = @$my_flags ?: B_DEFAULTS;
    $community = communityUid(@$my_postal); // defaults to current server
    $data = serialize(@$my_data ?: array());
    $frozen = serialize(array());
    $created = $login = $access = REQUEST_TIME;
    $info = compact(u\ray('phone status mail init pass name fullName flags community data created login access')) + $info;

    $DBTX = db_transaction();
    if (!$uid = @$my_uid) {
      for ($try = 0; $try < 20; $try++) { // limit the retries
        $uid = $info['uid'] = self::nextId($region);
        if (r\dbInsert('users', $info)) break;
      }
      u\EXPECT(@$try < 20, "failed to save user record after $try tries.");
      $region = r\region(@my_state, @my_postalCode);
    } else {
      r\dbInsert('users', $info); // predestined uid (probably for testing)
      $region = communityUid();
    }

    if (isset($my_number)) {
      $success = SMS\create($my_number, $uid);
      u\EXPECT($success, 'Unable to create SMS record.');
    }

//      $info['roles'] = 0; // these keep Drupal happy in user.module

    list($this->id, $this->agentId, $this->regionId, $this->agentRegion) = array($uid, $uid, $region, $region);
    self::$records[$this->id] = (object) $info;
    
    $card_code = u\randomString(R_CARDCODE_LEN); // create an rCard security code
    $secure = compact('card_code');
    $this->update(compact('secure')); // this is easier to do after saving the record
    unset($DBTX); // commit
  }

  /**
   * Setup acct variables, returning FALSE on error.
   */
  public static function ok($id0, $agent0='', &$error='', $test = TRUE) {
    if ($error = u\EXPECT(compact(u\ray('id0 agent0')), 'zid|qid|assoc empty|id|qid', $test)) return FALSE;
    if ($error = u\EXPECT((bool) $id0, 'null uid in new acct()', $test)) return FALSE;
    if ($error = u\EXPECT(!(strpos($id0, ':') and $agent0), 'agent already specified in qid', $test)) return FALSE;
    list ($id, $agent, $region) = u\isZid($id0) ? array($id0, $agent0 ?: $id0, serverUid()) : UAR($id0); // handle

    if (u\isQid($agent0)) {
      list ($agent, $zot, $agentRegion) = UAR($agent0);
      if ($error = u\EXPECT($agent == $zot, 'agent agent not allowed', $test)) return FALSE;
    } else $agentRegion = serverUid();

    $record = self::getRecord($id, $region);
    if ($error = u\EXPECT((bool) $record, 'That account does not exist.', $test)) return FALSE; // don't use tt() here (many calls)
    u\EXPECT($id and $agent and $region and $agentRegion, "Missing acct property: [$id, $agent, $region, $agentRegion]");
    return array($id, $agent, $region, $agentRegion);
  }
  
  private static function getRecord($id, $region, $reread = FALSE) {
    if (@self::$records[$id] and !property_exists(self::$records[$id], 'flags')) die("No flags field in record $id: " . print_r(self::$records, 1)); // keep this
    if (@self::$records[$id] and !$reread) return self::$records[$id];
    if ($region != serverUid()) { // foreign
      // contact other server here, for a subset of the record
    } else {
      if ($records = be\getRecords('users', "uid=:id LIMIT 1", compact('id'))) { // domestic (don't use Drupal's caching)
        $access = REQUEST_TIME;
        return self::$records[$id] = (object) (((array) $records[0]) + compact('access'));
      } else return FALSE;
    }
  }

  public function reread() {self::getRecord($this->id, $this->regionId, TRUE);}
  
  /**
   * Return the value of the specified field that is not a simple property of the acct class.
   * This function reads the account record from the database if it hasn't been read yet.
   * Special fields:
   *   agent: returns an account object for agentId
   *   language: returns what Drupal would
   */
  public function __get($field) {
    if (!@self::$records[$this->id]) $this->reread(); // necessary when we pass an acct object to another page
//    u\EXPECT(property_exists(self::$records[$this->id], $field), "bad field for uid $this->id: $field" . print_r(self::$records[$this->id], 1));
    if ($field == 'agent') return acct($this->agentId);
    if (in_array($field, u\ray(R_SECRET_FIELDS))) $this->getHidden();
    $result = @self::$records[$this->id]->$field; // returns NULL if field not set

    if ($field == 'data' or $field == 'frozen') {
      return @$result ? unserialize($result) : array();
    } elseif (in_array($field, u\ray(R_COMPANY_FIELDS))) {
      $id = $this->id;
      return @$result ?: (@self::$records[$this->id]->$field = r\dbLookup($field, 'r_companies', 'id=:id', compact('id')));
    } elseif ($field == 'secure') {
      return @$result ? unserialize(u\ezdecrypt($result, R_WORD)) : NULL;
    } elseif ($field == 'usdAccount') {
      return @$result ? u\ezdecrypt(hex2bin($result), R_WORD) : NULL;
    } elseif ($field == 'language') {
      $language = $result;
      return \user_preferred_language((object) compact('language'));
    } else return $result;
  }
  
  /**
   * Return the entire account object or just certain fields.
   * @param string $just: space-delimited list of fields to return
   * @param bool getHidden: whether we need to return the actual values of personal identifying information fields
   *   NOTE: getHidden is ignored if $just is specified
   */
  public function account($just = '', $getHidden = FALSE) {
    if (!@self::$records[$this->id]) $this->reread(); // make sure we have read the record from the db
    if (($getHidden or $just) and !$this->gotOffsite()) {
      if ($just) $getHidden = (count(array_intersect(u\ray($just), u\ray(R_SECRET_FIELDS))) > 0);
      if ($getHidden) $this->getHidden();
    }
    $account = @self::$records[$this->id];
    return $just ? (object) u\just($just, $account) : $account;
  }

  private function gotOffsite($set = FALSE) {
    if ($set) {
      self::$records[$this->id]->gotOffsite = TRUE; // applies to all objects for the id
    } else return @self::$records[$this->id]->gotOffsite;
  }
  
  /**
   * Read protected personal identifying information fields into the account record
   */
  private function getHidden() {
    if (!$this->offsite or $this->gotOffsite()) return; // no offsite data or already got it
    $data = (array) offsiteData($this->offsite); // get protected data from offsite
    foreach ($data as $key => $value) self::$records[$this->id]->$key = $value;
    $this->gotOffsite(TRUE);
  }
  
  public static function _clear() {self::$perms = self::$records = array();}
  
  /**
   * Return the next available uid in the specified region.
   */
  public static function nextId($region = '') {
    return r\newUid(R_REGION_MAX * -($region ?: r\serverUid()));
//    return max(t\EST() ? 1000 : -9999999, dbLookup('MAX(uid)', 'users', 1)) + 1;
  }
  
  /**
   * Update the saved record in the database with the given data.
   * @param assoc $info: data to update
   * @param string $just: update only these fields (update all if NULL, none if '')
   *   The flags field will always be included.
   * @return: FALSE if update fails (saving either onsite or offsite)
   */
  public function update($info, $just = NULL) {
    //if (!@self::$records[$this->id]->uid) self::$records[$this->id] = \user_load($this->id);
    if (isset($just)) $info = u\just($just, $info);
    if (isset($info['data'])) $info['data'] = serialize($this->data);
    if (isset($info['frozen'])) $info['frozen'] = serialize($info['frozen']);
    if (isset($info['secure'])) { // serialize and encrypt before updating this
      $usdArray = $info['secure'] + ($this->secure ?: array());
      $info['secure'] = u\ezencrypt(serialize($usdArray), R_WORD);
    }
    if (@$info['usdAccount']) $info['usdAccount'] = bin2hex(u\ezencrypt($info['usdAccount'], R_WORD));

    $toHide = count(array_intersect(array_keys($info), u\ray(R_SECRET_FIELDS))); // how many fields to hide
    if ($toHide and !$this->gotOffsite()) $this->getHidden(); // get what's offsite before updating it
    foreach ($info as $field => $value) { // update account object with new info
      if ($field != 'uid') self::$records[$this->id]->$field = $value;
    }
    if ($toHide) { // store protected information securely, offsite
      foreach (u\ray(R_SECRET_FIELDS) as $field) unset($info[$field]); // don't pass these to dbUpdate
      $key = offsiteData(@$this->offsite, $this->account(R_SECRET_FIELDS));
      if ($key and is_numeric($key)) $info['offsite'] = $key; else return FALSE; // if attempt to store fails, save nothing
    }
    if (count($companyInfo = u\just(R_COMPANY_FIELDS, $info))) {
      $companyInfo['id'] = $this->id;
      r\dbUpdate('r_companies', $companyInfo, 'id', TRUE);
    }
    u\setDft($info['flags'], $this->flags);
    $info['uid'] = $this->id; // make sure dbUpdate gets this
    return dbUpdate('users', $info, 'uid');
  }

  public function proSe() {return ($this->id == $this->agentId);}  
  public function qid() {return $this->proSe() ? $this->mainQid : quid($this->id, $this->agentId, $this->regionId);}
  public function hasBit($bit) {return (bool) ($this->flags & u\bit($bit));}
  
  /**
   * Set the bit in the flags field to the given value.
   * @param int $bit: number of bit to set (0 - 31)
   * @param bool $on: whether to set it ON or OFF
   * @param boot $now: whether to write to the database (DEFAULT FALSE) or just to the cache (awaiting write)
   */
  public function setBit($bit, $on = TRUE, $now = FALSE) {
// gets caught anyway    u\EXPECT(compact('int', 'on'), 'int bool');
    u\EXPECT($bit < 32, 'setting too big a bit');
    $bit = u\bit($bit);
    $flags = $on ? ($this->flags | $bit) : ($this->flags & ~$bit);
    self::$perms[$this->id] = NULL; // force redo in can()
    self::$records[$this->id]->flags = $flags;
    return $now ? $this->update(compact('flags')) : TRUE;
  }
  
  public static function setDefault($acct) {
    global $currentAcct; 
    global $user; if (empty($user)) $user = (object) ($acct ? $acct->account() : array('uid' => 0)); // probably needed only for rWeb login/registration form testing
    if (!$currentAcct = $acct) return;
    if (($login = REQUEST_TIME) != $acct->login) $acct->update(compact('login'));
  }

  function passwordOkay($password) {
    require_once DRUPAL_ROOT . '/' . variable_get('password_inc', 'includes/password.inc');
    $stored_hash = $this->pass;
    $hash = \_password_crypt('sha512', $password, $stored_hash);
    return ($hash and $stored_hash == $hash);
  }
  
  /**
   * Return the total (cached) balance.
   */
  function balance() {return $this->available + array_sum($this->frozen);}

  /**
   * Return an auxiliary filename for the account.
   * @param string $type: picture or proof
   */
  function auxFilename($type = 'picture') {
    return ($type == 'picture' ? R_PICTURE_DIR : R_PROOF_DIR) . "/$this->id-$this->created";
  }
  
  /**
   * Say whether this account/agent has the permission.
   * @param int $permission: the permission in question (DEFAULT B_READ)
   */
  public function can($permission = B_READ) {
//    if (0 <= $permission and $permission <= B_MAX) return $this->hasBit($permission);
    $id = $this->id;
    if (!@self::$perms[$id]) self::$perms[$id] = array();
    if (!@self::$perms[$id][$this->agentId]) { // set up perms if we haven't yet (setBit() resets this)
      $perms = array();
      $aacct = $this->agent;
      
      for ($bit = 0; $bit < B_MAX; $bit++) $perms[$bit] = $this->hasBit($bit);

      if (!$this->proSe()) { // admin permissions depend on agent, not account
        $perms[B_ADMIN] = $aacct->can(B_ADMIN);
        $perms[B_CTTY_ADMIN] = $aacct->can(B_CTTY_ADMIN);
      }

      $can = $this->proSe() ?
          (($id < 0) ? 0 : B_MANAGE) // communities must be managed by an agent, never directly
        : ($perms[B_CTTY_ADMIN] and $this->community == $aacct->community) ? 
              B_MANAGE : (B_RELATED + relation('permission', $id, $this->agentId));
      for ($i = B_RELATED; $i <= B_MANAGE; $i++) $perms[$i] = ($i <= $can); // set all permissions, even the false ones
      if (!$perms[B_OK]) $perms[B_READ] = $perms[B_SELL] = $perms[B_BUY] = FALSE; // no ASIFs!

      if ($perms[B_ADMIN]) {
        if (R_ADMIN_CAN_MANAGE_CTTYS) {
          $perms[B_CTTY_ADMIN] = TRUE; // temporary extra power, until communities are independent
          $perms[B_READ] = $perms[B_SELL] = $perms[B_BUY] = $perms[B_MANAGE] = TRUE;
        }
        $perms[B_PERSONAL] = TRUE; // manage show PERSONAL settings (for debugging)
        $perms[B_COMPANY] = $this->proSe(); // show company settings on own account (for debugging)
      };

      $perms[B_MANAGING_CTTY] = ($perms[B_CTTY_ADMIN] and $id == $this->community);
      if ($perms[B_MANAGING_CTTY] and !$perms[B_ADMIN]) $perms[B_BUY] = $perms[B_SELL] = FALSE; // ctty admin can manage but not buy/sell
      
      ksort($perms); // easier to debug
      self::$perms[$id][$this->agentId] = $perms;
    }
    if ($permission == -1) {
      $p = u\ray($GLOBALS['permissions']);
      for ($i = 0; $i < count($p); $i++) if ($p[$i] != '-') $result[$p[$i]] = @self::$perms[$id][$this->agentId][$i];
      return $result; // for debugging
    }
    return self::$perms[$id][$this->agentId][$permission];
  }
} // end of class

/**
 * Convert quid to UAR
 * @param quid $quid: the quid to convert (DEFAULT current acount and agent's quid)
 * @return the corresponding UAR = [uid, agent, region] (FALSE if wrong format)
 */

function UAR($quid = '', $no_abbrev = TRUE) {
  if (!$quid) return array(acct()->id, acct()->agentId, serverUid());
  if (!u\isQid($quid) and !$no_abbrev) $quid = R_SERVER_ID . $quid;
  if (!u\isQid($quid)) return FALSE;

  list ($zuid, $regionUid) = unQid($quid);
  if (($reid = -$zuid) > 0) {
    if (!$record = relation('main,other', 'reid=:reid', compact('reid'))) return FALSE;
    $result = array_values($record);
  } else {
    $zuid += -$regionUid * R_REGION_MAX;
    $result = array($zuid, $zuid);
  }
  $result[] = $regionUid;
  return $result;
}

/**
 * Store or retrieve the given offsite data.
 * @param string (bigint) $id: record key of offsite data to retrieve or update (if empty, store the data)
 * @param assoc $data: fields to store or update offsite (if NULL, retrieve the data)
 * @return: the actual data (if RETRIEVING) or record key (if STORING)
 */
function offsiteData($id, $data = NULL) {
//  debug(strlen(u\ezencrypt(serialize($orig = $data), R_WORD)));
  if (isset($data)) $data = bin2hex(u\ezencrypt(serialize($data), R_WORD));
//  debug(strlen($data));
//  debug($data);
//  debug(u\ezencrypt(serialize($orig), R_WORD) == hex2bin($data));
  $result = u\httpRequest(R_SECRET_URL . '/offsite.php', compact('id', 'data'));
  return isset($data) ? $result : unserialize(u\ezdecrypt(hex2bin($result), R_WORD));
}  

function acct($uid = '', $agent = '', &$error = '') {
  global $currentAcct; // use this ONLY in this class file
  if (!$uid) {
    if (!$currentAcct) {$error = 'There is no current account.'; return FALSE;}
    return $currentAcct;
  }
  if (!acct::ok($uid, $agent, $error, TRUE)) return FALSE;
  return new acct($uid, $agent);
}

function agent($uid = '') {return @acct($uid)->agent;}