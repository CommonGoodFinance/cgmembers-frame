<?php
namespace rCredits;
use rCredits as r;
use rCredits\DB as db;
use rCredits\Backend as be;
use rCredits\Util as u;
use rCredits\Testing as t;

/**
 * @file
 * rCredits Account class
 */

define('DW_NO', 0); // no Dwolla account yet
define('DW_YES', 1); // has a connected Dwolla account (required for all members)
define('DW_BANK', 2); // has a bank account, not yet verified
define('DW_VSAVINGS', 3); // verified savings/money market account
define('DW_VCHECKING', 4); // verified checking account (this or savings required for all human members)
 
class acct {
  var $id; // the account's record id
  var $agentId; // record id (in the agent's regional server) of whoever is acting on behalf of the account
  var $mainQid; // nearly alphabetic representation of id, id, and region for external queries
  private static $perms = array(); // permissions for all acct objects, indexed by id and agent
  private static $records = FALSE; // account records for all acct objects, indexed by id
  
  /**
   * Instantiate (create or retrieve) a member account for transactions and/or contact
   * Call by:
   *   new acct(info) OR
   *   acct(uid, agent) (see the acct() function below)
   * @param assoc $info: initial field values for the account, to be created and saved in the database, including at least one of the following:
   *   'uid' the record id
   *   'phone' is contact phone (in standard +ddddddddddd format) OR
   *   'number' is cell phone (in standard +ddddddddddd format -- use for phone also) OR
   *   'email' is email address
   *   UNUSED (because it's hard to verify): 'website' is website address
   *   (This function assumes that the info is not sufficient to identify an existing user)
   * @param id/qid $id: the account's record id (can this be a community?) (DEFAULT to myid)
   * @param id/qid $agent: the agent's record id on this server OR the foreign agent's qid (DEFAULT to same as $id)
   */
  function __construct($id = array(), $agent = '') {
    if (is_array($info = $id)) { // referring to existing db record
      $this->createNew($info); // create new db record
    } else list($this->id, $this->agentId) = acct::viable($id, $agent, $zot, FALSE);
    $this->mainQid = r\quid($this->id);
  }    

  /**
   * Create a new account record in the database.
   * @param assoc $info: array of field values for new account
   */
  private function createNew($info) {
    //$fields = 'phone number mail pass fullName legalName name flags rebate country state postalCode created login access uid community'; // used to include secure
    //if (u\test()) $fields .= ' usdAccount';
//    extract(u\just($fields, $info));
    extract($info);
    u\setDft($phone, @$number);
    if ($phone) $phone = u\fmtPhone($phone, '+n');
    
    $status = TRUE;
    u\EXPECT($mail, 'account with no email address');
    $init = $mail;
    $pass = (isset($pass) and trim($pass) !== '') ? r\passHash(trim($pass)) : ''; // no pass if none chosen yet
    u\setDft($fullName, @$legalName);
    $short_name = @$fullName ? u\shortName($fullName) : '';
    u\setDft($name, @$short_name ?: tempName($info));
    u\setDft($flags, 0);
    u\setDft($rebate, R_REBATE);
    if (@$state and !is_numeric(@$state)) { // allow state abbrevs within US
      $state = db\lookup('id', 'r_states', 'abbreviation=:state and country_id=:US_COUNTRY_ID', compact('state'));
    }
    u\setDft($community, communityUid(@$postalCode)); // defaults to current server
    u\setDft($created, REQUEST_TIME);
    u\setDft($login, $created);
    u\setDft($access, $login);
    u\setDft($data, array());
    u\setDft($secure, array());
    
    if ($secure += u\just(R_SECURE_FIELDS, $info)) foreach ($secure as $key => $value) unset($info[$key]);
    if ($data += u\just(R_DATA_FIELDS, $info)) foreach ($data as $key => $value) unset($info[$key]);
    $data['stepsDone'] = r\stepsDone0();
    if (@$signed) $signedBy = @$legalName;
    
    $record = compact(u\ray('phone status mail init pass name fullName state flags rebate community created login access signed signedBy'));
    foreach ($record as $key => $value) unset($info[$key]);
    foreach (u\ray('number secure data') as $one) unset($info[$one]); // special cases

    $DBTX = db_transaction();
    if (@$uid) {
      $record += compact('uid');
    } else $region = @$postalCode ? r\region(@$country, @$state, @$postalCode) : $community;
    $uid = r\regionalInsert('users', 'uid', $record, @$region);

    if (isset($number)) {
      $success = SMS\create($number, $uid);
      u\EXPECT($success, 'Unable to create SMS record.');
    }

    list($this->id, $this->agentId) = array($uid, $uid);
    self::$records[$this->id] = (object) ($record + $info + $data);
    if (!($flags & u\bit(B_CO))) u\setDft($secure['cardCode'], r\cardCode(r\quid($uid))); // must postcede $uid =

    $this->update(compact('secure', 'data') + $info); // this is easier to do after saving the record
    unset($DBTX); // commit
  }

  /**
   * Setup acct variables, returning FALSE on error.
   */
  public static function viable($id0, $agent0='', &$error='', $test = TRUE) {
    if (is_numeric($id0) and is_numeric($agent0)) return array($id0, $agent0);
    if ($error = u\EXPECT(compact(u\ray('id0 agent0')), 'zid|qid|assoc empty|id|qid', $test)) return FALSE;
    if ($error = u\EXPECT((bool) $id0, 'null uid in new acct()', $test)) return FALSE;
    if ($error = u\EXPECT(!(strpos($id0, R_AGENT_MARK) and $agent0), 'agent already specified in qid', $test)) return FALSE;
    list ($id, $agent) = u\isZid($id0) ? array($id0, $agent0 ?: $id0) : IA($id0); // handle
    if (u\isQid($agent0)) {
      list ($agent, $zot) = IA($agent0);
      if ($error = u\EXPECT($agent == $zot, 'agent agent not allowed', $test)) return FALSE;
    }

    $record = self::getRecord($id);
    if ($error = u\EXPECT((bool) $record, 'That account does not exist.', $test)) return FALSE; // don't use tt() here (many calls)
    u\EXPECT($id and $agent, "Missing acct property: [$id, $agent]");
    return array($id, $agent);
  }
  
  private static function getRecord($id, $reread = FALSE) {
/**/ if (@self::$records[$id] and !property_exists(self::$records[$id], 'flags')) die("No flags field in record $id: " . print_r(self::$records, 1)); // keep this
    if (@self::$records[$id] and !$reread) return self::$records[$id];
    if (!$records = db\records('users', "uid=:id LIMIT 1", compact('id'))) { // no such record here
      if (TRUE) return FALSE; // not foreign either
      // contact other server here, for a subset of the record
    }
    $data = @$records[0]->data; // treat data fields like any other
    $data = $data ? unserialize($data) : array();
    return self::$records[$id] = (object) (((array) $records[0]) + $data);
  }

  /**
   * Read in the account record, if we haven't yet.
   * This function should be called before any reference to self::$records[$this->id] (except in contructor).
   * @param bool $force: reread even if we already have an account record
   */
  public function reread($force = FALSE) {
    if (!@self::$records[$this->id] or $force) self::getRecord($this->id, TRUE);
  }
  
  /**
   * Return the value of the specified field that is not a simple property of the acct class.
   * This function reads the account record from the database if it hasn't been read yet.
   * Special fields:
   *   agent: returns an account object for agentId
   *   language: returns what Drupal would
   * @param string $field: name of field value to get
   * @return the value if it exists, else NULL
   */
  public function __get($field) {
    $this->reread(); // necessary when we pass an acct object to another page

    if (in_array($field, u\ray('ok member co admin cAdmin cAdmin2 cttyActive cttyUp'))) return $this->can(u\consta('b', $field)); 
    if ($field == 'agent') return acct($this->agentId);
    if ($field == 'proSe') return ($this->id == $this->agentId);
    if ($field == 'qid') return $this->proSe ? $this->mainQid : r\quid($this->id, $this->agentId);
    if ($field == 'ctty') return ($this->id < 0);
    if ($field == 'region') return r\uidRegion($this->id);
    if ($field == 'owns') return !$this->risk('rents');
    if ($field == 'bank') return $this->risk('hasBank');

    if (in_array($field, u\ray(R_SECRET_FIELDS))) $this->getHidden();
    $result = @self::$records[$this->id]->$field; // returns NULL if field not set

    if ($field == 'data' or $field == 'changes') return @$result ? unserialize($result) : [];
    if ($field == 'usdAccount') return @$result ? u\ezdecrypt(hex2bin($result), R_WORD) : NULL;
    if ($field == 'language') {
      $language = $result;
      return \user_preferred_language((object) compact('language'));
    }
    if ($field == 'secure') return @$result ? unserialize(u\ezdecrypt($result, R_WORD)) : array();
    if (in_array($field, u\ray(R_SECURE_FIELDS))) return @$this->secure[$field];

    return $result;
  }
  
  /**
   * Return the entire account object or just certain fields.
   * @param string $just: space-delimited list of fields to return
   * @param bool getHidden: whether we need to return the actual values of personal identifying information fields
   *   NOTE: getHidden is ignored if $just is specified
   */
  public function account($just = '', $getHidden = FALSE) {
    $this->reread(); // make sure we have read the record from the db
    if (($getHidden or $just) and !$this->gotOffsite()) {
      if ($just) $getHidden = (count(array_intersect(u\ray($just), u\ray(R_SECRET_FIELDS))) > 0);
      if ($getHidden) $this->getHidden();
    }
    $account = @self::$records[$this->id];
    return $just ? (object) u\just($just, $account) : $account;
  }

  private function gotOffsite($set = FALSE) {
    $this->reread();
    if ($set) {
      self::$records[$this->id]->gotOffsite = TRUE; // applies to all objects for the id
    } else return @self::$records[$this->id]->gotOffsite;
  }
 
  /**
   * Read protected personal identifying information fields into the account record
   */
  private function getHidden() {
    $this->reread();
    if (!$this->offsite or $this->gotOffsite()) return; // no offsite data or already got it
    $data = (array) offsiteData($this->offsite); // get protected data from offsite
    foreach ($data as $key => $value) self::$records[$this->id]->$key = $value;
    $this->gotOffsite(TRUE);
  }
  
  public static function _clear() {self::$perms = self::$records = array();}
  
  /**
   * Return the next available uid in the specified region.
   */
  public static function nextId($region = '') {
    u\EXPECT($region <= 0, 'non-negative region in nextId');
    return r\newUid(-($region ?: r\serverUid()));
  }
  
  /**
   * Update the saved record in the database with the given data.
   * Call by:
   *   update($info, $just); OR
   *   update($fields, $value1, ...)
   * @param assoc $info: data to update
   * @param string $just: update only these fields (update all if NULL, none if '')
   * @param string $fields: space-delimited list of field names
   * @param mixed $value1 (etc): new values for those fields
   *   The flags field will always be included.
   * @return: TRUE if update succeeds, FALSE if update fails (saving either onsite or offsite)
   * NOTE: data['changes'] = [date, oldvalues, agent] (this gives a complete history of the account record)
   *   but old secure and hidden data is replaced with ''
   */
  public function update($info, $just = NULL) {
    $this->reread();
    if (!is_array($info)) { // second syntax
      $args = func_get_args();
      $keys = u\ray(array_shift($args));
      u\EXPECT(count($keys) == count($args), 'assoc arg count mismatch');
      return $this->update(array_combine($keys, $args));
    }
    if (isset($just)) $info = u\just($just, $info);
    
    if (isset($info['secure'])) { // serialize and encrypt before updating this
      $usdArray = $info['secure']; // was " + ($this->secure ?: array())"
      $info['secure'] = u\ezencrypt(serialize($usdArray), R_WORD);
    } elseif ($secureFields = u\just(R_SECURE_FIELDS, $info)) {
      $info['secure'] = u\ezencrypt(serialize($secureFields + $this->secure), R_WORD);
      foreach ($secureFields as $k => $zot) unset($info[$k]);
    }
    if (@$info['usdAccount']) $info['usdAccount'] = bin2hex(u\ezencrypt($info['usdAccount'], R_WORD));
    if (isset($info['pass'])) $info['pass'] = r\passHash($info['pass']);

    $toHide = count(array_intersect(array_keys($info), u\ray(R_SECRET_FIELDS))); // how many fields to hide
    if ($toHide and !$this->gotOffsite()) $this->getHidden(); // get what's offsite before updating it
    if (!@self::$records[$this->id]) self::$records[$this->id] = new \stdClass();
    unset($info['uid']); // necessary?

//    if ($this->ok and time() - $this->activated > 30) { // don't record changes until member is a month old
    if ($this->ok) { // don't record changes until member is active
      $changes = u\justNot(R_HIDE_CHANGES, $info); // see if there are any changes to remember
      foreach ($changes as $k => $v) { // don't record if no change
        if ($v == $this->$k) {
          unset($changes[$k]);
        } elseif (isset(self::$records[$this->id]->$k)) $changes[$k] = @self::$records[$this->id]->$k;
      }
      if ($changes) {
        $changes = serialize([[time(), $changes]] + $this->changes);
        $info += compact('changes');
      }
    }
    
    if ($data = @$info['data']) {
      $info['data'] = serialize($data);
      u\preray($data, self::$records[$this->id]); // cache these individually
    } elseif ($data = u\just(R_DATA_FIELDS, $info)) $info['data'] = serialize($data += $this->data);

    u\preray($info, self::$records[$this->id]); // cache the field values

    if ($toHide) { // store protected information securely, offsite
      $key = offsiteData(@$this->offsite, $this->account(R_SECRET_FIELDS));
      if ($key and is_numeric($key)) $info['offsite'] = $key; else return FALSE; // if attempt to store fails, save nothing
    }
//NO    u\setDft($info['flags'], $this->flags); // accommodate setBit caching flags to be set/unset
    $info['uid'] = $this->id; // make sure dbUpdate gets this
    $info = u\justNot(R_SECRET_FIELDS . ' ' . R_DATA_FIELDS, $info); // don't pass these to dbUpdate

    return db\update('users', $info, 'uid');
  }

  public function upSecure($key, $value) {
    return $this->update(u\ray('secure', u\ray($key, $value) + ($this->secure ?: array())));
  }
  public function upData($key, $value) {
    return $this->update(u\ray('data', u\ray($key, $value) + $this->data));
  }
  public function usd($info = FALSE, &$err = '') {return new r\usd($this, $info, $err);}
  public function isNonprofit() {return (bool) ($this->coFlags & u\bit(CO_NONPROFIT));}
//  public function gotContact() {return ($this->can(B_PHONE_OK) and $this->address and $this->postalAddr and $this->city and $this->country and $this->postalCode and $this->can(B_SS_OK));}
  
  /**
   * Create a new relationship record.
   * @param int $other: account ID of the account to relate to this (all other params are optional)
   * @param int $reid: relationship record ID (for testing)
   * @return: the record ID of the new relationship record
   */
  function newRelation($other, $permission = 0, $employee = 0, $isOwner = 0, $draw = 0, $reid = NULL) {
    $info = compact('reid') + u\ray('main other permission employee isOwner draw',
      $this->id, $other, $permission, (int) $employee, (int) $isOwner, (int) $draw);
    return r\regionalInsert('r_relations', 'reid', $info, $this->region);
  }
  
  /**
   * Return specified account's profile picture, with markup
   * @param bool $unique: should the markup force reloading the image
   * @return: markup to display the account's picture (with a default image if none)
   * Use $result with DRUPAL_ROOT . $result OR $base_url . $result
   */
  public function picture($unique = FALSE) {
    global $base_url;
    if ($unique) $unique = '?' . REQUEST_TIME;
    $picFile = $this->auxFilename('picture');
    return '<div class="user-picture"><img src="' . "$base_url$picFile$unique" . '" alt="profile picture" /></div>';
  }

  /**
   * Return the account's name and qid, with a link to a fuller description.
   */
  public function linkedDesc() {
    global $base_url;
    $qid = "<a href=\"$base_url/sadmin/acct-info/$this->mainQid\">$this->mainQid</a>";
    return "$this->fullName ($qid)";
  }
  
  /**
   * Calculate updated r, rewards, and committed caches for a transaction (but do not write to db)
   * @param assoc $tx: the transaction record (or at least these fields: payer, payee, amount, type)
   * @param int $type: transaction type
   * @param stdObject $c: the cached fields:
   *   float $r: (UPDATED) the account's r balance
   *   float $rewards: (UPDATED) the account's rewards ever
   *   float $committed: (UPDATED) the account's reserve for sharing rewards with CGF
   */
  public function recache3($amount, $type, &$c) {
    $c->r = round($c->r + $amount, 2);
    if (r\isReward($type)) {
      if ($type == TX_REBATE or $type == TX_BONUS) $c->committed = round($c->committed + $amount * $this->share / 100, 2);
      $c->rewards = round($c->rewards + $amount, 2);
    }
  }

  /**
   * Set the bit in the flags field to the given value.
   * @param int $bit: number of bit to set (0 - 31)
   * @param bool $on: whether to set it ON or OFF
   * @return <successful>
   */
  public function setBit($bit, $on = TRUE) {
    $res = $this->setBitx($bit, $on, 'flags'); 
    if (@self::$perms[$id][$this->agentId]) {
      self::$perms[$id][$this->agentId][$bit] = $on;
    } // else can gets refreshed automatically next time can() is called
    return $res;
  }
  
  // public function refreshCan() {self::$perms[$this->id] = NULL;} // UNUSED force redo in can()

  /**
   * Set the current account being managed
   * @param acct $a: the account to manage
   * @return: the account (FALSE if $a is empty)
   */
  public static function setDefault($a) {
    global $currentAcct, $channel; 
    global $user; if (empty($user)) $user = (object) ($a ? $a->account() : array('uid' => 0)); // probably needed only for rWeb login form testing
    if ($a and @$currentAcct != $a and !$a->cAdmin) { // admin access doesn't count
      $access = REQUEST_TIME;
      if ($channel == TX_WEB) $login = $access;
      $a->update(compact('login', 'access'));
    }
    return $currentAcct = $a;
  }

  /**
   * Return the amount not available, including draws from related accounts, depending on the purpose.
   * If there are fees for drawing from a related account, they are added to the amount needed.
   * @param string $type: (does not default, to make sure we know what we're doing)
   *   buy: the amount of credit available for a purchase 
   *     (including credit lines and US Dollars in Dwolla)
   *   cash: the amount of credit available to trade for cash
   *     (not including credit lines and rewards)
   * @param float $need: the amount needed
   * @param bool $get: draw from other accounts as needed, then say whether there is enough
   * @param bool $retrying: UNUSED recursed after updating cache usd amount
   * @return how much short of what's needed is this account
   */
  public function shortfall($type, $need = 0, $get = FALSE) {
    $avail = $this->avail($type);
///    debug(compact(u\ray('type need get avail')));
    if ($avail >= $need) return 0; // plenty without drawing from other accounts

    $avail += $get ? $this->draw($need - $avail) : $this->canDraw(); // get or just asking
    $shortfall = max(0, $need - $avail);
/*
    if ($shortfall = max(0, $need - $avail) and !$get and !$retrying) {
      $lastWeek = strtotime('-10 days'); // EFTs never take this long
      $where = "payer=:id AND payee=0 AND amount<0 AND completed=0 AND created>$lastWeek"; // recent USD coming in
      if ($txid = db\lookup('txid', 'r_usd', $where, u\ray('id', $this->id))) { // found USD coming in
        if ($tx = (new r\usd($this))->tx($txid)) {
          if (r\usdTransferDone($tx)) return $this->shortfall($type, $need, $get, TRUE);
        }
      }
    }
    */
    return $shortfall; 
  }
  
  /**
   * Return how much is available in this account for the given operation, without drawing on other accounts.
   * @param string $type: purpose of the potential expenditure: buy or cash -- see acct::shortfall())
   */
  public function avail($type) {
    $floor = $this->floor;
    if (!$this->can(B_DEBT)) $floor = max($floor, 0); // no going into debt without permission
    if ($type == 'cash') $floor = max($floor, $this->rewards); // no exchanging rewards for cash
    return $this->r - $this->committed - $floor;
  }
  
  /**
   * Return the amount this account can draw from other accounts.
   * Repairs the B_DRAWS bit if all such relations have ended.
   */
  private function canDraw() {
    if (!$this->can(B_DRAWS)) return FALSE;
    
    $id = $this->id;
    $availBuy = R_AVAIL_BUY; // contains a constant, so can't use :R_AVAIL_BUY
    $sql = <<<EOF
      SELECT SUM($availBuy) AS avail, COUNT(*) as count
      FROM users u INNER JOIN r_relations r ON r.main=u.uid
      WHERE r.other=:id AND r.draw
EOF;
    if (!$row = db\q($sql, compact('id'))->fetchAssoc()) return 0;
    if (!$row['count']) $this->setBit(B_DRAWS, FALSE); // doesn't really have any drawable accounts
    return $row['avail'];
  }
  
  /**
   * Draw the needed amount from other accounts.
   * @param float $need: the amount needed
   * @return float: the amount drawn
   */
  public function draw($need) {
    if (!$this->can(B_DRAWS)) return 0;
    list ($from, $to, $auto) = array(t(' from '), t(' to '), t('automatic transfer'));
    $left = $need; // how much left to be drawn
    $id = $this->id;
    $availBuy = R_AVAIL_BUY; // contains a constant, so can't use :R_AVAIL_BUY
    $sql = <<<EOF
      SELECT u.uid,$availBuy AS avail FROM users u INNER JOIN r_relations r ON r.main=u.uid
      WHERE r.other=:id AND r.draw
EOF;
///debug(compact(u\ray('type need from to auto left id fields sql')));
    $result = db\q($sql, compact('id'));
    while ($row = $result->fetchAssoc()) {
      extract($row);
      $amount = round(min($left, $avail), 2);
///      debug(compact('row','avail','amount','left','need','id'));
      if ($amount > 0) {
        list ($fromQuid, $toQuid) = array(r\quid($uid), $this->mainQid);
        list ($payer, $payee) = array($uid, $this->id);
        $for = array($auto . $to . $toQuid, $auto . $from . $fromQuid);
        if (new r\x(compact(u\ray('amount payer payee goods for')))) $left -= $amount;
        if ($left <= 0) break;
      }
      
    }
    return round($need - $left, 2);
  }

  /**
   * Check the account's actual balance(s).
   * @return TRUE if the cached amounts are correct.
   * Otherwise deactivate the account, tell the staff, and return FALSE.
   */
  public function cacheOk() {
    $uid = $this->id;
    $info = be\creditInfo(compact('uid'));
    foreach (u\ray('r usd rewards minimum') as $key) {
      $is = $this->$key;
      if ($uid < 0) continue; // for communities and regions, only usd is cached
//      if ($uid < 0 and $key != 'usd') continue; // for communities and regions, only usd is cached
/*      $shouldBe = $key == 'usd' ? $this->actualUsd()
        : ($key == 'minimum' ? max(0, $this->floor, $this->minimum) 
        : $info->$key); */
      $shouldBe = $key == 'minimum' ? max(0, $this->floor, $this->minimum) : $info->$key;
      $shouldBe = round($shouldBe, 2);
      if ($is != $shouldBe) {
        r\tellStaff('cache mismatch', compact(u\ray('key is shouldBe')), $uid);
        $this->update(u\ray($key, $shouldBe));
        $suspend = (abs($is - $shouldBe) >= 1.00); // suspend on hacking
      }
    }
    if (@$suspend) {
// (disable temporarily)      $this->suspend('to protect data integrity.');
      return FALSE;
    } else return TRUE;
  }

  /**
   * De-activate the account for reasons of security or data integrity.
   * @param string $why: the reason for suspending (to tell member and staff)
   */
  public function suspend($why = '') {
    $this->setBit(B_OK, FALSE); // suspend the account
    if ($why) {
      r\message($this->id, 'account suspended', compact('why'));
      $notes = u\fmtDate() . ': ' . t('account suspended') . " $why\n" . @$this->notes;
      $this->update(compact('notes'));
      r\tellStaff('account suspended', u\ray('uid fullName why', $this->id, $this->fullName, $why));
    }      
  }
  
  /**
   * Return an auxiliary filename for the account.
   * @param string $type: picture, picture2, or proof
   * @param bool $ideal: return the ideal normal name, even if the file does not exist (default FALSE)
   * @param bool $old: use the old filename structure and location
   * @return: the relative file path (relative to Drupal)
   */
  public function auxFilename($type = 'picture', $ideal = FALSE, $old = FALSE) {
    $dir = $type == 'picture' ? R_PICTURE_DIR : ($type == 'picture2' ? R_PICTURE_DIR . '/small' : R_PROOF_DIR);
    $cardCode = @$this->secure['cardCode']; // @ for testing
    $file = "$this->id-$cardCode";
    if (u\abbreviates('picture', $type)) $file .= '.jpg';
    if (!$ideal and !$this->hasAux($type)) $file = $this->co ? R_DFT_PICTURE_WIDE : R_DFT_PICTURE;
    return "$dir/$file";
  }
  
  public function hasAux($type = 'picture') {return file_exists(DRUPAL_ROOT . $this->auxFilename($type, TRUE));}
  
  public function cardCode() {return $this->agent->secure[$this->proSe ? 'cardCode' : 'cardCode2'];}
  
  /**
   * Return TRUE if a connected funding source is verified.
   */ /* UNUSED (but maybe useful?)
  public function verified() {
    $usA = new r\usd($this);
    $source = $usA->source($err);
    return @$source['Verified'];
  }*/
  
  /**
   * Update the account's caches to reflect a trade of r for usd
   * @param float $change: how much rCredits got traded for usd (could be negative)
   */
  public function cacheR2Usd($change) {
    return $this->update('r usd', $this->r - $change, $this->usd + $change);
  }
  
  /**
   * Update the account's cached USD amount and return it.
   * @param float $change: if non-zero, update the USD cache by this much, without checking Dwolla or r_usd
   *//*
  public function actualUsd($change = 0) {
    $dw = $this->can(B_DW);
    if ($change) {
      u\EXPECT($dw, 'no dw');
      $usd = $this->usd + $change; // manual update
    } else {
      if (!$dw) return 0;
      $usAcct = new usd($this);
      $usd = $usAcct->bal($err); // $err is inaccessibility (usd=0)
      if ($err) return $this->usd; // can't get the figure from Dwolla

      if (u\test()) { // only these tests adjust according to Dwolla
        global $sceneTest; $scene = (object) $sceneTest->getInfo();
        if (!in_array($scene->short_name, u\ray('Recache RealUsd IncompleteUsdTxs'))) return $this->usd;
      }
    }
    if ($usd != $this->usd) $this->update(compact('usd')); // somehow balance got off
    return $usd;
  }
*/

  /**
   * Return the amount waiting to be transferred to or (if negative) from the bank.
   * @param bool $justTo: 'to': ignore transfers from bank, 'from': ignore transfers to bank
   */
  public function waitingToBank($justTo = FALSE) {
    $where = 'payer=:id AND payee=0 AND (NOT completed OR NOT deposit) AND created>:ancient';
    if ($justTo == 'to') $where .= ' AND amount>0';
    if ($justTo == 'from') $where .= ' AND amount<0';
    list ($id, $ancient) = array($this->id, REQUEST_TIME - R_ANCIENT_EFT * DAY_SECS);
    return db\lookup('SUM(amount)', 'r_usd', $where, compact('id', 'ancient')) + 0;
  }

  /**
   * Add a date stamp and agent's initials to the given note (before updating the notes field with it).
   */
  public function stampNotes(&$notes) {
    $rep = strtolower(u\initials(r\agent()->legalName) ?: 'WS');
    $date = str_replace('-', '', u\fmtDate(REQUEST_TIME));
    if ($notes != '' and $notes != $this->notes and substr($notes, 5, 2) != substr($date, 5, 2)) $notes = "$date  $rep: $notes"; // check century (will fail gently in 2100)
  }

  /**
   * Mark a membership step as completed.
   * @param string $step: a named step (see R_STEPS)
   * @param assoc $details: any details to report to the staff
   * @return the next step (FALSE if none)
   */
  function stepDone($step, $details = array()) {
    $stepsDone = $this->stepsDone ?: r\stepsDone0();
    if (!$stepsDone[$step]) { // unless already done
      $stepsDone[$step] = TRUE;
      $this->update(compact('stepsDone'));
      r\tellStaff('Step completed: ' . strtoupper($step), $details, $this->id);

//      if (!$this->member and $step == 'dw' and $stepsDone['connect']) r\Web\connectBank($this);
    }
    
    if (!$nextStep = $this->nextStep()) r\membershipEvent($this, 'member');
    return $nextStep;
  }
  
  /**
   * Return the next step to do.
   */
  function nextStep() {
    $steps = $this->stepsDone ?: r\stepsDone0(); // don't change the real data
    $unset = $this->co ? 'proxies connect' : 'company relations';
    foreach (u\ray($unset) as $one) unset($steps[$one]);
    foreach ($steps as $step => $done) if (!$done) break;
    if ($done) return FALSE;
/*
    if ($step == 'dw') {
      if ($this->can(B_DW) and !@$this->secure['auth']) {
        $this->createUsdAccount($err); // initialize Dwolla account
        if ($err) r\tellStaff($err, compact('step', 'details'), $this->id);
      }
      if ((new r\usd($this))->step() == 'Finished') $step = $this->stepDone('dw'); // happens externally
    }
*/
    return $step;
  }

  /**
   * Return the Community Admin's account ID.
   */
  function cAdminUid() {
    return db\lookup('uid', 'users', 'community=:ctty AND :IS_CADMIN', u\ray('ctty', $this->community));
  }
  
  /**
   * Return the community admin's contact info.
   */
  function cAdminContact() {
    if (!$id = $this->cAdminUid()) return t('(no Community Admin)');
    $a = r\acct($id);
    return "$a->fullName - $a->mail";
  }
  
  /**
   * Return an assoc of individual account statistics.
   * @return [returnMo, return, cttyBeneMo, cttyBene]
   */
  public function stats() {
    if ($this->stats) extract(unserialize($this->stats));
    $years = round((strtotime('today') - strtotime('today', $this->created)) / DAY_SECS) * DAY_SECS / YEAR_SECS;
    // rounding is to assure consistency for tests, despite daylight savings time changes
    $returnMo = @$avgBalPastMo > 0 ? 
        number_format(100 * 12 * (@$benePastMo + @$extraPastMo) / $avgBalPastMo, 1)
      : (@$benePastMo + @$extraPastMo > 0 ? '&infin;' : number_format(100 * R_INFLATION_RATE, 1));
    $return = ($years > 0 and @$avgBalEver > 0) ? 
        number_format(100 * (@$beneEver + @$extraEver) / $avgBalEver / $years, 1)
      : (@$beneEver + @$extraEver > 0 ? '&infin;' : number_format(100 * R_INFLATION_RATE, 1));
    $cttyBeneMo = u\fmtAmt(@$giftsPastMo + max(0, @$bankedPastMo) + @$benePastMo * (1 + R_CC_RATE / $this->rebate));
    $cttyBene = u\fmtAmt(@$giftsEver + max(0, @$bankedEver) + @$beneEver * (1 + R_CC_RATE / R_REBATE) + r\cttyPaidEver($this->community) / (@$pAccts ?: 1));
    return compact(u\ray('returnMo return cttyBeneMo cttyBene'));
  }

  /**
   * Return the rough business structure of a company, as required by Dwolla.
   */
  function businessStructure() {
    u\EXPECT($this->co, 'not a company');
    return $this->coCan(CO_CORPORATION) ? 'Corporation' : ($this->coCan(CO_PARTNERSHIP) ? 'Partnership' : 'SoleProprietorship');
  }
   
  /**
   * Create Dwolla account.
   * @param string $err (returned): the error message, if any
   * @return TRUE if success
   */
  function createUsdAccount(&$err = '') {
    if ($this->id == 1) return ($err = 'not registering admin');
    $usdPass = u\code() . '*B2'; // satisfy Dwolla (and our own security)
    $usdEmail = strtolower(u\code(4) . '.' . $this->mainQid) . '@rc4.me';
    //if (u\test()) $usdEmail = 'wspademan+' . strtolower(\user_password(4) . '.' . $this->mainQid) . '@gmail.com';
    $usdPin = u\randomString(4, 'digits');
    if (isDEV) list ($usdPass, $usdPin) = array('Password1', 9999);
    $usdPhone = $this->phone;
    $secure = compact(u\ray('usdPhone usdEmail usdPass usdPin')) + (@$this->secure ?: array());
    $this->update(compact('secure'));
    $us = new r\usd($this);
    if ($this->co) {
      $type = $this->isNonprofit() ? 'NonProfit' : 'Commercial';
      $structure = $this->businessStructure();
      return $us->register($type, u\ray('org ein structure', $this->legalName, u\fmtEin($this->federalId), $structure), 'true', $err);
    } else {
      if (!isPRODUCTION and !$this->dob) return TRUE; // don't annoy us with errors we don't care about
      list ($first, $last) = u\parseName($this->legalName);
      return $us->register('Personal', u\ray('first last dob', @$first, @$last, $this->dob), 'true', $err);
    }
  }
  
  /**
   * Return an SMS number for the account.
   * @return: the number or null if none
   */
  public function smsNumber() {  
    $id = $this->id;
    return db\lookup('code', 'r_boxes', "uid=:id AND code REGEX '+[:digit:]{7,15}'", compact('id')); // was status=:SMS_PRIMARY
  }

  /**
   * Return the account's Dwolla status (see definitions above)
   */
  public function dwStatus() {
    if (!@$this->usdAccount) return DW_NO;
    $usA = new r\usd($this);
    if (!$source = $usA->source($err)) return DW_YES; // Dwolla but no bank
    if (!@$source['Verified']) return DW_BANK;
    return @$source['Type'] == 'Checking' ? DW_VCHECKING : DW_VSAVINGS;
  }
  
  /**
   * Set or unset the BANK bit
   *//*
  public function setBank() {
    if (!$this->can(B_BANK) and $this->dwStatus() >= DW_VSAVINGS) $this->setBit(B_BANK, TRUE);
  }*/

  /**
   * Request a transfer of funds to or from a connected bank account.
   * @param numeric $amount: the amount to transfer TO or (if negative) FROM the bank
   * @param int $completed: (RETURNED) the completion date
   * @return the transaction number (FALSE if failure)
   */
  public function bank($amount, &$completed = '') {
    $payer = $this->id;
    $tid = r\getUsdTid($payer);
    $created = REQUEST_TIME;
    $completed = ($amount > 0 or -$amount <= -$this->floor) ? $created : 0;

    $DBTX = \db_transaction();
    $txid = db\insert('r_usd', $tx = compact(u\ray('amount payer created completed tid')));
    u\EXPECT((bool) $txid, 'saving usd record');

    if ($amount > 0) { // tell staff to transfer the funds using BillPay or check
      $this->update('r', $this->r - $amount);
      extract(u\just('bankAccount', $this->secure));
      list ($route, $account) = u\parseBankAccount(@$bankAccount);
      $bankName = db\lookup('name', 'r_banks', 'route=:route', compact('route'));
      $fullName = $this->fullName;
      r\tellStaff(t('outgoing bank transfer request'), compact('bankName route fullName account amount'));
    } elseif ($completed) $this->completeUsdTx(0, -$amount, $created);

    unset($DBTX);
    return $txid;
  }

  /**
   * Mark a USD transfer complete, update cache, and report.
   * @param int $txid: the transfer record ID (if NULL, no need to mark it complete)
   * @param numeric $amount: transfer amount (positive)
   * @param int $created: Unixtime record was created
   * @return <success>
   */
  public function completeUsdTx($txid, $amount, $created) {
    if (@$txid and !db\update('r_usd', ['txid'=>$txid, 'completed'=>time()], 'txid')) return FALSE;
    $this->update('r', $this->r + $amount);
    $hour = strftime('%H', strtotime($created)); // creation hour 
    $auto = $hour == R_DAILY_HOUR ? t(' automatic') : ''; // (space is intentional)
    $amount = u\fmtAmt(abs($amount));
    r\notify($this->id, 'transfer complete', compact('auto', 'amount'));
    r\membershipEvent($this, 'bona', TRUE);
    return TRUE;
  }
    
  /**
   * Set the bit in the given integer bit collection field to the given value.
   * @param int $bit: number of bit to set (0 - 31)
   * @param bool $on: whether to set it ON or OFF
   * @return <successful>
   */
  public function setBitx($bit, $on = TRUE, $field = 'flags') {
    $n = $this->$field;
    u\setBit($n, $bit, $on);
    return $this->update($field, $n);
  }

  /**
   * Set the bit (identified by number or name) in the "risks" integer bit collection field.
   * @param mixed $bit: number of bit to set (0 - 31) or name of bit
   * @param bool $on: whether to set it ON or OFF
   */
  public function setRisk($bit, $on = TRUE) {$this->setBitx($this::riskBit($bit), $on, 'risks');}
    
  public function risk($bit) {return u\getbit($this->risks, $this::riskBit($bit));}
  
  /**
   * Return the bit number for risk bit name.
   * @param mixed $bit: the bit name or number
   * @return the bit number
   */
  private static function riskBit($bit) {
    if (is_numeric($bitName = $bit)) return $bit;
    $acctRiskBits = array_flip(array_keys(u\ray(K_ACCT_RISKS)));
    $txRiskBits = array_flip(array_keys(u\ray(K_TX_RISKS)));
    return is_numeric($bit = @$acctRiskBits[$bitName]) ? $bit : $txRiskBits[$bitName];
  }

  public function coCan($bit = NULL) {return u\getbit($this->coFlags, $bit);}
  public function setCoBit($bit, $on = TRUE) {$this->setBitx($bit, $on, 'coFlags');}
  
  public function setCoCans($can) {
    $coFlags = $this->coFlags;
    for ($i = 0; $i < 2 * CO_CANS_BITS; $i++) {
      $bit = u\bit(CO_CANS + $i);
      $coFlags = isset($can[$i]) ? ($coFlags | $bit) : ($coFlags & ~$bit);
    }
    $this->update(compact('coFlags'));
  }

  /**
   * Set all account risk bits at once (called from formSummary for community admins)
   * @param array $values: numeric array of bit values (eg [3 => 3, 5 => 5])
   */
  public function setRisks($values) {
    $risks = 0;
    if ($values) foreach ($values as $bit) u\setBit($risks, $bit);
    $this->update(compact('risks'));
  }
  
  /**
   * Set all appropriate bits in the flags field (called from formSummary for community admins)
   * @param array $values: numeric array of bit values (eg [3 => 3, 5 => 5])
   */
  public function setBits($values) {
    u\setDft($values, array()); // fails in arg list (dunno why)
    $flags = $this->flags;
    foreach (u\ray(B_ADMINABLE) as $bitName) { // set all these on or off
//      if (substr($bitName, 0, 1) == 'u') continue; // lowercase u means undefined
      $bit = u\consta('b', $bitName);
      $on = isset($values[$bit]); // isset because bit 0 is 0 when checked
      u\setBit($flags, $bit, $on);
    }
    $this->update(compact('flags'));
  }  

  /**
   * Say whether this account/agent has the permission.
   * @param int $bit: the permission in question (DEFAULT B_READ)
   */
  public function can($bit = B_READ) {
    if ($bit <= B_MAX) { // ordinary bits
      $can = (bool) ($this->flags & (1 << $bit)); // these are easy. be efficient.
      if (in_array($bit, [B_REGULATOR, B_CADMIN2, B_CADMIN, B_ADMIN])) {
        if (!$this->proSe) { // admin permissions depend on agent
          return ($aa = $this->agent) ? $aa->can($bit) : FALSE; // timing errors in _construct can give no agent
        }
        if (!$can and $bit < R_ADMIN_CAN_MANAGE_CTTYS ? B_ADMIN : B_CADMIN) return $this->can($bit + 1); // not this admin bit, maybe the next higher?
      }
      return $can;
    }

    if ($bit == B_CTTYACTIVE or $bit == B_CTTYUP) {
      $a = $this->id < 0 ? r\acct($this->community) : $this;
      return $this->can($bit == B_CTTYACTIVE ? B_MEMBER : B_OK);
    }    

    if ($bit == B_BANK) return $this->risk(K_HASBANK); // might get set after getCan() is called
    $can = @self::$perms[$this->id][$this->agentId] ?: $this->getCan();
    return $can[$bit];
  }

  /**
   * Set up permissions (::$perms) if we haven't yet
   * @return the permissions array for this account
   */
  private function getCan() {
    $id = $this->id;
    
    // collect efficient bits, for reference within this function
    for ($bit = 0; $bit <= B_MAX; $bit++) $can[$bit] = $this->can($bit);
    foreach ([B_REGULATOR, B_CADMIN2, B_CADMIN, B_ADMIN] as $bit) $can[$bit] = $this->can($bit);
 
    $can[B_PERSON] = !$can[B_CO];

    $perm = $this->proSe ? ($id < 0 ? 0 : B_MANAGE) // communities must be managed by an agent, never directly
      : ($can[B_CADMIN] and $this->community == $this->agent->community) ? B_MANAGE 
      : (B_RELATED + relation('permission', $id, $this->agentId));
    for ($i = B_RELATED; $i <= B_MANAGE; $i++) $can[$i] = ($i <= $perm); // set all, even the false ones

    // (NO! this should never happen) if ($can[B_OK]) $can[B_MEMBER] = TRUE;
    if (!$can[B_OK]) $can[B_SELL] = $can[B_BUY] = FALSE; // (read here kills acct dropdown)

    if (!$can[B_MEMBER]) $can[B_BUY] = FALSE; // no spending even the SIGNUP GIFT for non-members
    
    if ($can[B_ADMIN] and R_ADMIN_CAN_MANAGE_CTTYS) { // temporary extra power, until communities are independent
      $can[B_READ] = $can[B_SCAN] = $can[B_SELL] = $can[B_BUY] = $can[B_MANAGE] = TRUE;
    }
    $can[B_DEV] = (isDEV or $can[B_ADMIN]); // used in menu system for tests page, etc.
    if ($can[B_MANAGING_CTTY] = ($can[B_CADMIN] and $id == $this->community)) $can[B_BUY] = TRUE;
    
    ksort($can); // easier to debug
    return self::$perms[$id][$this->agentId] = $can;
  }
  
} // end of class

/**
 * Convert quid to [id, agent]
 * @param quid $quid: the quid to convert (DEFAULT current acount and agent's quid)
 * @return the corresponding UAR = [uid, agent] (FALSE if wrong format)
 */

function IA($quid = '', $no_abbrev = TRUE) {
  if (!$quid) return array(acct()->id, acct()->agentId, serverUid());
  if (!u\isQid($quid) and !$no_abbrev) $quid = R_SERVER_ID . $quid;
  if (!u\isQid($quid)) return FALSE;

  list ($zid, $regionUid, $isRel) = r\unQid($quid); // unQid not unQuid
  if ($isRel) { // company agent
    $reid = -$regionUid + $zid;
    if (!$record = relation('main,other', 'reid=:reid', compact('reid'))) return FALSE;
    return array_values($record);
  } else {
    $zuid = r\unQuid('', $zid, $regionUid); // unQuid not unQid
    return array($zuid, $zuid); // pro Se
  }
}

/**
 * Store or retrieve the given offsite data.
 * @param string (bigint) $id: record key of offsite data to retrieve or update (if empty, store the data)
 * @param assoc $data: fields to store or update offsite (if NULL, retrieve the data)
 * @return: the actual data (if RETRIEVING) or record key (if STORING)
 */
function offsiteData($id, $data = NULL) {
/// debug(strlen(u\ezencrypt(serialize($orig = $data), R_WORD)));
  if (isset($data)) $data = bin2hex(u\ezencrypt(serialize($data), R_WORD));
/// debug(strlen($data));
/// debug($data);
/// debug(u\ezencrypt(serialize($orig), R_WORD) == hex2bin($data));
/// debug(R_SECRET_URL . '/offsite.php');
  $result = u\httpRequest(R_SECRET_URL . '/offsite.php', compact('id', 'data'));
/// debug($result);
  return isset($data) ? $result : unserialize(u\ezdecrypt(hex2bin($result), R_WORD)); // hex2bin = pack('H*'
}  

function acct($uid = '', $agent = '', &$error = '') {
  global $currentAcct; // use this ONLY in this class file
  if (!$uid) {
    if (!$currentAcct) {$error = 'There is no current account.'; return FALSE;}
    return $currentAcct;
  }
  if (strpos($uid, '@')) $uid = db\lookup('uid', 'users', 'mail=:uid', compact('uid'));
  if (!acct::viable($uid, $agent, $error, TRUE)) return FALSE;
  if (!acct::viable($uid, $agent, $error, TRUE)) return FALSE;
  return new acct($uid, $agent);
}

function agent($uid = '') {return @acct($uid)->agent;}
