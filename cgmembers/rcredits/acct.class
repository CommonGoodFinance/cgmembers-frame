<?php
namespace rCredits;
use rCredits as r;
use rCredits\DB as db;
use rCredits\Backend as be;
use rCredits\Util as u;
use rCredits\Testing as t;

/**
 * @file
 * rCredits Account class
 */

define('DW_NO', 0); // no Dwolla account yet
define('DW_YES', 1); // has a connected Dwolla account (required for all members)
define('DW_BANK', 2); // has a bank account, not yet verified
define('DW_VSAVINGS', 3); // verified savings/money market account
define('DW_VCHECKING', 4); // verified checking account (this or savings required for all human members)
 
class acct {
  var $id; // the account's record id
  var $agentId; // record id (in the agent's regional server) of whoever is acting on behalf of the account
  var $mainQid; // nearly alphabetic representation of id, id, and region for external queries
  private static $perms = array(); // permissions for all acct objects, indexed by id and agent
  private static $records = FALSE; // account records for all acct objects, indexed by id
  
  /**
   * Instantiate (create or retrieve) a member account for transactions and/or contact
   * Call by:
   *   new acct(info) OR
   *   acct(uid, agent) (see the acct() function below)
   * @param assoc $info: initial field values for the account, to be created and saved in the database, including at least one of the following:
   *   'uid' the record id
   *   'phone' is contact phone (in standard +ddddddddddd format) OR
   *   'number' is cell phone (in standard +ddddddddddd format -- use for phone also) OR
   *   'email' is email address
   *   UNUSED (because it's hard to verify): 'website' is website address
   *   (This function assumes that the info is not sufficient to identify an existing user)
   * @param id/qid $id: the account's record id (can this be a community?) (DEFAULT to myid)
   * @param id/qid $agent: the agent's record id on this server OR the foreign agent's qid (DEFAULT to same as $id)
   */
  function __construct($id = array(), $agent = '') {
    if (is_array($info = $id)) { // referring to existing db record
      $this->createNew($info); // create new db record
    } else list($this->id, $this->agentId) = acct::viable($id, $agent, $zot, FALSE);
    $this->mainQid = r\quid($this->id);
  }    

  /**
   * Create a new account record in the database.
   * @param assoc $info: array of field values for new account
   */
  private function createNew($info) {
    $fields = 'phone number mail pass secure fullName name flags rebate country state postalCode data created uid';
    extract(u\just($fields, $info));
    u\setDft($phone, @$number);
    if ($phone) $phone = u\fmtPhone($phone, '+n');
    
    $status = TRUE;
    $init = $mail = @$mail ?: '';
    $pass = r\passHash(trim(@$pass ?: \user_password()));
    $short_name = @$fullName ? u\shortName($fullName) : '';
    u\setDft($name, @$short_name ?: tempName($info));
    u\setDft($fullName, $info['name']);
    u\setDft($flags, B_DFT);
    u\setDft($rebate, R_REBATE);
    if (@$state and !is_numeric(@$state)) { // allow state abbrevs within US
      $state = db\lookup('id', 'r_states', 'abbreviation=:state and country_id=:US_COUNTRY_ID', compact('state'));
    }
    $community = communityUid(@$postalCode); // defaults to current server
    $data = serialize(@$data ?: array());
//    $frozen = serialize(array());
    $created = $login = $access = @$created ?: REQUEST_TIME;
    $companyInfo = u\just(R_COMPANY_FIELDS, $info);
    foreach ($companyInfo as $key => $value) unset($info[$key]);

    $record = compact(u\ray('phone status mail init pass name fullName state flags rebate community data created login access'));
    foreach ($record as $key => $value) unset($info[$key]);
    unset($info['secure']); // special case because of encryption (needed for testing)

    $DBTX = db_transaction();
    if (@$uid) {
      db\insert('users', $record += compact('uid')); // predestined uid (probably for testing)
      $region = communityUid();
    } else {
      $region = r\region(@$country, @$state, @$postalCode);
      for ($try = 0; $try < 20; $try++) { // limit the retries
        $uid = $record['uid'] = self::nextId($region);
        if (db\insert('users', $record)) break;
      }
      u\EXPECT(@$try < 20, "failed to save user record after $try tries.");
    }

    if (!empty($companyInfo)) {
      $companyInfo['uid'] = $uid;
      if ($flags & u\bit(B_COMPANY)) db\insert('r_companies', $companyInfo);
    }
    
    if (isset($number)) {
      $success = SMS\create($number, $uid);
      u\EXPECT($success, 'Unable to create SMS record.');
    }

    list($this->id, $this->agentId) = array($uid, $uid);
    self::$records[$this->id] = (object) ($record + $info);
    
    $cardCode = r\cardCode(r\quid($uid));
    u\setDft($secure, compact('cardCode'));
    $this->update(compact('secure') + $info); // this is easier to do after saving the record
    unset($DBTX); // commit
  }

  /**
   * Setup acct variables, returning FALSE on error.
   */
  public static function viable($id0, $agent0='', &$error='', $test = TRUE) {
    if ($error = u\EXPECT(compact(u\ray('id0 agent0')), 'zid|qid|assoc empty|id|qid', $test)) return FALSE;
    if ($error = u\EXPECT((bool) $id0, 'null uid in new acct()', $test)) return FALSE;
    if ($error = u\EXPECT(!(strpos($id0, R_AGENT_MARK) and $agent0), 'agent already specified in qid', $test)) return FALSE;
    list ($id, $agent) = u\isZid($id0) ? array($id0, $agent0 ?: $id0) : IA($id0); // handle
    if (u\isQid($agent0)) {
      list ($agent, $zot) = IA($agent0);
      if ($error = u\EXPECT($agent == $zot, 'agent agent not allowed', $test)) return FALSE;
    }

    $record = self::getRecord($id);
    if ($error = u\EXPECT((bool) $record, 'That account does not exist.', $test)) return FALSE; // don't use tt() here (many calls)
    u\EXPECT($id and $agent, "Missing acct property: [$id, $agent]");

    return array($id, $agent);
  }
  
  private static function getRecord($id, $reread = FALSE) {
    if (@self::$records[$id] and !property_exists(self::$records[$id], 'flags')) die("No flags field in record $id: " . print_r(self::$records, 1)); // keep this
    if (@self::$records[$id] and !$reread) return self::$records[$id];
    if (!$records = be\getRecords('users', "uid=:id LIMIT 1", compact('id'))) { // no such record here
      if (TRUE) return FALSE; // not foreign either
      // contact other server here, for a subset of the record
    }
    $access = REQUEST_TIME;
    return self::$records[$id] = (object) (((array) $records[0]) + compact('access'));
  }

  /**
   * Read in the account record, if we haven't yet.
   * This function should be called before any reference to self::$records[$this->id] (except in contructor).
   */
  public function reread() {if (!@self::$records[$this->id]) self::getRecord($this->id, TRUE);}
  
  /**
   * Return the value of the specified field that is not a simple property of the acct class.
   * This function reads the account record from the database if it hasn't been read yet.
   * Special fields:
   *   agent: returns an account object for agentId
   *   language: returns what Drupal would
   */
  public function __get($field) {
    $this->reread(); // necessary when we pass an acct object to another page
//    u\EXPECT(property_exists(self::$records[$this->id], $field), "bad field for uid $this->id: $field" . print_r(self::$records[$this->id], 1));
    if ($field == 'agent') return acct($this->agentId);
    if (in_array($field, u\ray(R_SECRET_FIELDS))) $this->getHidden();
    $result = @self::$records[$this->id]->$field; // returns NULL if field not set

    if ($field == 'data') {
      return @$result ? unserialize($result) : array();
    } elseif (in_array($field, u\ray(R_COMPANY_FIELDS))) {
      $id = $this->id;
      return @$result ?: (@self::$records[$this->id]->$field = db\lookup($field, 'r_companies', 'uid=:id', compact('id')));
    } elseif ($field == 'secure') {
      return @$result ? unserialize(u\ezdecrypt($result, R_WORD)) : NULL;
    } elseif ($field == 'usdAccount') {
      return @$result ? u\ezdecrypt(hex2bin($result), R_WORD) : NULL;
    } elseif ($field == 'language') {
      $language = $result;
      return \user_preferred_language((object) compact('language'));
    } else return $result;
  }
  
  /**
   * Return the entire account object or just certain fields.
   * @param string $just: space-delimited list of fields to return
   * @param bool getHidden: whether we need to return the actual values of personal identifying information fields
   *   NOTE: getHidden is ignored if $just is specified
   */
  public function account($just = '', $getHidden = FALSE) {
    $this->reread(); // make sure we have read the record from the db
    if (($getHidden or $just) and !$this->gotOffsite()) {
      if ($just) $getHidden = (count(array_intersect(u\ray($just), u\ray(R_SECRET_FIELDS))) > 0);
      if ($getHidden) $this->getHidden();
    }
    $account = @self::$records[$this->id];
    return $just ? (object) u\just($just, $account) : $account;
  }

  private function gotOffsite($set = FALSE) {
    $this->reread();
    if ($set) {
      self::$records[$this->id]->gotOffsite = TRUE; // applies to all objects for the id
    } else return @self::$records[$this->id]->gotOffsite;
  }
  
  /**
   * Read protected personal identifying information fields into the account record
   */
  private function getHidden() {
    $this->reread();
    if (!$this->offsite or $this->gotOffsite()) return; // no offsite data or already got it
    $data = (array) offsiteData($this->offsite); // get protected data from offsite
    foreach ($data as $key => $value) self::$records[$this->id]->$key = $value;
    $this->gotOffsite(TRUE);
  }
  
  public static function _clear() {self::$perms = self::$records = array();}
  
  /**
   * Return the next available uid in the specified region.
   */
  public static function nextId($region = '') {
    u\EXPECT($region <= 0, 'non-negative region in nextId');
    return r\newUid(R_REGION_MAX * (-($region ?: r\serverUid()) - 1) + 1);
  }
  
  /**
   * Update the saved record in the database with the given data.
   * @param assoc $info: data to update
   * @param string $just: update only these fields (update all if NULL, none if '')
   *   The flags field will always be included.
   * @return: TRUE if update succeeds, FALSE if update fails (saving either onsite or offsite)
   */
  public function update($info, $just = NULL) {
    $this->reread();
    if (isset($just)) $info = u\just($just, $info);
    if (isset($info['data'])) $info['data'] = serialize($info['data']);
    if (isset($info['secure'])) { // serialize and encrypt before updating this
      $usdArray = $info['secure'] + ($this->secure ?: array());
      $info['secure'] = u\ezencrypt(serialize($usdArray), R_WORD);
    }
    if (@$info['usdAccount']) $info['usdAccount'] = bin2hex(u\ezencrypt($info['usdAccount'], R_WORD));
    if (isset($info['pass'])) $info['pass'] = r\passHash($info['pass']);

    $toHide = count(array_intersect(array_keys($info), u\ray(R_SECRET_FIELDS))); // how many fields to hide
    if ($toHide and !$this->gotOffsite()) $this->getHidden(); // get what's offsite before updating it
    foreach ($info as $field => $value) { // update account object with new info
      if ($field != 'uid') self::$records[$this->id]->$field = $value;
    }
    if ($toHide) { // store protected information securely, offsite
      $key = offsiteData(@$this->offsite, $this->account(R_SECRET_FIELDS));
      if ($key and is_numeric($key)) $info['offsite'] = $key; else return FALSE; // if attempt to store fails, save nothing
    }
    if (count($companyInfo = u\just(R_COMPANY_FIELDS, $info))) {
      $companyInfo['uid'] = $this->id;
      db\update('r_companies', $companyInfo, 'uid', TRUE);
    }
    u\setDft($info['flags'], $this->flags); // accommodate setBit caching flags to be set/unset
    $info['uid'] = $this->id; // make sure dbUpdate gets this
    foreach (u\ray(R_SECRET_FIELDS . ' ' . R_COMPANY_FIELDS) as $field) unset($info[$field]); // don't pass these to dbUpdate
    return db\update('users', $info, 'uid');
  }

  public function usd($info = FALSE, &$err = '') {return new r\usd($this, $info, $err);}
  public function proSe() {return ($this->id == $this->agentId);}  
  public function qid() {return $this->proSe() ? $this->mainQid : r\quid($this->id, $this->agentId);}
  public function isNonprofit() {return (bool) ($this->coFlags & u\bit(CO_NONPROFIT));}
//  public function gotContact() {return ($this->can(B_PHONE_OK) and $this->address and $this->postalAddr and $this->city and $this->country and $this->postalCode and $this->can(B_SS_OK));}
  
  /**
   * Return specified account's profile picture, with markup
   * @param bool $unique: should the markup force reloading the image
   * @return: markup to display the account's picture (with a default image if none)
   * Use $result with DRUPAL_ROOT . $result OR $base_url . $result
   */
  function picture($unique = FALSE) {
    global $base_url;
    if ($unique) $unique = '?' . REQUEST_TIME;
    $picFile = $this->auxFilename('picture');
    return '<div class="user-picture"><img src="' . "$base_url$picFile$unique" . '" alt="profile picture" /></div>';
  }

  public function hasBit($bit) {return (bool) ($this->flags & u\bit($bit + 0));}
  
  /**
   * Set the bit in the flags field to the given value.
   * @param int $bit: number of bit to set (0 - 31)
   * @param bool $on: whether to set it ON or OFF
   * @param boot $now: whether to write to the database (DEFAULT TRUE) or just to the cache (awaiting write)
   */
  public function setBit($bit, $on = TRUE, $now = TRUE) {
    $this->reread();
// gets caught anyway    u\EXPECT(compact('int', 'on'), 'int bool');
    u\EXPECT($bit <= B_MAX, 'setting too big a bit');
    $bit = u\bit($bit0 = $bit);
    $flags = $on ? ($this->flags | $bit) : ($this->flags & ~$bit);
    self::$records[$this->id]->flags = $flags;
    $this->refreshCan();
    return $now ? $this->update(compact('flags')) : TRUE;
  }
  
  public function refreshCan() {
    self::$perms[$this->id] = NULL; // force redo in can()
  }

  /**
   * Set the current account being managed
   * @param acct $a: the account to manage
   * @return: the account (FALSE if $a is empty)
   */
  public static function setDefault($a) {
    global $currentAcct; 
    global $user; if (empty($user)) $user = (object) ($a ? $a->account() : array('uid' => 0)); // probably needed only for rWeb login form testing
    $login = REQUEST_TIME;
    if ($a and @$currentAcct != $a and $a->login != $login) $a->update(compact('login'));
    return $currentAcct = $a;
  }

  /**
   * Return the amount not available, including draws from related accounts, depending on the purpose.
   * If there are fees for drawing from a related account, they are added to the amount needed.
   * @param string $type: (does not default, to make sure we know what we're doing)
   *   buy: the amount of credit available for a purchase 
   *     (including credit lines and US Dollars in Dwolla)
   *   exch: the amount of rCredits available to trade for US Dollars
   *     (not including credit lines and rewards)
   *   cash: the amount of credit available to trade for cash
   *     (including US Dollars in Dwolla, not including credit lines and rewards)
   * @param float $need: the amount needed
   * @param bool $get: draw from other accounts as needed, then say whether there is enough
   * @return how much short of what's needed is this account
   */
  function shortfall($type, $need = 0, $get = FALSE) {
    $ray = (array) $this->account(R_MONEY_FIELDS);
    $ray['fees'] = 0;
    $avail = r\avail($type, $ray);
/// debug(compact('need','avail','get','ray'));
    if ($avail >= $need) return 0; // plenty without drawing from other accounts

    if ($get) { // get what we need (should have already checked to see if it's there)
      r\usd::beginAtom();
      $avail += $this->draw($type, $need - $avail, 'r'); // get as much in r as possible
      if ($avail < $need) $avail += $this->draw($type, $need - $avail, 'usd'); // the remainder in USD
      r\usd::commit($avail >= $need); // rollback if failure
    } else $avail += $this->canDraw($type); // just asking
/// debug(compact('need','avail','get'));
    return max(0, $need - $avail); // the shortfall
  }
  
  /**
   * Return how much is available in this account, without drawing on other accounts.
   * @param string $type: buy, exch, or cash
   * @param bool $usdToo: if TRUE, include any USD available
   */
  function rAvailable($type, $usdToo = FALSE) {return r\avail($type, (array) $this->account(R_MONEY_FIELDS), $usdToo);}
  function usdAvailable($type) {return $this->rAvailable($type, TRUE) - $this->rAvailable($type);}
  
  /**
   * Return the amount this account can draw from other accounts.
   * Repairs the B_DRAWS bit if all such relations have ended.
   * @param string $type: purpose of the draw (see $this->shortfall))
   */
  private function canDraw($type) {
    if (!$this->can(B_DRAWS)) return FALSE;
    
    $id = $this->id;
    $sums = u\sumAs(R_MONEY_FIELDS, 'u.');
    $sql = <<<EOF
      SELECT $sums, SUM(IF(u.usd>:DW_FEE_THRESHOLD, :DW_FEE, 0)) AS fees, COUNT(*) as count
      FROM users u INNER JOIN r_relations r ON r.main=u.uid
      WHERE r.other=:id AND r.draw
EOF;
    $row = db\q($sql, compact('id'))->fetchAssoc();
    if (!$row['count']) $this->setBit(B_DRAWS, FALSE); // doesn't really have any drawable accounts
    return r\avail($type, $row);
  }
  
  /**
   * Draw the needed amount from other accounts.
   * Expects to be called within a usd class atom
   * @param string $type: purpose of the draw (see acct::available())
   * @param float $need: the amount needed
   * @param string $currency: r or usd
   * @return float: the amount drawn
   */
  private function draw($type, $need, $currency) {
    u\EXPECT(r\usd::inAtom(), 'not in usd atom!');
    list ($from, $to, $auto) = array(t(' from '), t(' to '), t('automatic transfer'));
    $wantUsd = ($currency == 'usd');
    $left = $need; // how much left to be drawn
    $id = $this->id;
    $fields = join(',', u\ray(R_MONEY_FIELDS));
    $sql = <<<EOF
      SELECT u.uid, $fields FROM users u INNER JOIN r_relations r ON r.main=u.uid
      WHERE r.other=:id AND r.draw
EOF;
    $result = db\q($sql, compact('id'));
    while ($row = $result->fetchAssoc()) {
      extract($row);
      if ($wantUsd and $left > DW_FEE_THRESHOLD) {$left += DW_FEE; $need += DW_FEE;}
      $avail = r\avail($type, $row, $wantUsd);
      if ($amount = max(0, min($left, $avail))) {
        list ($fromQuid, $toQuid) = array(r\quid($uid), $this->mainQid);
        if ($wantUsd) {
          $r = 0;
          $fromUsA = new r\usd($fromA = r\acct($uid));
          $usTo = new r\usd($this);
          $note = $auto . $from . $fromQuid . $to . $toQuid;
          if (!$usdXid = $fromUsA->send($amount, $usTo, $note)) {
            $fromA->actualUsd(); // fix cached USD, if needed
            if ($left > DW_FEE_THRESHOLD) {$left -= DW_FEE; $need -= DW_FEE;} // undo bump
            continue;
          }
          if ($left > DW_FEE_THRESHOLD and $amount <= DW_FEE_THRESHOLD) {$left -= DW_FEE; $need -= DW_FEE;} // undo bump
        } else $r = $amount;
        list ($payer, $payee) = array($uid, $this->id);
        $for = array($auto . $to . $toQuid, $auto . $from . $fromQuid);
        r\transact(compact(u\ray('amount r payer payee for usdXid')));
        $left -= $amount;
        if ($left <= 0) break;
      }
      
    }
    return $need - $left;
  }

  /**
   * Return an auxiliary filename for the account.
   * @param string $type: picture or proof
   * @param bool $ideal: return the ideal normal name, even if the file does not exist (default FALSE)
   * @return: the relative file path (relative to Drupal)
   */
  public function auxFilename($type = 'picture', $ideal = FALSE) {
    $dir = $type == 'picture' ? R_PICTURE_DIR : R_PROOF_DIR;
    $result = "$dir/$this->id-$this->created";
    if (!$ideal and !$this->hasAux($type)) $result = $this->can(B_PERSON) ? R_DFT_PICTURE : R_DFT_PICTURE_WIDE;
    return $result;
  }
  
  public function hasAux($type = 'picture') {return file_exists(DRUPAL_ROOT . $this->auxFilename($type, TRUE));}
  
  /**
   * Return TRUE if a connected funding source is verified.
   */
  public function verified() {
    $usA = new r\usd($this);
    $source = $usA->source($err);
    return @$source['Verified'];
  }
    
  /**
   * Update the account's cached USD amount and return it.
   * @param float $change: if non-zero, update the USD cache by this much, without checking Dwolla or r_usd
   */
  public function actualUsd($change = 0) {
    if ($change) {
      $usd = $this->usd + $change; // manual update
    } else {
      $usAcct = new usd($this);
      $bal = $usAcct->bal($err);
      if ($err) return $this->usd; // can't get the figure from Dwolla
      
      $usd = max(0, $bal - $this->waitingToBank(TRUE)); // $err is inaccessibility (usd=0)

      if (t\est()) { // only these tests adjust according to Dwolla
        global $sceneTest; $scene = (object) $sceneTest->getInfo();
        if (!in_array($scene->short_name, u\ray('Recache RealUsd IncompleteUsdTxs'))) return $this->usd;
      }
    }
    if ($usd != $this->usd) $this->update(compact('usd')); // somehow balance got off
    return $usd;
  }

  /**
   * Return the amount waiting to be transferred to or (if negative) from the bank.
   * @param bool $justTo: ignore withdrawals from bank
   */
  public function waitingToBank($justTo = FALSE) {
    $where = 'payer=:id AND payee=0 AND NOT completed AND created>:ancient';
    if ($justTo) $where .= ' AND amount>0';
    list ($id, $ancient) = array($this->id, REQUEST_TIME - R_ANCIENT_EFT * DAY_SECS);
    return db\lookup('SUM(amount)', 'r_usd', $where, compact('id', 'ancient')) + 0;
  }

  /**
   * Say whether the account is nearly a member.
   * That is, have they satisfied all the basic membership requirements except possibly choosing proxies.
   * @param assoc $steps: (returned) the component steps: $signed and $donated
   * @return TRUE if the account is nearly a member
   */
  public function nearlyMember(&$steps = '') {
    $signed = (bool) $this->signed;
  //  $donated = ($this->share > 0 or r\share($this)); // r\share() also updates the database
    $donated = db\exists('r_gifts', 'uid=:myid', array('myid' => $this->id));
    $steps = compact(u\ray('signed donated'));
    return ($signed and $donated);
  }
  
  /**
   * Create Dwolla account.
   * @param string $err (returned): the error message, if any
   * @return TRUE if success
   */
  function createUsdAccount(&$err = '') {
    if ($this->id == 1) return ($err = 'not registering admin');
    $usdPass = user_password(20) . '*B2'; // satisfy Dwolla (and our own security)
    $usdEmail = strtolower(\user_password(4) . '.' . $this->mainQid) . '@rc4.me';
    $usdPin = u\randomString(4, 'digits');
    if (isDEV) list ($usdPass, $usdPin) = array('Password1', 9999);
    if (isDEV and (!$usdEmail or !strpos('@dwolla.com', $usdEmail))) $usdEmail = 'gordon+william+5@dwolla.com';
    $secure = compact(u\ray('usdPass usdEmail usdPin')) + $this->secure;
    $this->update(compact('secure'));
    $us = new r\usd($this);
    if ($this->can(B_PERSON)) {
      if (!isPRODUCTION and !$this->dob) return TRUE; // don't annoy us with errors we don't care about
      list ($first, $last) = u\parseName($this->fullName);
      return $us->register('Personal', u\ray('first last dob', @$first, @$last, $this->dob), 'true', $err);
    } else {
      $type = $this->isNonprofit() ? 'NonProfit' : 'Commercial';
      $structure = $this->coCan(CO_CORPORATION) ? 'Corporation' : ($this->coCan(CO_PARTNERSHIP) ? 'Partnership' : 'SoleProprietorship');
      return $us->register($type, u\ray('org ein structure', $this->fullName, u\fmtEin($this->federalId), $structure), 'true', $err);
    }
  }
  
  /**
   * Return an SMS number for the account.
   * @return: the number or null if none
   */
  public function smsNumber() {  
    $id = $this->id;
    return db\lookup('code', 'r_boxes', "uid=:id AND code REGEX '+[:digit:]{7,15}'", compact('id')); // was status=:SMS_PRIMARY
  }

  /**
   * Return the account's Dwolla status (see definitions above)
   */
  public function dwStatus() {
    if (!@$this->usdAccount) return DW_NO;
    $usA = new r\usd($this);
    if (!$source = $usA->source($err)) return DW_YES; // Dwolla but no bank
    if (!@$source['Verified']) return DW_BANK;
    return @$source['Type'] == 'Checking' ? DW_VCHECKING : DW_VSAVINGS;
  }
  
  /**
   * Set or unset the BANK bit
   */
  public function setBank() {
    if (!$this->can(B_BANK) and $this->dwStatus() >= DW_VSAVINGS) $this->setBit(B_BANK, TRUE, FALSE);
  }
  
  /**
   * Say whether this company account has the bit.
   * @param int $bit: the bit in question (return all, if omitted)
   * @return TRUE if the bit is there, else FALSE (or an integer bit collection if no param)
   */
  public function coCan($bit = NULL) {
    return is_null($bit) ? $this->coFlags : ($this->coFlags & u\bit($bit));
  }
  
  /**
   * Set the bit in the company field (coFlags) to the given value.
   * @param int $bit: number of bit to set (0 - 31)
   * @param bool $on: whether to set it ON or OFF
   * @param boot $now: whether to write to the database (DEFAULT TRUE) or just to the cache (awaiting write)
   */
  public function setCoBit($bit, $on = TRUE) {
    $bit = u\bit($bit0 = $bit);
    $coFlags = $on ? ($this->coFlags | $bit) : ($this->coFlags & ~$bit);
    $this->update(compact('coFlags'));
  }
  
  /**
   * Set all appropriate bits in the flags or coFlags field.
   * (called in form _submit functions)
   */
  public function setBits($bits, $values, $prefix) {
    foreach (u\ray($bits) as $bitName) {
      if (substr($bitName, 0, 1) == 'u') continue; // undefined
      $bit = u\consta($prefix, $bitName);
      $value = isset($values[$bit]); // isset because bit 0 is 0 when checked
      if ($prefix == 'co') $this->setCoBit($bit, $value); else $this->setBit($bit, $value, FALSE);
    }	  
  }  

  /**
   * Say whether this account/agent has the permission.
   * @param int $permission: the permission in question (DEFAULT B_READ)
   */
  public function can($permission = B_READ) {
    // For permissions based on flag bits that never get turned off in this function, be efficient:
    if (0 <= $permission and $permission <= B_CTTY_ADMIN and $this->hasBit($permission)) return TRUE;
    $id = $this->id;
    if (!@self::$perms[$id]) self::$perms[$id] = array();
    if (!@self::$perms[$id][$this->agentId]) { // set up perms if we haven't yet (setBit() resets this)
      $perms = array();
      $aacct = $this->agent;
      
      for ($bit = 0; $bit < B_MAX; $bit++) $perms[$bit] = $this->hasBit($bit);
      if (!$perms[B_COMPANY]) $perms[B_PERSON] = TRUE; // make sure it's always at least one of these
      
      if (!$this->proSe()) { // admin permissions depend on agent, not account
        $perms[B_ADMIN] = $aacct->can(B_ADMIN);
        $perms[B_CTTY_ADMIN] = $aacct->can(B_CTTY_ADMIN);
      }
      $perms[B_PERSONISH] = $perms[B_PERSON] or $perms[B_ADMIN];

      $can = $this->proSe() ?
          (($id < 0) ? 0 : B_MANAGE) // communities must be managed by an agent, never directly
        : ($perms[B_CTTY_ADMIN] and $this->community == $aacct->community) ? 
              B_MANAGE : (B_RELATED + relation('permission', $id, $this->agentId));
      for ($i = B_RELATED; $i <= B_MANAGE; $i++) $perms[$i] = ($i <= $can); // set all, even the false ones

      if ($perms[B_OK]) {
        $perms[B_MEMBER] = TRUE; // make sure nobody gets downgraded
      } else $perms[B_SELL] = $perms[B_BUY] = FALSE; // (read here kills acct dropdown)

      if (!$perms[B_MEMBER]) $perms[B_BUY] = FALSE; // no spending even the SIGNUP GIFT for non-members
      if (r\Web\svar('scanned_in') and $this == r\acct()) $perms[B_BUY] = $perms[B_MANAGE] = $perms[B_ADMIN] = $perms[B_CTTY_ADMIN] = FALSE; // scanning in, you can read and scan, at most
      
      if ($perms[B_ADMIN]) {
        if (R_ADMIN_CAN_MANAGE_CTTYS) {
          $perms[B_CTTY_ADMIN] = TRUE; // temporary extra power, until communities are independent
          $perms[B_READ] = $perms[B_SCAN] = $perms[B_SELL] = $perms[B_BUY] = $perms[B_MANAGE] = TRUE;
        }
//        $perms[B_PERSON] = TRUE; // manage show PERSONAL settings (for debugging)
        if ($this->proSe()) $perms[B_COMPANY] = TRUE; // show company settings on own account (for debugging)
      };
      $perms[B_DEV] = (isDEV or $perms[B_ADMIN]); // is this used?
      
      $perms[B_MANAGING_CTTY] = ($perms[B_CTTY_ADMIN] and $id == $this->community);
      if ($perms[B_MANAGING_CTTY] and !$perms[B_ADMIN]) $perms[B_BUY] = $perms[B_SELL] = FALSE; // ctty admin can manage but not buy/sell

      ksort($perms); // easier to debug
      self::$perms[$id][$this->agentId] = $perms;
    }
///  debug("id=$id agent=$this->agentId permissions=" . print_r(self::$perms[$id][$this->agentId], 1));
    return self::$perms[$id][$this->agentId][$permission];
  }
  
  public function co() {return $this->can(B_COMPANY);}
  public function person() {return $this->can(B_PERSON);}
  public function admin() {return $this->can(B_ADMIN);}
  public function ok() {return $this->can(B_OK);}
} // end of class

/**
 * Convert quid to [id, agent]
 * @param quid $quid: the quid to convert (DEFAULT current acount and agent's quid)
 * @return the corresponding UAR = [uid, agent] (FALSE if wrong format)
 */

function IA($quid = '', $no_abbrev = TRUE) {
  if (!$quid) return array(acct()->id, acct()->agentId, serverUid());
  if (!u\isQid($quid) and !$no_abbrev) $quid = R_SERVER_ID . $quid;
  if (!u\isQid($quid)) return FALSE;

  list ($zid, $regionUid) = r\unQid($quid); // unQid not unQuid
  if (($reid = -$zid) > 0) { // company agent
    if (!$record = relation('main,other', 'reid=:reid', compact('reid'))) return FALSE;
    return array_values($record);
  } else {
    $zuid = r\unQuid('', $zid, $regionUid); // unQuid not unQid
    return array($zuid, $zuid); // pro Se
  }
}

/**
 * Store or retrieve the given offsite data.
 * @param string (bigint) $id: record key of offsite data to retrieve or update (if empty, store the data)
 * @param assoc $data: fields to store or update offsite (if NULL, retrieve the data)
 * @return: the actual data (if RETRIEVING) or record key (if STORING)
 */
function offsiteData($id, $data = NULL) {
/// debug(strlen(u\ezencrypt(serialize($orig = $data), R_WORD)));
  if (isset($data)) $data = bin2hex(u\ezencrypt(serialize($data), R_WORD));
/// debug(strlen($data));
/// debug($data);
/// debug(u\ezencrypt(serialize($orig), R_WORD) == hex2bin($data));
/// debug(R_SECRET_URL . '/offsite.php');
  $result = u\httpRequest(R_SECRET_URL . '/offsite.php', compact('id', 'data'));
/// debug($result);
  return isset($data) ? $result : unserialize(u\ezdecrypt(hex2bin($result), R_WORD)); // hex2bin = pack('H*'
}  

function acct($uid = '', $agent = '', &$error = '') {
  global $currentAcct; // use this ONLY in this class file
  if (!$uid) {
    if (!$currentAcct) {$error = 'There is no current account.'; return FALSE;}
    return $currentAcct;
  }
  if (!acct::viable($uid, $agent, $error, TRUE)) return FALSE;
  return new acct($uid, $agent);
}

function agent($uid = '') {return @acct($uid)->agent;}
