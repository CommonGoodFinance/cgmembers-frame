<?php
namespace rCredits;
use rCredits as r;
use rCredits\DB as db;
use rCredits\Backend as be;
use rCredits\Util as u;
use rCredits\Testing as t;
use rCredits\Web as w;

/**
 * @file
 * %PROJECT account class
 */
 
class Acct {
  public $id; // the account's record id
  public $agentId; // record id (in the agent's regional server) of whoever is acting on behalf of the account
//  var $mainQid; // nearly alphabetic representation of id, id, and region for external queries
  public $qo; // qid object
  
  private static $perms = []; // permissions for all acct objects, indexed by id and agent
  public static $rs = FALSE; // account records for all acct objects, indexed by id
  
  /**
   * Instantiate (create or retrieve) a member account for transactions and/or contact
   * @param mixed $info (either assoc or array):
   *   (1) an assoc: initial field values for the account, to be created in the database, including at least one of the following:
   *     'uid' the record id
   *     'phone' is contact phone (in standard +ddddddddddd format) OR
   *     'number' is cell phone (in standard +ddddddddddd format -- use for phone also) OR
   *     'email' is email address
   *     (This function assumes that the field values not sufficient to identify an existing user)
   *   (2) a flat array of user table IDs: [uid, agent] where uid is the main account and agent is the agent's id
   */
  function __construct($info = []) {
    $a = $this;
    if (!is_numeric(key($info))) { // u\isAssoc($info)) { // specifying field values
      $a->createNew($info); // create new db record
    } else list($a->id, $a->agentId) = $info; // called from r\acct()
    $a->qo = r\qo($a->id, $a->proSe ? '' : $a->agentId);
  }    

  /**
   * Create a new account record in the database.
   * @param assoc $info: array of field values for new account
   */
  private function createNew($info) {
    $a = $this;
    extract($info);
    
    u\setDft($phone, @$number);
    if ($phone) $phone = u\fmtPhone($phone, '+n');
    
    $status = TRUE;
    u\EXPECT($email, 'account with no email address');
    u\setDft($fullName, @$legalName);
    u\setDft($legalName, $fullName);
    $shortName = @$fullName ? u\shortName($fullName) : '';
    u\setDft($name, @$shortName ?: tempName($info));
    u\setDft($flags, 0);
    $co = ($flags & u\bit(B_CO));
    u\setDft($rebate, R_REBATE);
    if (@$state and !is_numeric(@$state)) { // allow state abbrevs within US
      $state = db\lookup('id', 'r_states', 'abbreviation=:state and country_id=:US_COUNTRY_ID', compact('state'));
    }
    u\setDft($community, r\communityUid(@$postalCode)); // defaults to current server
    u\setDft($created, r\rTime());
    u\setDft($login, $created);
    u\setDft($access, $login);

    $stepsDone = @$uid == 1 ? [] : r\stepsDone0();
    foreach (ray($co ? 'proxies connect' : 'company relations') as $k) unset($stepsDone[$k]);

    if (!@$uid and !@$region) $region = @$postalCode ? -r\region(@$country, @$state, @$postalCode) : -r\uidRegion($community);

    $record = compact('uid', 'name');
    
    $DBTX = db_transaction();
    $uid = r\regionalInsert('users', 'uid', $record, @$region);
    u\EXPECT($uid != 0, 'zero regionalinsert');
    if (!$co) { // must postcede $uid =
      u\setDft($cardCode, r\cardCode(r\qid($uid)));
      u\setDft($emailCode, r\cardCode(r\qid($uid)));
    }
    
    if (isset($number)) $success = SMS\create($number, $uid);

    list ($a->id, $a->agentId) = array($uid, $uid); // finish creating the object

    self::$rs[$a->id] = (object) $record;

    foreach (ray('number region') as $k) unset($info[$k]);
    u\preray(compact(ray('phone status email pass fullName legalName flags rebate state community created login access emailCode cardCode stepsDone')), $info); // things we may have added or changed
    $a->update($info); // this is a lot easier to do after saving the record
    unset($DBTX); // commit
  }

  /**
   * Setup acct variables, returning FALSE on error.
   * @param id/qid $id: the account's record id or qid (DEFAULT to myid)
   * @param id/qid $agent: the agent's record id or qid (DEFAULT to same as $id)
   * @param string $error: (RETURNED) the error message, if any
   * @param bool $test: <this is only a test, do not die on error>
   * @return [$id, $agent] where id and agent are actual record IDs
   */
  public static function viable($id00, $agent0='', &$error='', $test = TRUE) {
    if (is_numeric($id00) and is_numeric($agent0)) return [$id00, $agent0];
    $id0 = $id00;
    if (strpos($id0, AGT_MARK)) list ($id0, $agentCode) = explode(AGT_MARK, $id0); // new company qid format

    if ($error = u\EXPECT(compact(ray('id0 agent0')), 'zid|qid|assoc empty|id|qid', $test)) return FALSE;
    if ($error = u\EXPECT((bool) $id0, 'null uid in new r\Acct()', $test)) return FALSE;
    if ($error = u\EXPECT(!(strpos($id0, R_AGENT_MARK) and $agent0), 'agent already specified in qid', $test)) return FALSE;
    list ($id, $agent) = u\isZid($id0) ? [$id0, $agent0 ?: $id0] : r\qo($id00)->ia; // handle

    if (u\isQid($agent0)) {
      list ($agent, $zot) = r\qo($agent0)->ia;
      if ($error = u\EXPECT($agent == $zot, 'agent agent not allowed', $test)) return FALSE;
    }

    $got = (bool) self::getRecord($id); // read the record into cache
    if ($error = u\EXPECT($got, 'That account does not exist.', $test)) return FALSE; // don't use t() here (many calls)

    if (isset($agentCode)) $agent = r\qo($id0 . AGT_MARK . $agentCode)->agent; // new company qid format

    if ($error = u\EXPECT($id and $agent, "Missing acct property: [$id, $agent]", $test)) return FALSE;
    return [$id, $agent];
  }
  
  private static function getRecord($id, $reread = FALSE) {
/// if (@self::$rs[$id] and !property_exists(self::$rs[$id], 'flags')) die("No flags field in record $id: " . print_r(self::$rs, 1)); // keep this
    if (@self::$rs[$id] and !$reread) return self::$rs[$id];
    if (!$records = db\records('users', "uid=:id LIMIT 1", compact('id'))) { // no such record here
      if (TRUE) return FALSE; // not foreign either
      // contact other server here, for a subset of the record
    }

    return self::$rs[$id] = (object) $records[0];
  }

  /**
   * Read in the account record, if we haven't yet.
   * This function should be called before any reference to self::$rs[$this->id] (except in contructor).
   * @param bool $force: reread even if we already have an account record (used only externally)
   */
  public function reread($force = FALSE) {
    if (!@self::$rs[$this->id] or $force) self::getRecord($this->id, TRUE);
  }
  
  /**
   * Return the value of the specified field that is not a simple property of the acct class.
   * This function reads the account record from the database if it hasn't been read yet.
   * Many of these fields are slightly tweaked fields from the users table (for example, unserialized or decrypted).
   * @param string $field: name of field value to get
   * @return the value if it exists, else NULL
   */
  public function __get($field) {
    $a = $this;
    $a->reread(); // make sure record has been read in

    if (u\starts($field, 'o_')) { // ignore joinedness of the account, if it is joint ("own" account)
      $field = substr($field, 2);
    } elseif (u\starts($field, 'j_')) { // concatenate joint fields
      $field = substr($field, 2);
      return $a->o($field) . ($a->jid ? ' & ' . $a->jA->o($field) : '');
    } else { // tests for field must precede tests for jid or slave (else loop)
      if (u\in($field, JOINT_FIELDS) and $a->jid) return round($a->o($field) + $a->jA->o($field), 2); // sum joint fields
      if (u\in($field, MASTER_FIELDS) and $a->slave) return $a->jA->o($field); // master only
    }

    // From here down, everything should be for "own" account
    $nick = substr($field, 0, 3); // possibly meaningful prefix
    if (in_array($nick, ['can', 'raw']) and $field != 'rawChanges') $field = lcfirst(substr($field, 3));
    if (u\in($field, B_LIST . ' up cgc cttyActive cttyUp')) $nick = 'can';
    if ($nick == 'can') return $a->can(u\consta('b', $field));
    
    if ($field == 'mainQid') return $a->qo->mainQid;
    if ($field == 'isRegulator') return (bool) ($a->flags & u\bit(B_REGULATOR)); // not ->can() included by cAdmin etc.
    if ($field == 'balance') return $a->o_r - $a->o_rewards; // $a->r - $a->savings;
    u\EXPECT($field != 'savings', 'tried to get savings field'); // return ($a->rewards + ($a->savingsAdd ?: 0));
    if ($field == 'email') return strpos($a->mail, '@') ? $a->mail : u\decryptN($a->mail);
    if ($field == 'phone') return u\starts($ph = @self::$rs[$a->id]->phone, '+') ? $ph : u\decryptN($ph);
    if ($field == 'agentA') return r\acct($a->agentId);
    if ($field == 'proSe') return ($a->id == $a->agentId);
    if ($field == 'qid') return $a->qo->qid;
    if ($field == 'rewarding') return FALSE; // no community is guaranteeing incentive rewards at this time
    if ($field == 'isCtty') return ($a->id < 0); // or ($a->id == $a->community);
    if ($field == 'isRegion') return (substr($a->name, -1, 1) == '.');
    if ($field == 'isNormal') return ($a->id > 0);
    if ($field == 'cttyA') return r\acct($a->community);
    if ($field == 'region') return r\uidRegion($a->id);
    if ($field == 'regionName') return @r\acct($a->region)->fullName ?: (PROJECT . ' ' . db\lookup('name', 'r_regions r INNER JOIN r_states s ON s.abbreviation=r.st', 's.country_id=:US_COUNTRY_ID AND r.region=:reg', ['reg' => $a->qo->region]));
    if ($field == 'legalNameDpy') return str_replace('_', ' ', $a->legalName); // for u\parseName of names like Jay di_Fiori
    if ($field == 'owns') return !$a->risk('rents');
    if ($field == 'hasBank') return $a->risk('hasBank');
    if ($field == 'lowSecurity') return u\n2ai(substr($a->created, -5, 5), 3); // result is 3 chars long
    if ($field == 'inviteCode') return $a->mainQid . $a->lowSecurity;
    if ($field == 'slave') return ($jid = $a->jid and $jid < $a->id); // slave in a joint account
    if ($field == 'jA') return $a->jid ? r\acct($a->jid) : NULL;
    if ($field == 'masterA') return $a->slave ? $a->jA : $a;
    if ($field == 'helperA') return $a->helper ? r\acct($a->helper) : '';
    if ($field == 'prefsSet') return !is_null($a->o_minimum); // preferences have been set at least once
    if ($field == 'bankInfo') return (!$routing = substr($a->bankAccount, 4, 9)) ? NULL
      : db\lookup('*', 'r_banks', 'route=:routing', compact('routing'));
      
    if (isset(self::$rs[$a->id]->$field)) {
      $result = @self::$rs[$a->id]->$field; // returns NULL if field not set
    } else $result = $a->getSpecial($field); // set up caches and get value, if appropriate
    
//    if ($field == 'raw') return $result;
    if ($nick == 'raw') return $result;

    if ($field == 'language') return \user_preferred_language((object) ['language' => $result]);
    if ($field == 'hasPhoto') return $this->photo or file_exists(DRUPAL_ROOT . $this->photoFilename(TRUE));
    if ($field == 'photo') return $result ? u\decrypt($result) : '';
    if (in_array($field, ray(R_VSECURE_FIELDS)) and !is_array($result) and u\starts($result, CRYPT_FLAG)) { // !is_array() is temporary, for ssnData in transition
      if (@r\acct()->admin and $pw2 = @$_COOKIE['pw2']) {
        $result = u\decrypt($result, 0, $pw2);
        if ($field == 'ssnData') $result = unserialize($result);
        return @self::$rs[$a->id]->$field = $result;
      }
    }

    if (in_array($field, ray('data changes secure')) and !is_array($result)) { // special not yet arrayed
      if (!$result) return [];
      if ($field == 'secure') $result = u\decrypt(u\decrypt($result, 1), 0);
      if ($field == 'changes' and u\starts($result, CRYPT_FLAG)) {
        self::$rs[$a->id]->rawChanges = $result;
        $result = u\decrypt(u\decrypt($result, 1), 0);
      }
      return (self::$rs[$a->id]->$field = unserialize($result));
    }

    return $result;
  }

  /**
   * Cache the set of special fields of which the given field is a member.
   * @param mixed $field: possibly special field name (data/secure)
   * @return the field value
   */
  private function getSpecial($field) {
    $a = $this;
    foreach (['data', 'secure'] as $k) {
      if ($a->special($field, strtoupper($k))) {
        if ($set = $a->$k ?: []) u\preray($set, self::$rs[$a->id]); // cache all components of the special field
        return @$set[$field]; // must be separate line from $a->set (PHP bug)
      }
    }
    return NULL;
  }
  
  /**
   * Say whether the given field(s) is/are the specified kind of special.
   * @param mixed $fields: array or space-delimited list of fields (one or more)
   * @param string $specialType: name of space-delimited list of special fields of a certain type.
   * @return <at least one of $fields is in the $specialType list>
   */
  private function special($fields, $specialType) {
    $specials = constant("R_{$specialType}_FIELDS");
    return is_array($fields) ? (bool) array_intersect($fields, ray($specials))
    : (strpos($fields, ' ') === FALSE ? u\inList($fields, $specials) // be efficient, if just one field
    : (bool) array_intersect(ray($fields), ray($specials)));
  }
  
  /**
   * Handle joint field request (for example $a->j_r)
   * @param string $field: normal name of field to get for both members of the joint account (if it is joint)
   * @return if joint: the sum or concatenation of the member account values, otherwise just the normal value
   *//*
  private function jGet($field) {
    $a = $this;
    if (!$jid = $a->jid) return $a->$field;
    if (in_array($field, ray(MASTER_FIELDS))) return $a->masterA->$field;
    $j = u\nn(r\acct($jid)->$field, 0); // use 0 if other value is null
    return is_numeric($j) ? round($j + $a->$field, 2) : ($a->$field . " & $j"); // assume $ for numeric fields
  }*/
  
  /**
   * Return a printable (scrambled) invitation card code 
   * @param int $iCode: sequence number (0 to 35^3-1)
   */
  public function iCardCode($iCode = 0) {
    $a = $this;
    list ($region, $tail) = $a->qo->parse();

    $b = u\lpad(decbin(u\a2n($region)), ILEN_REGION);
///  debug("b=$b region=$region tail=$tail security=$a->lowSecurity iCode=$iCode");
    $b .= u\lpad(decbin(u\a2n($tail)), ILEN_TAIL);
///  debug("b=$b region=$region tail=$tail security=$a->lowSecurity iCode=$iCode");
    $b .= u\lpad(decbin(u\ai2n($a->lowSecurity)), ILEN_SECURITY);
///  debug("b=$b region=$region tail=$tail security=$a->lowSecurity iCode=$iCode");
    $b = u\rotateBits($b, ($iCode + 1) * (bindec(substr(R_INVITE_KEY, 0, 31)) % strlen($b)));
///  debug("b=$b region=$region tail=$tail security=$a->lowSecurity iCode=$iCode");
    $b = u\xorBits($b, substr(R_INVITE_KEY, -strlen($b)));
///  debug("b=$b region=$region tail=$tail security=$a->lowSecurity iCode=$iCode");
    return u\n2ai(bindec(substr($b, 0, ILEN_DIV)), 5) . u\n2ai(bindec(substr($b, ILEN_DIV)), 5) . u\n2ai($iCode, -1);
  }

  /**
   * Return the entire account object or just certain fields.
   * @param string $just: space-delimited list of fields to return (all raw fields, if empty)
   * @param bool $own: <return just the account's own field values, even if it is a joint account> (always true if $just == '')
   * Note: the returned object does not include uid -- haven't figured out why.
   */
  public function account($just = '', $own = TRUE) {
    $a = $this;
    $a->reread(); // make sure we have read the record from the db
    if (!$just) return @self::$rs[$a->id];

    foreach (ray($just) as $k) $res[$k] = $own ? $a->o($k) : $a->$k;
    return (object) $res;
  }

  public static function _clear() {self::$perms = self::$rs = [];}
  
  /**
   * Return the next available uid in the specified region.
   */
  public static function nextId($region = '') {
    u\EXPECT($region <= 0, 'non-negative region in nextId');
    return r\newUid(-($region ?: r\serverUid()));
  }
  
  /**
   * Update the saved record in the database with the given data. For joint accounts, update partner too.
   * Call by:
   *   update($info); OR
   *   update($fields, $value1, ...)
   * @param assoc $info: data to update
   * @param string $fields: space-delimited list of field names
   * @param mixed $value1 (etc): new values for those fields
   * @return: TRUE if update succeeds, FALSE if update fails
   */
  public function update($info) {
    $a = $this;
    if (!is_array($info)) $info = rayy(func_get_args());
    
    u\EXPECT(!isset($info['savings']), 'archaic savings field');
//    if ($jid = $a->jid and $jInfo = u\just(MASTER_FIELDS . ' savings', $info)) {
    if ($a->jid and $jInfo = u\just(MASTER_FIELDS, $info)) {
      list ($a2, $a1) = u\order($a->slave, $a, $a->jA); // set $a1 master, $a2 slave

      $jInfo2 = array_fill_keys(ray(MASTER_FIELDS), 0);
      unset($jInfo2['achMin']); // no change to slave achMin
      $a2->update1($jInfo2);
      
//      $a2->update1(MASTER_FIELDS, FALSE, '', '', FALSE, @$jInfo['achMin'] ?: $a1->achMin, 0, 0, 0); // not much for slave
//      $a->updateSavings($jInfo, $a1 == $a ? $a2->rewards : $a1->rewards); // update savings in master
      $a1->update1($jInfo);
//      if (!$info = u\justNot(MASTER_FIELDS . ' savings', $info)) return TRUE; // fall through if something else to update
      if (!$info = u\justNot(MASTER_FIELDS, $info)) return TRUE; // fall through if something else to update
    }
//    } else $a->updateSavings($info, 0); // update savings in proSe account

    return $a->update1($info);
  }

  /**
   * Interpret requested update of savings as a change to the savingsAdd field (for testing).
   * @param assoc $info: (MODIFIED) fields and values to update
   * @param numeric $slaveRewards: rewards in slave account, if any
   *//*
  private function updateSavings(&$info, $slaveRewards) {
    if (isset($info['savings'])) {
      $rewards = (@$info['rewards'] ?: $this->rewards) + $slaveRewards;
      $info['savingsAdd'] = $info['savings'] - $rewards; // may be negative in official CGCs
      unset($info['savings']);
    }
  }*/
  
  /**
   * Update the account record in the database (with no special treatment of joint accounts).
   */
  public function update1($info) { // public only for testing
    $a = $this;
    if (!is_array($info)) $info = rayy(func_get_args());

    if (isset($info['balance'])) {
      $info['r'] = $info['balance'];
      foreach (['rewards', 'savingsAdd'] as $k) $info['r'] += isset($info[$k]) ? $info[$k] : $a->o($k);
      $info['r'] = round($info['r'], 2);
      unset($info['balance']);
    }

    foreach ($bits = u\just(B_LIST, $info) as $k => $v) {$a->setBit($k, $v); unset($info[$k]);}
    if ($a->ok and !isGAME) $info += $a->recordChanges(u\justNot(B_LIST, $info)); // record changes if member is active
    foreach (u\just('hasBank', $info) as $k => $v) {$a->setRisk($k, $v); unset($info[$k]);}

    if (isset($info['photo'])) $info['photo'] = u\crypt($info['photo']);
    if (isset($info['email'])) $info['mail'] = u\cryptN($info['email']);
    if (isset($info['phone'])) $info['phone'] = u\cryptN($info['phone']);
    
    if (isset($info['data'])) {
      $info['data'] = serialize($info['data']);
    } elseif ($data = u\just(R_DATA_FIELDS, $info)) $info['data'] = serialize($data += $a->data);

    if (($set = isset($info['secure'])) or $sFlds = u\just(R_SECURE_FIELDS, $info)) { // serialize and encrypt
      if (!$set and @r\acct()->admin and $pw2 = @$_COOKIE['pw2'] and $vflds = u\just(R_VSECURE_FIELDS, $sFlds)) {
        foreach ($vflds as $k => $v) if (is_array($v) or !u\starts($v, CRYPT_FLAG)) { // is_array is temporary for ssnData in transition
          if ($k == 'ssnData') $v = serialize($v);
          $info[$k] = $sFlds[$k] = u\crypt($v . '', 0, $pw2);
        }
      }
      $secure = $set ? $info['secure'] : ($sFlds + $a->secure);
      $info['secure'] = u\crypt(u\crypt(serialize($secure), 0), 1);
    }
    if (isset($info['pass'])) $info['pass'] = r\passHash($info['pass']);

    u\preray($info, self::$rs[$a->id]); // cache the new field values
    $info = u\justNot(R_SECURE_FIELDS . ' email ' . R_DATA_FIELDS, $info); // don't pass these
    return $info ? db\update('users', $info + ['uid' => $a->id], 'uid') : TRUE;
  }

  /**
   * Record memorable changes being made to an account record.
   * @param assoc $info: all changes being made
   * @return the changes
   */
  private function recordChanges($info) {
    $a = $this;
    $newChanges = u\justNot(R_HIDE_CHANGES, $info); // see if there are any changes to remember
    foreach ($newChanges as $k => $v) { // don't record if no change
      $ak = $a->$k;
      if ($v == $ak or (is_numeric($v) and is_numeric($ak) and $v + 0 == $ak + 0)) {
        unset($newChanges[$k]);
      } else $newChanges[$k] = $ak; // @self::$rs[$a->id]->$k;
    }
    
    if (!$newChanges) return [];
  
    $changes = $a->changes; // must precede ->rawChanges
    $encrypted = u\starts($a->rawChanges, CRYPT_FLAG);
//    for ($k = r\rTime(); isset($changes[$k]); $k++);
    $time = r\rTime();
    if (isset($changes[$time])) {
      $changes[$time] += $newChanges;
    } else u\preray([$time => $newChanges], $changes); // put the new changes first
    $changes = serialize($changes);
    if ($encrypted or u\just(R_SECURE_FIELDS, $newChanges)) $changes = u\crypt(u\crypt($changes, 0), 1);
    return compact('changes');
  }
  
  public function isNonprofit() {return (bool) ($this->coFlags & u\bit(CO_NONPROFIT));}
  
  /**
   * Create a new relationship record.
   * NOTE: Assume no other company agent for this company is trying to create a relation at the same time.
   * @param assoc $info: field values
   * @return: the record ID of the new relationship record
   */
  function newRelation($info) {
//  function newRelation($other, $permission = 0, $employee = 0, $isOwner = 0, $draw = 0, $reid = NULL) {
//   * @param int $other: account ID of the account to relate to this (all other params are optional)
//   * @param int $reid: relationship record ID (for testing only)
//    $info = compact('reid') + ray('main other permission employee isOwner draw',
//      $this->id, $other, $permission, (int) $employee, (int) $isOwner, (int) $draw);
    //return db\insert('r_relations', $info);
    u\EXPECT($info['other'], 'missing other in new relation');
    foreach (['employee', 'isOwner', 'draw'] as $k) $info[$k] = (int) @$info[$k];
    return r\regionalInsert('r_relations', 'reid', $info + ['main' => $this->id], -$this->region);
  }

  /**
   * Create an agent number for the account's relation, if it's a relational account and doesn't have one yet.
   */
  public function setAgentNum() {
    $a = $this;
    if ($a->proSe or r\qo($a->qid)->agentCode) return;
    $otherNum = db\max('otherNum', 'r_relations', 'main=:main', ['main' => $a->id]) + 1;
    $reid = r\relation('reid', $a->id, $a->agentId);
    db\update('r_relations', compact('otherNum', 'reid'), 'reid');
    return $otherNum;
  }
  
  /**
   * Say whether the wanted transaction proof really wrong, not just a delayed transaction with a cardcode that got changed.
   * @param string $proof: tx proof supplied by the app
   * @param string $wanted: proof we expected
   * @param int $created: transaction creation date/time
   * @return <the proof is really wrong>
   */
  public function badOldProof($proof, $wanted, $created) {
    $a = $this;
    $codeName = $a->proSe ? 'cardCode' : 'cardCode2';
    $code = $a->$codeName;
    $changes = $a->agentA->changes;
    
    foreach ($changes as $tm => $v) {
      if ($tm < $created) break;
      if ($oldCode = @$v[$codeName] and u\hash(str_replace($code, $oldCode, $wanted)) == $proof) return false;
    }
    return true;
  }
  
  /**
   * Return specified account's profile picture, with markup
   * @param bool $unique: should the markup force reloading the image
   * @return: markup to display the account's picture (with a default image if none)
   * Use result with DRUPAL_ROOT . $result OR $base_url . $result
   */
  public function photoHtml($small = FALSE, $unique = FALSE) {
    $a = $this;
    global $base_url;
    if ($unique) $unique = '?' . r\rTime();
    $thing = $small ? 'icon' : 'photo';
    $qid = $a->mainQid;
    if (!$a->co) $qid .= "/$a->cardCode";
    return '<div id="user-picture"><img src="' . "$base_url/settings/member-photo/$qid$unique" . '" alt="profile picture" /></div>';
  }

  /**
   * Return the account's name and qid, with a link to a fuller description.
   */
  public function linkedDesc() {
    global $base_url;
    $qid = "<a href=\"$base_url/summary/$this->mainQid\">$this->mainQid</a>";
    return "$this->fullName ($qid)";
  }
  
  /**
   * Calculate updated r, rewards, and committed caches for a transaction (but do not write to db)
   * @param assoc $tx: the transaction record (or at least these fields: payer, payee, amount, type)
   * @param int $type: transaction type
   * @param stdObject $c: the cached fields:
   *   float $r: (UPDATED) the account's r balance
   *   float $rewards: (UPDATED) the account's rewards ever
   *   float $committed: (UPDATED) the account's reserve for sharing rewards with CGF
   *//*
  public function recache3($amount, $type, &$c) {
    $c->r = round($c->r + $amount, 2);
    if ($c->r < 0 and $this->slave) { // Don't let joint account slave balance go negative, so cron can handle banking right.
      $this->jA->update('r', $this->jA->o_r + $c->r); // send the negative balance to the master
      $c->r = 0;
    }
    if (r\isReward($type)) {
      if ($type == TX_REBATE or $type == TX_BONUS) $c->committed = round($c->committed + $amount * $this->share / 100, 2);
      $c->rewards = round($c->rewards + $amount, 2);
    }
  }*/

  /**
   * Set the bit in the flags field to the given value.
   * @param int $bit: number of bit to set (0 - 31)
   * @param bool $on: whether to set it ON or OFF
   * @return <successful>
   * @see also self::can()
   */
  public function setBit($bit, $on = TRUE) {
    $a = $this;
    if (!is_numeric($bit)) $bit = u\consta('b', $bit);
    $res = $a->setBitx($bit, $on, 'flags'); 
    if (@self::$perms[$id][$a->agentId]) {
      self::$perms[$id][$a->agentId][$bit] = $on;
    } // else can gets refreshed automatically next time can() is called
    return $res;
  }
  
  // public function refreshCan() {self::$perms[$this->id] = NULL;} // UNUSED force redo in can()

  /**
   * Set the current account being managed (must be static so we can set account to empty)
   * @param acct $a: the account to manage
   * @return: the account (FALSE if $a is empty)
   */
  public static function setDefault($a) {
    global $currentAcct, $channel; 
    global $user; if (empty($user)) $user = (object) ['uid' => $a ? $a->id : 0]; // probably needed only for rWeb login form testing
    if ($a and @$currentAcct != $a and !$a->cAdmin) { // admin access doesn't count
      $access = r\rTime();
      if ($channel == TX_WEB) $login = $access;
      $a->update(compact('login', 'access'));
    }
    return $currentAcct = $a;
  }

  /**
   * Return a filename for the back of invitation cards (to print)
   */
  public function invitationBack() {
    $a = $this;
    $filename = ($a->co and ($a->admin or $a->id != r\cgfId())) ? 'InvitationCardsBackCo.pdf' : 'InvitationCardsBack.pdf';
    return 'http://rc4.me/doc/' . $filename;
  }

  /**
   * Return the amount not available, including draws from related accounts, depending on the purpose.
   * If there are fees for drawing from a related account, they are added to the amount needed.
   * If the account has permission to cash out while serving as an ATM their rewards amount will not limit them.
   * @param string $goods: (does not default, to make sure we know what we're doing)
   *   FOR_GOODS or FOR_NONGOODS: the amount of credit available for a purchase 
   *     (including credit lines)
   *   FOR_USD: the amount of credit available to trade for cash or US Dollars
   *     (not including credit lines and rewards)
   * @param float $need: the amount needed
   * @param bool $get: draw from other accounts as needed, then say whether there is enough
   * @param acct $actor: account of the individual or company initiating the transaction
   * @param bool $retrying: UNUSED recursed after updating cache usd amount
   * @return how much short this account is, of what's needed
   */
  public function shortfall($goods, $need = 0, $get = FALSE, $actor = NULL) {
    global $channel;
    $a = $this;
    // don't allow companies to spend rewards unless they have ATM permission and are exchanging r for USD
    if ($a->co and COMPANY_FREEZE) $goods = (@$actor == $a and $a->coCan(CO_ATM) and $goods == FOR_USD) ? FOR_GOODS : FOR_USD;
    $avail = $a->avail($goods);
    if ($avail >= $need) return 0; // plenty without drawing from other accounts

    $avail += $get ? $a->draw($need - $avail) : $a->canDraw(); // get or just asking
    return max(0, $need - $avail); 
  }
  
  /**
   * Return how much is available in this account for the given operation, without drawing on other accounts.
   * @param string $goods: purpose of the potential expenditure: FOR_GOODS or FOR_USD - see r\Acct::shortfall())
   */
  public function avail($goods) {
    $a = $this;
    $floor = ($a->can(B_DEBT) and $goods != FOR_USD) ? $a->floor : max($a->floor, 0); // no going into debt without permission
    if ($goods == FOR_USD or (COMPANY_FREEZE and $a->co)) $floor = max($floor, $a->rewards); // no exchanging rewards for cash (and companies temporarily can't spend rewards)
    return round($a->r - $floor, 2);
//    return round($a->j_r - $a->j_committed - $floor, 2);
  }
  
  /**
   * Return the amount this account can draw from other accounts.
   * Repairs the B_DRAWS bit if all such relations have ended.
   */
  private function canDraw() {
    if (!$this->can(B_DRAWS)) return FALSE;
    
    $id = $this->id;
    $availBuy = R_AVAIL_BUY; // R_AVAIL_BUY contains a constant, so can't use :R_AVAIL_BUY
    $sql = <<<EOF
      SELECT SUM($availBuy) AS avail, COUNT(*) as count
      FROM users u INNER JOIN r_relations r ON r.main=u.uid
      WHERE r.other=:id AND r.draw
EOF;
    if (!$row = db\q($sql, compact('id'))->fetchAssoc()) return 0;
    if (!$row['count']) $this->setBit(B_DRAWS, FALSE); // doesn't really have any drawable accounts
    return $row['avail'];
  }
  
  /**
   * Draw the needed amount from other accounts.
   * @param float $need: the amount needed
   * @return float: the amount drawn
   */
  public function draw($need) {
    if (!$this->can(B_DRAWS)) return 0;
    list ($from, $to, $auto) = array(t(' from '), t(' to '), t('automatic transfer'));
    $left = $need; // how much left to be drawn
    $id = $this->id;
    $availBuy = R_AVAIL_BUY; // R_AVAIL_BUY contains a constant, so can't use :R_AVAIL_BUY
    $sql = <<<EOF
      SELECT u.uid,$availBuy AS avail FROM users u INNER JOIN r_relations r ON r.main=u.uid
      WHERE r.other=:id AND r.draw
EOF;
///   debug(compact(ray('type need from to auto left id fields sql')));
    $result = db\q($sql, compact('id'));
    while ($row = $result->fetchAssoc()) {
      extract($row);
      $amount = round(min($left, $avail), 2);
///      debug(compact('row','avail','amount','left','need','id'));
      if ($amount > 0) {
        list ($fromQid, $toQid) = [r\qid($uid), $this->mainQid];
        list ($payer, $payee) = [$uid, $this->id];
        $for = [$auto . $to . $toQid, $auto . $from . $fromQid];
        $goods = FOR_NONGOODS;
        if (new r\X(compact(ray('amount payer payee goods for')))) $left -= $amount;
        if ($left <= 0) break;
      }
      
    }
    return round($need - $left, 2);
  }

  /**
   * Check the account's actual balance(s) and fix them if necessary.
   * @param bool $testOnly: <don't fix anything>
   * @return TRUE if the cached amounts are correct.
   * Otherwise maybe deactivate the account, tell the staff, and return FALSE.
   * Tricky: for joint accounts, r may be wrong (slave r is never negative), but the sum should be correct.
   */
  public function cacheOk($testOnly = FALSE) {
    $a = $this;
    $uid = $a->id;
    if ($uid < 0) return TRUE; // for communities and regions, nothing is cached
    $jA = $a->jA;

    $calc = be\creditInfo(ray('uid noj', $uid, TRUE));
    if ($jA) $jCalc = be\creditInfo(compact('uid')); // for joint account get joint info
    
    foreach (['r', 'rewards'] as $k) {
      list ($is, $shouldBe) = [$a->o($k), round($calc->$k, 2)];

      if ($jA and $k == 'r') {
        list ($jIs, $jShouldBe) = [$a->$k, round($jCalc->$k, 2)];
        $bad = ($jIs != $jShouldBe or ($a->slave and $is < 0)); // joint r must be correct AND slave r non-negative
      } else list ($bad, $jIs, $jShouldBe) = [$is != $shouldBe, '', ''];
      
      if ($bad) {
//        $worst = max(abs(round($is - $shouldBe, 2)), $worst);
        $worst = TRUE;
// NO        if ($a->jid) $shouldBe = round($shouldBe - $a->jA->o($k), 2);
        $DBTX = \db_transaction();
        if ($k == 'r') $a->slaveCacheR($shouldBe, $testOnly); // affects only slave, sum is already correct (master goes first)
        if (!$testOnly) $a->update($k, $shouldBe);
        unset($DBTX);
        $fullName = $a->fullName;
        r\tellAdmin('cache mismatch', compact(ray('fullName k is shouldBe jIs jShouldBe')));
      }
    }
    if (@$worst) {
      // (disable temporarily)      if ($worst > .01) $a->suspend('to protect data integrity.'); // ignore a penny error
      return FALSE;
    } else return TRUE;
  }

  /**
   * Don't let joint account slave balance go negative, so cron can handle banking right.
   * @param numeric $r: (RETURNED FIXED) the prospective balance to cache for this account
   */
  public function slaveCacheR(&$r, $testOnly = FALSE) {
    $a = $this;
    if ($r < 0 and $a->slave) { // Don't let joint account slave balance go negative, so cron can handle banking right.
      if (!$testOnly) $a->jA->update('r', $a->jA->o_r + $r); // send the negative balance to the master
      $r = 0;
    }      
  }

  /**
   * Return full account name, including the other's name in a joint account.
   *//*
  function j_acctName() {
    $a = $this;
    $name = "$a->fullName ($a->name)";
    $sql = 'main=:main AND permission=:joint';
    $subs = ['main'=>$a->id, 'joint'=>r\perm(B_JOINT)];
    if ($a->can(B_JOINED) and $other = r\relation('other', $sql, $subs)) {
      $a2 = r\acct($other);
      $name .= " & $a2->fullName ($a2->name)";
    }
    return $name;
  }*/

  /**
   * Set or return the proxy for the person
   */
  public function proxy($priority = 1, $proxy = NULL) {
    $person = $this->id;
    if (!@$proxy) return db\lookup('proxy', 'r_proxies', 'person=:person AND priority=:priority', compact('person', 'priority'));
    db\q('DELETE FROM r_proxies WHERE person=:person AND priority=:priority', compact('person', 'priority'));
    $info = compact(ray('person priority proxy'));
    db\insert('r_proxies', $info);
  }

  /**
   * Mark two accounts joined (a joint account)
   * @param acct $b: the other account
   * Note we cannot split rewards and floor because they are recalculated in cron.
   */
  function join($b) {
    $a = $this;
    $fields = ray(MASTER_NUMERIC_FIELDS);

    $DBTX = \db_transaction();
    foreach ([$a, $b] as $i => $ai) {
      $aj = $i == 0 ? $b : $a; // the other account
      $ai->update('jid', $aj->id);
      if (!$ai->o_hasBank and $aj->o_hasBank) {
        $ai->update('bankAccount last4bank', $aj->o_bankAccount, $aj->o_last4bank);
        $ai->setRisk('hasBank');
        $ai->setBit(B_REFILL, $aj->o_refill);
      }
      $ai->setBit(B_JOINED);
      foreach ($fields as $k) $$k = @$$k + $ai->o($k);
    }
    $achMin = max($a->o_achMin, $b->o_achMin); // one of the $fields
    $a->update(compact($fields)); // this sets master numeric fields to the sums, slave fields to zero
    unset($DBTX);
  }
  
  /**
   * Unjoin a specific joint account or delete a specific joint account request or remove all joins and requests
   * @param acct $b: the joined account (any and all, if empty)
   */
  function unjoin($b = '') {
    $a = $this;

    $sql = 'UPDATE r_relations SET permission=:manage WHERE permission=:joint AND main=:id';
    $subs = ray('manage joint id', r\perm(B_MANAGE), r\perm(B_JOINT), $a->id);

    $DBTX = \db_transaction();
    if ($jid = $a->jid) { // unravel a consummated join
      $b = r\acct($jid); // ignore param (actual joined account will be unjoined and any join requests zapped)
      foreach ([$a, $b] as $ai) {
        $ai->update1('jid minimum', '', max($a->o_minimum, $b->o_minimum));
        $ai->cacheOk(); // make sure each account is left with its proper cached amounts
        $ai->setBit(B_JOINED, FALSE);
      }
      list ($a1, $a2) = u\order($b->o_balance > $a->o_balance, $b, $a);
      $amount = round(($a1->o_balance - $a2->o_balance) / 2, 2);
      if ($amount > 0) be\transfer('payment', $a1, $a2, $amount, FOR_USD, t('joint account settlement'), NULL, TRUE, ['force' => 1]);
    } elseif ($b) {
      $sql .= ' AND other=:other';
      $subs += ['other' => $b->id];
    }
    
    db\q($sql, $subs); // zap one or more joins (or requested joins) for this account
    unset($DBTX);
  }

  /**
   * De-activate the account for reasons of security or data integrity.
   * @param string $why: the reason for suspending (to tell member and staff)
   */
  public function suspend($why = '') {
    $this->setBit(B_OK, FALSE); // suspend the account
    if ($why) {
      r\message($this->id, 'account suspended', compact('why'));
      $notes = u\fmtDate() . ': ' . t('account suspended') . " $why\n" . @$this->notes;
      $this->update(compact('notes'));
      r\tellAdmin('account suspended', ray('uid fullName why', $this->id, $this->fullName, $why));
    }      
  }
  
  /**
   * Return the appropriate photo for the account (a "no photo available" image, if none).
   * ($this->photo without parens is empty for companies and empty if there is no photo)
   */
  public function photo() {
    return $this->photo ?: @file_get_contents(BASE_URL . $this->photoFilename());
  }
  
  /**
   * Return an auxiliary filename for the account.
   * @param string $type: picture, picture2, or proof
   * @param bool $ideal: return the ideal normal name, even if the file does not exist (default FALSE)
   * @return: the relative file path (relative to Drupal)
   */
  public function photoFilename($ideal = FALSE) {
    $cardCode = @$this->cardCode; // @ for testing
    if (!$ideal and !$this->hasPhoto) {
      $file = $this->co ? R_DFT_PICTURE_WIDE : R_DFT_PICTURE;
    } else $file = "$this->id-$cardCode.jpg";
    return R_PICTURE_DIR . $file;
  }
  
  public function cardCode() {
    $field = $this->proSe ? 'cardCode' : 'cardCode2';
    return $this->agentA->$field;
  }

  /**
   * Create an rCard security code for the given account (either for an individual or a company agent).
   * @param acct $a: the account
   */
  function makeCardCode($newCode = '') {
    $a = $this;
    $qid = $a->qid;
    $aA = $a->agentA;
    $field = $a->proSe ? 'cardCode' : 'cardCode2';
    $oldCode = $aA->$field;
    db\insert('r_bad', ray('qid code created', $qid, $oldCode, time()));
    if (!$newCode) $newCode = r\cardCode($qid);
    $aA->update($field, $newCode); // resave the secure fields
  }
    
  /**
   * Return the total waiting to be credited as a transfer TO or (if negative result) FROM the member's bank.
   * @param numeric $combinable: (RETURNED) how much is waiting and checks haven't been printed yet
   */
  public function waitingToBank(&$combinable = 0) {
    $id = ($jid = $this->jid) ? "$this->id,$jid" : $this->id;
    extract(db\q("SELECT SUM(amount) AS amt, SUM(IF(deposit, 0, amount)) AS combinable FROM r_usd WHERE payer IN ($id) AND NOT completed")->fetchAssoc());
    return $amt;
  }

  /**
   * Add a date stamp and agent's initials to the given note (before updating the notes field with it).
   */
  public function stampNotes(&$notes) {
    $rep = strtolower(u\initials(r\agent()->legalName) ?: 'WS');
    $date = str_replace('-', '', u\fmtDate());
    if ($notes != '' and $notes != $this->notes and substr($notes, 5, 2) != substr($date, 5, 2)) $notes = "$date  $rep: $notes"; // check century (will fail gently in 2100)
  }

  /**
   * Mark a membership step as completed.
   * @param string $step: a named step (see R_STEPS)
   * @param assoc $details: any details to report to the staff
   * @param bool $done: whether to set the step done or not done
   * @return the next step (FALSE if none)
   */
  function stepDone($step, $details = [], $done = TRUE) {
    $a = $this;
    $stepsDone = $a->stepsDone;

    if (!$stepsDone[$step]) { // unless already done
//      if ($done) r\tellAdmin(t('Step completed: ') . strtoupper($step), $details, $a->id);
    } elseif (!$a->cAdmin) r\tellAdmin(t('Settings changed: ') . strtoupper($step), $details, $a->id);
   
    $stepsDone[$step] = $done;
    $a->update(compact('stepsDone'));
    if (!$nextStep = $a->nextStep()) r\membershipEvent($a, 'member');
    return $nextStep;
  }
  
  /**
   * Return the next step to do.
   */
  function nextStep() {
    $steps = $this->stepsDone ?: []; // don't change the real data ([] for admin)
    foreach ($steps as $step => $done) if (!$done) return $step;
    return FALSE;
  }

  /**
   * Go to the next step
   * @param string $stepDone: the step just completed, if any
   * @param string $msg: message to display if account is already a member (defaults to "info saved")
   * @param string $msg: (RETURNED) a status message to display, if any 
   * @return the url of the next account-setup step ('', if no step)
   */
  public function nextStepUrl($stepDone = '', &$msg = NULL, $info = []) {
    $a = $this;
    
    if ($stepDone) u\setDft($msg, 'info saved');
    if ($a->ok or $a->closed) return $stepDone == '' ? '' : "settings/$stepDone"; // "going" to current page makes tests work
    
/*    if ($a->member) {
      if ($stepDone) $nextStep = $stepDone; else return 'summary';
    } else { */
    $nextStep = $stepDone ? $a->stepDone($stepDone, $info) : $a->nextStep();
    if (!$nextStep) {
      $approval = $a->co
      ? 'company approval'
      : ('individual approval' . ($a->confirmed ? '' : '|must be confirmed'));
      
      $msg = "setup complete|$approval" . ($stepDone ? '|join thanks' : '');
      return 'summary'; // go nowhere if not completing a step
    } elseif (!$a->member) $msg .= '|step completed';

    $steps = ray(R_STEPS);
    return $a->member ? '' : ($steps[$nextStep] ?: "settings/$nextStep");
  }

  /**
   * Decrypt and/or fix the bankAccount in a USD/rCredits exchange record.
   */
  public function fixTxBankAccount(&$bankAccount, $txid) {
    $a = $this;
    $bankAccount = ($pw2 = @$_COOKIE['pw2']) ? u\decrypt($bankAccount, 0, $pw2) : '';
    if (substr($bankAccount, 0, 2) <> 'US' and ($bankAccount = $a->bankAccount) and $pw2) { // bank account got screwed up somehow -- probably double-encrypted (happened again on 2/10/2016)
      db\update('r_usd', ray('txid bankAccount', $txid, u\crypt($bankAccount, 0, $pw2)), 'txid');
      w\say('fixed bankAccount for ' . $a->fullName);
    }
  }
  
  /**
   * Create a once-use password and return it.
   * @param string $name: login identifier (email, account ID, or shortname) -- not used on production server
   * @return the once-use password
   */
  function oneTimePass($name) {
    $a = $this;
  //  $pass = strtolower(u\nonce()); // not a hash, easy to remember and type
    $verifying = !$a->stepDone['verify'];
    $pass = u\randomString($verifying ? 3 : R_CODE_LEN, $verifying ? 'upper' : 'word'); // use
  /// oops! don't let people reset passwords on test server. if (!isPRODUCTION and !in_array($name, ray('cornerstore bobbossman cathycashier helgas curtcustomer susanshopper'))) \drupal_set_message('Link: ' . "<a href='http://localhost" . DEV_ROOT . "/reset/id=$name&code=$pass'>reset</a>");
  /**/ if (isDEV or (!isPRODUCTION and time() - db\lookup('created', 'users', 'name=:name', compact('name')) < HOUR_SECS)) \drupal_set_message('Link: ' . "<a href='http://localhost" . DEV_ROOT . "/reset/id=$name&code=$pass'>reset</a>");
  /// if (isDEV) \drupal_set_message('Link: ' . "<a href='http://localhost" . DEV_ROOT . "/reset/id=$name&code=$pass'>reset</a>");
    $expires = r\rTime() + HOUR_SECS * R_SIGNIN_HOURS;
  //  r\setCook('loginto', $name, $expires);
    $a->update('oneTimePass', compact('pass', 'expires'));
    return $pass;
  } 

  /**
   * Say whether the password is acceptable.
   * @param string $password: the password supplied by the user
   * @param string $passFieldName: password field name (none if using only oneTimePass)
   * @param string $err: (RETURNED) the error message, if any
   * @return <password is good>
   */
  function passwordOkay($password, $passFieldName = '', &$err = '') {
    $a = $this;
    if (@$a->oneTimePass) {
      extract(u\just('pass expires', $a->oneTimePass));
      if ($password == @$pass) return ($a->admin or r\rTime() < @$expires) ?: !($err = 'pass expired');
    }

    require_once DRUPAL_ROOT . '/includes/password.inc';
    $hash = \_password_crypt('sha512', $password, $a->$passFieldName);
    return ($hash and $a->$passFieldName == $hash) ?: (!$err = 'bad login');
  }
  
  public function stepsRemaining() {
    $a = $this;
    $steps = $a->stepsDone ?: [];
    $dones = array_sum($steps);
    return count($steps) - $dones;
  }
  
  /**
   * Return the Community Admin's account ID.
   */
  function cAdminUid() {
    return db\lookup('uid', 'users', 'community=:ctty AND :IS_CADMIN', ray('ctty', $this->community));
  }
  
  /**
   * Return the community admin's contact info.
   */
  function cAdminContact() {
    if (!$id = $this->cAdminUid()) return t('(no Community Admin)');
    $a = r\acct($id);
    return "$a->fullName - $a->email";
  }
  
  /**
   * Return an assoc of individual (or joint) account statistics.
   * @return [returnMo, return, cttyBeneMo, cttyBene]
   */
  public function j_stats() {
    $a = $this;
    $stats = ($stats = $a->stats) ? unserialize($stats) : [];

    if ($jid = $a->jid) {
      $j = r\acct($jid);
      $jstats = ($jstats = $j->stats) ? unserialize($jstats) : [];
      foreach ($stats as $k => $v) {
        $jv = $jstats[$k];
        $stats[$k] = u\abbreviates('avg', $k) ? ($v + $jv) / 2 : ($v + $jv);
      }
      $created = round(($a->created + $j->created) / 2);
    } else $created = $a->created;
    
    extract($stats);
    $years = round((strtotime('today') - strtotime('today', $created)) / DAY_SECS) * DAY_SECS / YEAR_SECS;
    // rounding is to assure consistency for tests, despite daylight savings time changes
    $returnMo = @$avgBalPastMo > 0 ? 
        number_format(100 * 12 * (@$benePastMo + @$extraPastMo) / $avgBalPastMo, 1)
      : (@$benePastMo + @$extraPastMo > 0 ? '&infin;' : number_format(100 * R_INFLATION_RATE, 1));
    $return = ($years > 0 and @$avgBalEver > 0) ? 
        number_format(100 * (@$beneEver + @$extraEver) / $avgBalEver / $years, 1)
      : (@$beneEver + @$extraEver > 0 ? '&infin;' : number_format(100 * R_INFLATION_RATE, 1));
    $cttyBeneMo = u\fmtAmt(@$giftsPastMo + max(0, @$bankedPastMo) + @$benePastMo * (1 + R_CC_RATE / $a->rebate));
    $cttyBene = u\fmtAmt(@$giftsEver + max(0, @$bankedEver) + @$beneEver * (1 + R_CC_RATE / $a->rebate) + r\cttyPaidEver($a->community) / (@$pAccts ?: 1));
/// debug(compact(ray('years returnMo extraPastMo benePastMo avgBalPastMo avgBalEver extraEver cttyBeneMo giftsPastMo bankedPastMo benePastMo cttyBeneMo giftsEver bankedEver beneEver')));
    return compact(ray('returnMo return cttyBeneMo cttyBene'));
  }

  /**
   * Return the rough business structure of a company, as required by Dwolla.
   */
  function businessStructure() {
    u\EXPECT($this->co, 'not a company');
    return $this->coCan(CO_CORPORATION) ? 'Corporation' : ($this->coCan(CO_PARTNERSHIP) ? 'Partnership' : 'SoleProprietorship');
  }
   
  /**
   * Return an SMS number for the account.
   * @return: the number or null if none
   */
  public function smsNumber() {  
    $id = $this->id;
    return db\lookup('code', 'r_boxes', "uid=:id AND code REGEX '+[:digit:]{7,15}'", compact('id')); // was status=:SMS_PRIMARY
  }

  /**
   * Request a transfer of funds to or from a connected bank account.
   * @param numeric $amount0: the amount to transfer TO or (if negative) FROM the bank
   * @param int $completed: (also RETURNED) the completion date
   * @param assoc $tx: forced field values, if any
   * @return the transaction number (FALSE if failure)
   */
  public function bank($amount0, &$completed = '', $tx = []) {
    global $channel;
    $a = $this;
    $payer = $a->id;
    $bankAccount = @$a->secure['bankAccount']; // already-encrypted bank account (@ is for testing)
    if ($tx) extract($tx);
    u\setDft($tid, r\getUsdTid($payer));
    u\setDft($created, r\rTime());
    if (!$completed) $completed = ($amount0 > 0 or -$amount0 <= -$a->floor) ? $created : 0;

    $DBTX = \db_transaction();
    $where = 'payer=:payer AND NOT deposit AND amount' . ($amount0 < 0 ? '<0 AND NOT completed' : '>0');
    if ($res = db\lookup('txid,amount', 'r_usd', $where, compact('payer'))) { // found another the same direction
      extract($res);
      $amount += $amount0;
      db\update('r_usd', compact(ray('txid amount completed bankAccount')), 'txid');
    } else {
      $amount = $amount0;
      if (isGAME) $tx += ['members' => $a->members];
      $txid = db\insert('r_usd', $tx += compact(ray('amount payer created completed tid bankAccount channel')));
      u\EXPECT((bool) $txid, 'saving usd record');
    }

    if ($amount0 > 0) { // tell staff to transfer the funds using BillPay or check
      $a->update('r', $a->o_r - $amount0);
      if ($txid > 0) r\tellAdmin(t('outgoing bank transfer request'), ['amount' => $amount0]);
    } elseif ($completed) $a->completeUsdTx(0, -$amount0, TRUE);

    unset($DBTX);
    return $txid;
  }

  /**
   * Mark an incoming USD transfer complete, update cache, and report.
   * @param int $txid: the transfer record ID (if empty, no need to mark it complete)
   * @param numeric $amount: transfer amount (positive)
   * @param bool $automatic: <transfer was created automatically>
   * @return <success>
   */
  public function completeUsdTx($txid, $amount, $automatic) {
    $a = $this;
    
    $DBTX = \db_transaction();

    if ($txid) { // unless transfer is already marked complete
      $realAmt = db\lookup('-amount', 'r_usd', 'txid=:txid', compact('txid'));
      if ($amount != $realAmt) r\tellAdmin('bad completeUsdTx amt in acct', compact(ray('txid amount realAmt automatic')));
      if (!db\update('r_usd', ['txid'=>$txid, 'completed'=>r\rTime()], 'txid')) return FALSE;
    }
    
    $a->update('r', $a->o_r + $amount);
    unset($DBTX);
    
    $transfer = $automatic ? t('automatic transfer') : t('transfer');
    $amount = u\fmtAmt($amount);
    r\notify($a->id, 'transfer complete', compact('transfer', 'amount'));
    if (!$a->can(B_BONA)) r\message($a->id, 'account funded');
    return TRUE;
  }

  /**
   * Return a link to a "no signin required" action.
   * Omit $life only for a forever link not specific to a particular account
   * @param string $op: what to do (REQUIRED)
   * @param numeric $v: an amount or identifier
   * @param int $life: number of seconds until link expires (link gets invalidated after doing operation once)
   * @param assoc $info: other parameters (sql, subs, etc.)
   * @return <a> tag guts for a clickable link that will do something without requiring the member to sign in
   *    makeDo0 returns just the url (for form action, for example)
   * @see also r\Web\rdo()
   */
  function makeDo0($op, $v = NULL, $life = WEEK7_SECS, $info = []) {
  //  extract($data = rayy(func_get_args()) ?: $data);
    extract($info);
    $info += compact('op');
    if (!is_null($v)) $info += compact('v');
    
    if (@$life) {
      $data = ray('uid expires data', $this->id, r\rTime() + $life, serialize($info));
      $info = ray('op', db\insert('r_do', $data)); // (preliminary) op is r_do record ID
    } else $info += ['mo'=>rdoMonth()]; // remember month, in case we need to know when link was created

    return BASE_URL . "/do/" . r\makeDoCode($info);
  }
  function makeDo($op, $v = NULL, $life = WEEK7_SECS, $info = []) {
    return 'a href="' . $this->makeDo0($op, $v, $life, $info) . '"';
  }
  
  /**
   * Set the bit in the given integer bit collection field to the given value.
   * If the requested bit is too high, "2" (or more) gets appended to the collection name
   * @param int $bit: number of bit to set (0 - 30)
   * @param bool $on: whether to set it ON or OFF
   * @return <successful>
   */
  public function setBitx($bit, $on = TRUE, $field = 'flags') {
    if ($bit > B_MAX) $field .= 1 + floor($bit / (B_MAX + 1));
    $n = $this->$field;
    u\setBit($n, $bit, $on);
    return $this->update($field, $n);
  }

  /**
   * Set the bit (identified by number or name) in the "risks" integer bit collection field.
   * @param mixed $bit: number of bit to set (0 - 31) or name of bit
   * @param bool $on: whether to set it ON or OFF
   */
  public function setRisk($bit, $on = TRUE) {$this->setBitx($this::riskBit($bit), $on, 'risks');}
    
  public function risk($bit) {return u\getBit($this->risks, $this::riskBit($bit));}
  
  /**
   * Return the bit number for risk bit name.
   * @param mixed $bit: the bit name or number
   * @return the bit number
   */
  private static function riskBit($bit) {
    if (is_numeric($bitName = $bit)) return $bit;
    $acctRiskBits = array_flip(array_keys(ray(K_ACCT_RISKS)));
    $txRiskBits = array_flip(array_keys(ray(K_TX_RISKS)));
    return is_numeric($bit = @$acctRiskBits[$bitName]) ? $bit : $txRiskBits[$bitName];
  }
  
//  private static function flagBit($bit) {return is_numeric($bit) ? $bit : u\consta('b', $bit);}
  public function coCan($bit = NULL) {return u\getBit($bit <= B_MAX ? $this->coFlags : $this->coFlags2, $bit);}
  public function setCoBit($bit, $on = TRUE) {$this->setBitx($bit, $on, 'coFlags');}
  
  public function setCoCans($can) {
    $coFlags = $this->coFlags;
    for ($i = 0; $i < 2 * APP_CAN_BITS; $i++) {
      $bit = u\bit(APP_CANS + $i);
      $coFlags = isset($can[$i]) ? ($coFlags | $bit) : ($coFlags & ~$bit);
    }
    $this->update(compact('coFlags'));
  }

  /**
   * Set all account risk bits at once (called from formSummary for community admins)
   * @param array $values: numeric array of bit values (eg [3 => 3, 5 => 5])
   */
  public function setRisks($values) {
    $risks = 0;
    if ($values) foreach ($values as $bit) u\setBit($risks, $bit);
    $this->update(compact('risks'));
  }
  
  /**
   * Set all appropriate bits in the flags field (called from formSummary for community admins)
   * @param array $values: numeric array of bit values (eg [3 => 3, 5 => 5])
   */
  public function setBits($values) {
    u\setDft($values, []); // fails in arg list (dunno why)
    $flags = $this->flags;
    foreach (ray(B_ADMINABLE) as $bitName) { // set all these on or off
//      if (substr($bitName, 0, 1) == 'u') continue; // lowercase u means undefined
      $bit = u\consta('b', $bitName);
      $on = isset($values[$bit]); // isset because bit 0 is 0 when checked
      u\setBit($flags, $bit, $on);
    }
    $this->update(compact('flags'));
  }  

  /**
   * Say whether another active account has the same address
   */
  public function dupAddr() {
    $a = $this;
    if (!$address = $a->address) return FALSE;
    $q = db\q('SELECT uid FROM users WHERE :IS_OK AND uid<>:id AND postalCode=:postalCode', ray('id postalCode', $a->id, $a->postalCode));
    while ($row = $q->fetchAssoc()) if (r\acct($row['uid'])->address = $address) return TRUE;
    return FALSE;      
  }

  /**
   * Change the account's community.
   * @param int $newCtty: the new community uid
   * @param bool $retro: <change rewards transactions retroactively>
   * @param string $err: (RETURNED) the error message, if any
   * @return <success>
   */   
  public function changeCtty($newCtty, $retro = FALSE, &$err = '') {
    $a = $this;
    if (!db\exists('users', 'uid<1 AND uid=:newCtty', compact('newCtty'))) return !$err = 'bad ctty';
    
    $DBTX = \db_transaction();
    $a->update('community', $newCtty);
    if ($retro) db\q('UPDATE r_txs SET payer=:newCtty WHERE payee=:myid AND type IN (:TX_REWARDS)', ray('newCtty myid', $newCtty, $a->id));
    unset($DBTX);
    return TRUE;
  }
  
  /**
   * Say whether this settings/agent has the permission.
   * @param int $bit: the permission in question (DEFAULT B_READ)
   */
  public function can($bit = B_READ) {
    $a = $this;
    if ($bit <= B_MAX) { // ordinary bits
      $can = (bool) ($a->flags & (1 << $bit)); // these are easy. be efficient.
      if (in_array($bit, [B_REGULATOR, B_CADMIN2, B_CADMIN, B_ADMIN])) {
        if (!$a->proSe) return ($aa = $a->agentA and $aa->can($bit)); // admin permissions are for agent instead
        if (!$can and $bit < (R_ADMIN_CAN_MANAGE_CTTYS ? B_ADMIN : B_CADMIN)) return $a->can($bit + 1); // not this admin bit, maybe the next higher?
      }
      return $can;
    }

    if ($bit == B_CTTYUP) return $a->cttyA->up;

    if ($bit == B_BANK) return $a->hasBank; // might get set after getCan() is called
    $can = @self::$perms[$a->id][$a->agentId] ?: $a->getCan();
    return $can[$bit];
  }

  /**
   * Set up permissions (::$perms) if we haven't yet
   * @return the permissions array for this account
   */
  private function getCan() {
    $a = $this;
    $id = $a->id;
    
    // collect efficient bits, for reference within this function
    for ($bit = 0; $bit <= B_MAX; $bit++) $can[$bit] = $a->can($bit);
    foreach ([B_REGULATOR, B_CADMIN2, B_CADMIN, B_ADMIN] as $bit) $can[$bit] = $a->agentA->can($bit);
 
    $can[B_PERSON] = !$can[B_CO];

    $perm = $a->closed ? B_READ
      : ($a->proSe ? B_MANAGE
      : (($can[B_CADMIN] and $a->community == $a->agentA->community) ? B_MANAGE 
      : (B_RELATED + relation('permission', $id, $a->agentId))));
    for ($i = B_RELATED; $i <= B_MANAGE; $i++) $can[$i] = ($i <= $perm); // set all, even the false ones

    // (NO! this should never happen) if ($can[B_OK]) $can[B_MEMBER] = TRUE;
    if (!$can[B_OK]) $can[B_SELL] = $can[B_BUY] = FALSE; // (read here kills acct dropdown)

    if (!$can[B_MEMBER]) $can[B_BUY] = FALSE; // no spending even the SIGNUP GIFT for non-members
    
    if ($can[B_ADMIN] and R_ADMIN_CAN_MANAGE_CTTYS) { // temporary extra power, until communities are independent
      $can[B_READ] = $can[B_SCAN] = $can[B_SELL] = $can[B_BUY] = $can[B_MANAGE] = TRUE;
    }
    $can[B_DEV] = (isDEV or $can[B_ADMIN]); // used in menu system for tests page, etc.
    if ($can[B_MANAGING_CTTY] = ($can[B_CADMIN] and $id == $a->community)) $can[B_BUY] = TRUE;
    
    ksort($can); // easier to debug
    return self::$perms[$id][$a->agentId] = $can;
  }

  public function isMe($uid) {return ($uid == $this->id or $uid == $this->jid);}
  public function codeHash() {return u\hash($this->cardCode());}
  public function o($k) {return $this->{'o_' . $k};}
  
} // end of class

/**
 * Return an account object for the described account.
 * call by:
 *   r\acct()       (returns current account)
 *   r\acct($uid)
 *   r\acct($main, $agent)
 *   r\acct($main, $agent, $error)
 *   r\acct($email)
 * @param int $uid: account uid
 * @param int $main: main account uid
 * @param int $agent: agent uid
 * @param string $email: email address for the account
 * @param string $error: error message, if any
 * @return the appropriate account object (FALSE if none)
 */
function acct($uid = '', $agent = '', &$error = '') {
  global $currentAcct; // use this ONLY in this class file
  if (!$uid) return $currentAcct ?: (!$error = 'There is no current account.');
  if (strpos($uid, '@')) $uid = db\lookup('uid', 'users', 'mail=:mail', ['mail' => u\cryptN($uid)]);
//  if (!$ua = r\Acct::viable($uid, $agent, $error, TRUE)) return FALSE;
  if (!$ua = r\Acct::viable($uid, $agent, $error, TRUE)) return FALSE;
  return new r\Acct($ua); // the only place we call new r\Acct() with a flat array (meaning an existing account)
}

/**
 * Return an account object for the agent of the given account.
 */
function agent($uid = '') {return @r\acct($uid)->agentA;}
