<?php
namespace rCredits;
use rCredits as r;
use rCredits\Util as u;

/**
 * @file
 * rCredits USD (official currency) account class
 *
 * This class has no awareness of the Drupal database
 */

require_once __DIR__ . '/../dwolla/dwolla.php';
define ('R_USD_NOTE_PREFIX', 'rC: '); // prefix USD transaction notes so we know they are ours

class usd {
  var $acct; // the associated rCredits account
  var $type; // what type of official currency account (for example Dwolla, Ripple, or Bank)
  var $number; // the USD account number
  var $pin; // PIN for that account
  var $auth; // authorization token
  private static $atoms = array();

  /**
   * Get a dwolla object. Set the auth token, if appropriate.
   * @param string $redirectUri: where to redirect on request for auth token OR
   *   an arbitrary string meaning "don't set the token"
   * @return: a dwolla object (usually received into $dw)
   */
  private function dwolla($redirectUri = FALSE) {
    $dw = new \DwollaRestClient(DWOLLA_API_KEY, DWOLLA_API_SECRET, $redirectUri);
    if (!$redirectUri) $dw->setToken($this->acct->secure['auth']);
    return $dw;
  }
  
  /**
   * Instantiate (and return) a new USD account object
   * @param acct $acct: the rCredits account that has this USD account
   */
  function __construct($acct) {
    $this->acct = $acct;
    foreach ($acct->secure as $key => $value) if (property_exists($this, $key)) $this->$key = $value;
    $this->number = $acct->usd_account;
  }
  
  /**
   * Handle updated usd information by requesting a new auth token from Dwolla
   * @return: does not return, but initiates callback to receive auth token
   */
  public function update() {
    global $base_url;
    $dw = $this->dwolla("$base_url/usd-callback/" . $this->acct->id); // tell Dwolla where to wake us up
	  header('Location: ' . $dw->getAuthUrl()); // request an auth token
    exit();
  }    

  /**
   * Return the account balance or its sufficiency
   * Call by:
   *   $usd->bal() - return the amount currently in the account
   * UNUSED  $usd->bal($want) - return FALSE=no/TRUE=yes/'?'=maybe (meaning there is a connected bank account)
   * UNUSED @param float $want: can the account give up this much money in a hypothetical immediate transaction?
   * UNUSED @param string $error: (RETURNED) an error message on failure
   * @return: balance or sufficiency (FALSE if failure)
   */
  function bal($want = NULL, &$error = NULL) {
    $dw = $this->dwolla();
    return $dw->balance();
  }

  /**
   * Transfer funds from this account to another.
   * @param float $amount: the amount to transfer
   * @param usd $other: the other account
   * @param string $notes: description of transaction (to be prefixed with "r: "), limited to 250-4 characters
   * @param bool $payerFee: the payer pays the transaction fee (if any) -- otherwise (default) the payee pays it
   * $param bool $direct: the funds must already be in the Dwolla account (no 3-day delay)
   * @param string $error: (RETURNED) an error message on failure
   * @return:
   *   success: transaction ID string
   *   fail: FALSE
   *   maybe: '?'
   * NOTE: this function should write the transaction id, amount, payer, and payee to r_usd BEFORE doing the Dwolla transfer
   */
  function transfer($amount, $other, $notes, $payerFee = FALSE, $direct = TRUE, &$error = NULL) {
    $source = $direct ? 'Dwolla' : 'ERROR'; // no delayed payments at present
    $notes = R_USD_NOTE_PREFIX . $notes;
    $dw = $this->dwolla();
    $txid = $dw->send($this->pin, $other->number, $amount, $source, $notes, 0, $payerFee);
    if (!$txid) return FALSE;
    
    $created = time();
    $payer = $this->acct->id;
    $payee = $other->acct->id;
    self::addToAtom(compact(u\ray('txid amount payer payee created')));
    debug("Transferring USD $amount from $payer to $payee.");
    return $txid;
  }
  
  /**
   * Handle callbacks from the USD institution
   * The calling institution is expected to be explicit in the callback info.
   * Used at present only for getting the auth token from Dwolla.
   * @param int $uid: the account id of the rCredits account for which we are getting a callback
   */
  public static function callback($uid) {
    global $base_url;
    $uri = "$base_url/account/usd/connected=";
    if(@$_GET['error']) return r\go($uri . $_GET['error_description']);

    $dw = $this->dwolla('no token yet');
    if (!$token = $dw->requestToken(@$_GET['code'])) return r\go($uri . $dw->getError());

    //session_start(); $_SESSION['token'] = $token;
    $acct = r\acct($uid);
    $secure = $acct->secure;
    $secure['auth'] = $token;
    $acct->update(compact('secure'));
    return r\go($uri . TRUE); // tell user we were successful
  }

  /**
   * Transfer funds from a Dwolla account to the connected bank account or vice versa.
   * @param float $amount: the amount to transfer to the bank (from the bank, if negative)
   */
  function bank($amount) {
    $dw = $this->dwolla();
    $sources = $dw->fundingSources();
    $function = $amount < 0 ? 'withdraw' : 'deposit';
    debug("Transferring USD $amount from $this->acct->id's Dwolla account to the bank.");
    return $dw->$function($sources['WHAT GOES HERE?'], $this->pin, abs($amount));
  }

  /**
   * Call the callback for each transaction OUT of the account after a given date/time (defaults to day 1 of the Unix Epoch).
   * Passes to the callback function an assoc with complete transaction details, including transaction id
   */
  function each($callback, $start = 0) {
    $dw = $this->dwolla();
    $skip = 0;
    $atATime = 50;
    while ($listings = $dw->listings(strftime('%m-%d-%Y', $start), 'money_sent', $atATime, $skip)) {
      foreach ($listings as $txid) {
        $details = transaction($txid);
        $details['txid'] = $txid;
        if (u\abbreviates(R_USD_NOTE_PREFIX, $one['notes'])) $callback($details);
      }
      $skip += $atATime;
    }   
  }

// Atomic Data Transaction Handling for mixed rCredits/USD financial transactions
// Strategy: Allow inconsistent USD transfers for up to 24 hours after system failure.
// Record committed USD transactions in the r_usd table. 
// A compensating transaction is created at the end of the day, 
//    for any recent USD transfer that does not appear in that table.
// $atoms is a list of transaction IDs waiting to be committed. 
// A Drupal transaction object entry marks the start of a new nested level.
// For example, [$DBTX1, a, b, $DBTX2, c, d, e] has 2 transactions at the top level and 3 nested.
// commit() and rollback() must always be called explicitly, barring a system crash (don't just return to the caller)
  
  /**
   * Mark the beginning of a mixed USD/rCredits (possibly nested) database transaction.
   */
  public static function beginAtom() {
    return self::$atoms[] = \db_transaction();
  }
  
  private static function addToAtom($txid) {
    self::$atoms[] = $txid; // remember transaction to commit or rollback
  }

  public static function commit() {
    $values = '';
    while (!is_object($one = array_shift($atoms))) {
      extract(u\just('txid amount payer payee created', $one));
      $values .= ($values ? ',' : '') . "($txid, $amount $payer $payee $created)";
    }
    r\dbQ("INSERT INTO r_usd (txid, amount, payer, payee, created) VALUES $values");
    // Drupal automatically commits if we don't rollback
  }
  
  /**
   * Rollback a list of transactions
   * If no $list is specified, rollback the most recent atom.
   * @param array $list: array of assocs of USD transaction details (defaults to most recent atom)
   * $list is specified when recovering from system failure during the daily (nightly) consistency checks
   */
  public static function rollback($list = array()) {
    if (!$list) {
      while (!is_object($one = array_shift(self::$atoms))) $list[] = $one;
      $one->rollback(); // got Drupal transaction object last (and removed it from list)
    }
    $fields = 'txid amount payer payee created';
    
    foreach ($list as $one) { // create a compensating usd transaction for each transaction in $list
      extract(u\just($fields, $one));
      $usdAcct1 = new usd(r\acct($payer));
      $usdAcct2 = new usd(r\acct($payee));
  
      self::beginAtom();
      $notes = R_USD_NOTE_PREFIX . 'reversing transaction #' . $one['transactionID'];
      $dw = $usdAcct1->dwolla();
      extract(u\just('WHAT ARE THESE FIELDS?', $dw->transaction($txid)));
      $dw = $usdAcct2->dwolla();
      // payerFee should be the opposite of 
      if (!$txid = $dw->send($usdAcct2->pin, $usdAcct1->number, $amount, 'Dwolla', $notes, 0, $payerFee) {
        // failure (probably insufficient Dwolla balance). transfer amount in r, from payee to payer
        // if ($amount > 10) reimburse the original 25 cents, in r
        $one['created'] = REQUEST_TIME; // sync with the r transfer
        self::addToAtom($one);
      } else {
        $one['amount'] = $one['payer'] = $one['payee'] = 0; // all irrelevant (just the txids matter)
        self::addToAtom($one);
        list ($amount, $payer, $payee, $created) = array(0, $payee, $payer, time());
        self::addToAtom(compact(u\ray($fields)));
        // if ($amount > 10) reimburse both 25 centses in r
      }
      self::commit();
    }
  }
  
} // end of class
