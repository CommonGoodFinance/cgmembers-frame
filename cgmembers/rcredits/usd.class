<?php
namespace rCredits;
use rCredits as r;
use rCredits\DB as db;
use rCredits\Util as u;
use rCredits\Testing as t;

/**
 * @file
 * rCredits USD (official currency) account class
 *
 * Note that if Dwolla is not reachable: bal(), bank(), and send() have a fallback.
 */

require_once __DIR__ . '/../dwolla/dwolla.php';
require_once __DIR__ . '/rcredits-testing.inc'; // required during cron

define('USD_NOTE_PREFIX', 'rC: '); // prefix USD tx notes so we know they're ours (preceded by "1" when testing)

class usd {
  var $acct; // the associated rCredits account
  var $type; // what type of official currency account (for example Dwolla, Ripple, or Bank)
  var $number; // the USD account number
  var $pin; // PIN for that account
  var $auth; // authorization token
  private static $atoms = array();

  /**
   * Get a dwolla object. Set the auth token, if appropriate.
   * @param bool $setToken: whether to set the auth token
   * @param string $redirectUri: where Dwolla should return to
   * @return: a dwolla object (usually received into $dw)
   */
  private function dwolla($setToken = TRUE, $redirectUri = 'usd-callback') {
    global $base_url;
    $redirectUri = "$base_url/$redirectUri/" . $this->acct->id;
    $dw = new \DwollaRestClient(DW_API_KEY, DW_API_SECRET, $redirectUri);
    if ($setToken) $dw->setToken(@$this->acct->secure['auth']);
    return $dw;
  }

  public static function format($n) {return preg_replace('/(\d{3})(\d{3})(\d{4})/', '$1-$2-$3', $n);}
  
  /**
   * Instantiate (and return) a new USD account object
   * @param acct $acct: the rCredits account that has this USD account
   */
  function __construct($acct) {
    $this->acct = $acct;
    $this->number = $acct->usdAccount; // may be empty
    $secure = $acct->secure;
    foreach (u\ray('type auth') as $one) $this->$one = @$secure[$one];
    $this->pin = @$secure['usdPin'] ?: @$secure['pin'];
  } 
  
  /**
   * Open a dwolla account
   * @param string $err: (returned) error message if any
   * @return: does not return, but initiates callback to receive auth token
   */
  public function register($type, $info, $acceptTerms = FALSE, &$err = '') {
    $dw = $this->dwolla(FALSE, R_GET_AUTH_URI);
    extract(u\just('usdPass usdEmail usdPin', $this->acct->secure));
    extract(u\just($type == 'Personal' ? 'first last dob' : 'org ein', $info));
    if (@$dob) $dob = date('m-d-Y', $dob);
    $result = $dw->register2($usdEmail, $usdPass, $usdPin, @$first, @$last, @$dob, $type, @$org, @$ein, $acceptTerms);
//    debug($result);
    if (!$auth = @$result['OAuthToken']) return dwError($dw, $err); // set error message, if any
    $secure = compact('auth') + $this->acct->secure;
    $this->acct->update(compact('secure'));
    list ($this->type, $this->pin, $this->auth) = array('Dwolla', $usdPin, $auth); // must precede me()
    $dw->me(); // set usdAccount and $this->number

    return TRUE; // report success
  }    

  /**
   * Return basic account information and set usdAccount.
   * @return an assoc of basic info. On error, return FALSE and set $err.
   */
  public function me(&$err = '') {
    $dw = $this->dwolla();
    if (!$me = $dw->me()) return dwError($dw, $err);
    $this->number = $usdAccount = str_replace('-', '', $me['Id']); // regardless of whether it already has a #
    if ($other = r\whoseUsd($usdAccount, $this->acct->id)) return dwError(u\tt('usd account taken', compact('other')), $err); // should probably be u\EXPECT() soon?
    $this->acct->update(compact('usdAccount'));

    return $me;
  }
  
  function step(&$err = '') {
    $dw = $this->dwolla();
    if (!$step = $dw->step()) return dwError($dw, $err);
    return $step;
  }

  function resendEmail(&$err = '') {
    $dw = $this->dwolla();
    if (!$dw->resendEmail()) return dwError($dw, $err);
    return TRUE;
  }
  
  /**
   * Add primary phone.
   * @param string $phone: primary phone number (no punctuation)
   * @param string $verificationMethod: SMS or Voice
   * @param string $err: (returned) the error message, if any
   * @return string $phoneId or FALSE
   */
  function addPhone($phone, $verificationMethod, &$err = '') {
    $dw = $this->dwolla();
    if (!$phoneId = $dw->addPhone($phone, $verificationMethod)) return dwError($dw, $err);
    return $phoneId;
  }

  /**
   * Resend phone verification code.
   * @param string $phoneId: phone identifier
   * @param string $err: (returned) the error message, if any
   * @return TRUE if success
   */
  function reAddPhone($phoneId, &$err = '') {
    $dw = $this->dwolla();
    if (!$dw->reAddPhone($phoneId)) return dwError($dw, $err);
    return TRUE;
  }
  
  /**
   * Verify primary phone.
   * @param string $phoneId: phone identifier
   * @param integer $code: 5-digit verification code (sent earlier to phone by SMS or voice)
   * @param string $err: (returned) the error message, if any
   * @return TRUE if success
   */
  function verifyPhone($phoneId, $code, &$err = '') {
    $dw = $this->dwolla();
    if (!$dw->verifyPhone($phoneId, $code)) return dwError($dw, $err);
    return TRUE;
  }

  /**
   * Specify user's address.
   * @param string $address: Line one of user address. Precise data & format critical to geo-location data.
   * @param string $city: User's City.
   * @param string $state: USA state or territory two character code (2 Char Abbrv)
   * @param string $zip: Postal code or zip code.
   * @param string $err: (returned) the error message, if any
   * @return TRUE if success
   */
  function address($address, $city, $state, $zip, &$err = '') {
    $dw = $this->dwolla();
    if (!$dw->address($address, $city, $state, $zip)) return dwError($dw, $err);
    return TRUE;
  }

  /**
   * Verify the user's social security number.
   * @param string $ssn: the user's social security number
   * @param string $err: (returned) the error message, if any
   * @return TRUE if success, else FALSE (in which case next step is normally "AccountInfo")
   */
  function ssn($ssn, &$err = '') {
    $dw = $this->dwolla();
    if (!$dw->ssn($ssn)) return dwError($dw, $err);
    return TRUE;
  }

  /**
   * Submit corrected personal information (because SSN could not be verified by ssn())
   * @param string $structure: "Personal", "NonProfit", or "Commercial"
   * @param string $dob: person's birth date (empty for companies)
   * @param string $ein: organization's Employer Id Number (empty for individuals)
   * @param string $first: person's first name (empty for companies)
   * @param string $last: person's last name (empty for companies)
   * @param string $org: organization name (empty for individuals)
   * @param string $err: (returned) the error message, if any
   * @return TRUE if success, else FALSE (in which case next step is normally "Kba")
   */
  function accountInfo($structure, $dob = '', $ein = '', $first = '', $last = '', $org = '', &$err = '') {
    $dw = $this->dwolla();
    if ($dob) $dob = date('m-d-Y', $dob);
    if (!$dw->accountInfo($structure, @$dob, @$ein, @$first, @$last, @$org)) return dwError($dw, $err);
    return TRUE;
  }
  
  /**
   * Get KBA verification questions for the user.
   * @param array $questions: (returned) simple array of [Id, Text, Choices]
   *   where Choices is array of [answer id => answer text]
   * @param string $err: (returned) the error message, if any
   * @return transactionId
   */
  function kba(&$questions, &$err = '') {
    $dw = $this->dwolla();
    if (!$kba = $dw->kba()) return dwError($dw, $err);
    $questions = $kba['Questions'];
    return $kba['TransactionId'];
  }

  /**
   * Verify the KBA questions.
   * @param int $transactionId: the ID of the set of questions being answered
   * @param assoc array $answers: [answerid, questionid]
   * @param string $err: (returned) the error message, if any
   * @return TRUE if success
   */
  function verifyKba($transactionId, $answers, &$err = '') {
    $dw = $this->dwolla();
    if (!$dw->verifyKba($transactionId, $answers)) return dwError($dw, $err);
    return TRUE;
  }

  /**
   * Specify an authorized representative for a company account (commercial or nonprofit).
   * @param string $first
   * @param string $last
   * @param string $addr
   * @param string $city
   * @param string $state
   * @param string $zip
   * @param string $phone
   * @param string $dob: the responsible person's date of birth mm-dd-yyyy
   * @param string $ssn: the responsible person's social security number
   * @return TRUE if success
  */
  function authorizedRep($first, $last, $addr, $city, $state, $zip, $phone, $dob, $ssn, &$err = '') {
    $dw = $this->dwolla();
    $dob = date('m-d-Y', $dob);
    if (!$dw->authorizedRep($first, $last, $addr, $city, $state, $zip, $phone, $dob, $ssn)) return dwError($dw, $err);
    return TRUE;
  }
  
  /**
   * Add a funding source.
   */
  function addBank($accountNumber, $routingNumber, $accountType, &$error = NULL) {
    $dw = $this->dwolla();
    $accountName = \user_password(); // random account nickname
    if (!noDw($dw) and !$dw->addFundingSource($accountNumber, $routingNumber, $accountType, $accountName)) return dwError($dw, $error);
    return TRUE;
  }
  
  /**
   * Verify a funding source.
   */
  function verifyBank($fundingSourceId, $deposit1, $deposit2, &$error = NULL) {
    $dw = $this->dwolla();
    if (!noDw($dw) and !$dw->verifyFundingSource($fundingSourceId, $deposit1, $deposit2)) return dwError($dw, $error);
    return TRUE;
  }
    
  /**
   * Handle updated usd information by requesting a new auth token from Dwolla
   * @return: does not return, but initiates callback to receive auth token
   */
  public function getAuth() {
    if (!$dw = $this->dwolla(FALSE, R_GET_AUTH_URI)) return FALSE; // tell Dwolla where to wake us up (getAuth2)
	  header('Location: ' . $dw->getAuthUrl()); // request an auth token
    exit();
  }    

  /**
   * Return here from requesting an auth code, to get the final code.
   * @param int $uid: rCredits account id, passed in return uri
   */
  public static function getAuth2($uid) {
    if (t\est()) unset($_GET['error']);
    if (@$_GET['error']) return authReturn($_GET['error_description']);
//    if ($uid != @$mya->id) return authReturn(u\tt('wrong user'));
    $usdAcct = new usd($mya = r\acct($uid));
    $dw = $usdAcct->dwolla(FALSE, R_GET_AUTH_URI); // URI must match the one in getAuth
    if (t\est()) $authToken = \user_password(); else
    if (!$authToken = $dw->requestToken(@$_GET['code'])) return authReturn($dw);
//  die("uid=$uid code=" . $_GET['code'] . $_GET['error']);

    $secure = $mya->secure;
    $secure['auth'] = $authToken;
    $mya->update(compact('secure'));

    $dw = $usdAcct->dwolla(); // this time set token
    if ($me = $dw->me()) $me = (object) $me; else return authReturn($dw); // get dwolla Id, etc.
    
    $usdAccount = str_replace('-', '', $me->Id);
    if ($other = r\whoseUsd($usdAccount, $uid)) return authReturn(u\tt('usd account taken', compact('other')));
//    if ($mya->city != $me->City) r\Web\say('dw mismatch', array('field' => 'City'));
//    if (r\realState($mya->state) != $me->State) r\Web\say('dw mismatch', array('field' => 'State'));
//    if ($mya->co() xor $me->Type != 'Personal') r\Web\say('dw mismatch', array('field' => 'Type'));
    if ($me->Type == 'Non-profit' and $mya->co()) $coFlags = $mya->coFlags | u\bit(CO_NONPROFIT);

    $mya->update(compact('usdAccount', 'coFlags'));
//    print_r(compact('uid','_GET','mya','usdAcct','dw','authToken','secure')); die();
    return authReturn(); // report success
  }
  
  /**
   * Return the account balance or its sufficiency
   * UNUSED  $usd->bal($want) - return FALSE=no/TRUE=yes/'?'=maybe (meaning there is a connected bank account)
   * UNUSED @param float $want: can the account give up this much money in a hypothetical immediate transaction?
   * UNUSED @param string $err: (RETURNED) an error message on failure
   * @return: current balance
   */
  public function bal(&$err = NULL) {
    $dw = $this->dwolla();
    if (t\est() and !in_array($this->number, array(DW_TESTER_ACCT, DW_TEST_ACCT))) return $this->acct->usd + 0;
    if (!noDw($dw)) $result = $dw->balance(); // this may set an error
    return noDw($dw, $err) ? $this->acct->usd + 0 : $result;
  }
  
  /**
   * Transfer funds from this account to another.
   * @param float $amount: the amount to transfer
   * @param usd $other: the other account
   * @param string $notes: description of transaction (to be prefixed with "r: "), limited to 250-4 characters
   * @param string $err: (RETURNED) an error message on failure
   * @param bool $payerFee: the payer pays the transaction fee (if any) -- otherwise (default) the payee pays it
   * $param bool $direct: the funds must already be in the Dwolla account (no 3-day delay) (UNUSED for now)
   * @return:
   *   success: Dwolla transaction ID string OR -1 if Dwolla is down
   *   fail: FALSE
   *   maybe: '?' (UNUSED for now)
   */
  public function send($amount, $other, $notes = R_DEFAULT_PURPOSE, &$err = NULL, $payerFee = FALSE, $direct = TRUE) {
  t\output(t('@id1 (@num1) sending @amt USD to @id2 (@num2)', u\ray('@id1 @num1 @amt @id2 @num2', $this->acct->id, $this->number, u\fmtAmt($amount), $other->acct->id, $other->number)));
    u\EXPECT(self::inAtom(), 'usd transfer outside atom');
    u\EXPECT(is_object($this->acct), 'empty account: ' . print_r($this->acct, 1));
    u\EXPECT(is_object($other->acct), 'empty other account: ' . print_r($other->acct, 1));
    u\EXPECT($this->acct->ok() and $other->acct->ok(), 'non rTraders in usd send');
    if ($this->acct->usd < $amount and $this->bal() < $amount) return dwError('not enough', $err);
    
    $source = $direct ? 'Dwolla' : 'ERROR'; // no delayed payments at present
    $notes = t\est() . USD_NOTE_PREFIX . $notes;
    $dw = $this->dwolla();
    if (t\est() and !($this->number == DW_TEST_ACCT and $other->number == DW_TESTER_ACCT)) {
      return $this->afterTx(t\seq(), $amount, $other);
    } else u\EXPECT(!is_null($this->number) and !is_null($other->number), 'null dw number');
    if ($this->number == $other->number) return dwError(u\tt('no self-trading'), $err); // AFTER t\est() check

    if (!noDw($dw) and $txid = $dw->send($this->pin, self::format($other->number), $amount, $source, $notes, 0, $payerFee)) {
      return $this->afterTx($txid, $amount, $other);
    } else return noDw($dw, $err) ? -1 : NULL;
  }

  /**
   * Set the account's USD balance by transferring funds to/from DW_TESTER_ACCT
   */
  public function setbal($target, &$err = '') {
    //u\EXPECT(t\est(), 'putting back');
    $amount = $target - $this->bal($err); if (@$err) return FALSE;
    if ($amount < 0) {
      $amount = -$amount;
      $dw = $this->dwolla();
      $other = self::format(DW_TESTER_ACCT);
      $result = $dw->send($this->pin, $other, $amount, 'Dwolla', 'setbal down', 0, FALSE) ?: dwError($dw, $err);
    } elseif ($amount > 0) {
      $mainUid = db\lookup('uid', 'users', "mail=':R_TESTER_EMAIL'");
      $a = r\acct($mainUid);
      $us = new r\usd($a);
      if ($amount > DW_FEE_THRESHOLD) $amount += DW_FEE;
      $dw = $us->dwolla();
      $other = self::format($this->number);
      $result = $dw->send($us->pin, $other, $amount, 'Dwolla', 'setbal up', 0, FALSE) ?: dwError($dw, $err);
    } else $result = TRUE;
    if (!@$err) t\output($this->acct->mainQid . ' balance set to ' . ($amount ? $this->bal() : $target), '');
    return (bool) $result;
  }

  /**
   * Queue a task to reimburse the Dwolla fee, if any, and add the tx to the current USD atom.
   * (@todo: maybe reimburse immediately if daily cron has begun)
   * @return the transaction id
   */
  private function afterTx($txid, $amount, $other) {
    list ($payer, $payee) = array($this->acct->id, $other->acct->id);
    self::addToAtom($txid, $amount, $payer, $payee);
    if ($amount > DW_FEE_THRESHOLD) r\queue('coverFee', compact(u\ray('txid payee')));
    return $txid;
  }

  /**
   * Handle callbacks from the USD institution
   * The calling institution is expected to be explicit in the callback info.
   */
  public static function callback() {
  }

  /**
   * Transfer funds from a Dwolla account to the connected bank account or vice versa.
   * @param float $amount: the amount to transfer to the bank (from the bank, if negative)
   * @param string $error: (returned) the error message, if any
   * @return: the transaction ID string (FALSE on failure)
   *
   * result:
array (
  'Id' => 2420668,
  'Amount' => 20,
  'Date' => '3/25/2013 10:23:59 PM',
  'Type' => 'deposit',
  'UserType' => 'Dwolla',
  'DestinationId' => '812-448-6052',
  'DestinationName' => 'William Spademan',
  'SourceId' => 'XXX1990',
  'SourceName' => 'Computer Practitioner',
  'ClearingDate' => '3/29/2013',
  'Status' => 'pending',
  'Notes' => NULL,
  'Fees' => NULL,
)
   */
  public function bank($amount, &$error = NULL) {
    u\EXPECT($amount <> 0, 'bank zero');
    $dw = $this->dwolla();
    if (!t\est())
    if (!($source = $this->source($err)) or !@$source['Id'] or $err) return dwError($err ?: 'no source', $error);
    if (!t\est())
    if (!@$source['Verified']) return dwError('not verified', $error);
    
    $function = $amount < 0 ? 'deposit' : 'withdraw'; // seems backwards (it's from Dwolla perspective)
/// debug("Transferring USD $amount from Dwolla account to the bank for account uid=" . $this->acct->id);
    self::beginAtom();
    if (t\est()) $txid = t\seq(); else
    if (!noDw($dw)) {
      $result = $dw->$function(@$source['Id'], $this->pin, abs($amount));
      if (!$result and !noDw($dw, $error)) { // noDw in case Dwolla went down since two lines above
        self::rollback();
        return NULL;
      } else $txid = @$result['Id'] ?: -1; // -1 for noDw
    } else $txid = -1;
    
    if ($txid != -1) self::addToAtom($txid, $amount, $this->acct->id, 0, 0);
    self::commit();
    if ($amount > 0) $this->acct->actualUsd(-$amount); // treat the money as already gone, if depositing in bank
    return $txid;
  }

  /**
   * Get funding source info
   * @return the source array (FALSE if no connected bank account)
   */
  public function source(&$error = NULL) {
    $dw = $this->dwolla();
    if (!noDw($dw) and !$sources = $dw->fundingSources()) return dwError($dw, $error);
    return $sources[0]['Id'] == 'Balance' ? @$sources[1] : $sources[0];
  }
  
  /**
   * Call the callback for each transaction OUT of the account after a given date/time 
   * @param string $callback: function to call
   * @param int $start: earliest second to consider (defaults to day 1 of the Unix Epoch).
   * @param string $type: what type of transactions to handle 
   *   default: [money_sent,money_received,deposit,withdrawal,fee]
   * @param bool $anybody: UNUSED include all transactions, otherwise only ones marked as originating with us
   * Passes to the callback function an assoc with complete transaction details, including transaction id
   */
  public function each($callback, $start = 0, $type = FALSE) {
    $dw = $this->dwolla();
    $skip = 0; // how many transactions to skip, in call to $dw->listings()
    $atATime = 50; // arbitrary, up to 200 (Dwolla limit)
    while ($listings = $dw->listings(strftime('%m-%d-%Y', $start - DW_LAG), $type, $atATime, $skip)) {
      foreach ($listings as $one) $callback($one);
      // if ($anybody ?: u\abbreviates(t\est() . USD_NOTE_PREFIX, $one['Notes']))
      $skip += $atATime;
    }
  }

  /**
   * Return the net fee on the given transaction.
   * @param string $txid: the payee's transaction id for the transaction about which to inquire
   * @return 0 if the transaction had no fee OR if the fee was reimbursed, '?' if no Dwolla, otherwise DW_FEE
   */
  public function fee($txid) {
    $dw = $this->dwolla();
    if (t\est()) return DW_FEE; // no way to test Dwolla reimbursements yet, but called only if amount>threshold
    if (!$tx = $dw->transaction($txid)) {
      u\EXPECT(noDw($dw), "bad txid: $txid");
      return '?';
    }
    if (!$fees = @$tx['Fees']) return 0; 
    u\EXPECT($fees[0]['Id'] == $txid + 2, 'misnumbered fee'); // $txid+1 is the payer's copy
    u\EXPECT($fees[0]['Amount'] + 0 == DW_FEE, 'wrong fee amount');
    if (!$tx = $dw->transaction($txid + 3)) return DW_FEE; // no reimbursement transaction
    return ($tx['Type'] == 'fee' ? 0 : DW_FEE); // found a reimbursement ? no fee, else return fee amount
  }
  
// Atomic Data Transaction Handling for mixed rCredits/USD financial transactions
// Strategy: Allow inconsistent USD transfers for up to 24 hours after system failure.
// Record committed USD transactions in the r_usd table. 
// A compensating transaction is created at the end of the day, 
//    for any recent USD transfer that does not appear in that table.
// $atoms is a list of transaction IDs waiting to be committed. 
// A Drupal transaction object entry marks the start of a new nested level.
// For example, [$DBTX1, a, b, $DBTX2, c, d, e] has 2 transactions at the top level and 3 nested.
// commit() and rollback() must always be called explicitly, barring a system crash (don't just return to the caller)
  
  /**
   * Mark the beginning of a mixed USD/rCredits (possibly nested) database transaction.
   */
  public static function beginAtom() {return self::$atoms[] = \db_transaction();}
  
  /**
   * Say whether we are currently in an atom.
   */
  public static function inAtom() {return !empty(self::$atoms);}
  
  /**
   * Remember a Dwolla transaction to commit or rollback (passed as individual params or as an assoc)
   * @param int $txid: the Dwolla transaction id
   *     OR assoc $txid: array of all the args for this function
   * @param float $amount: the amount of a Dwolla transaction or bank transfer (negative for a withdrawal)
   * @param int $payer: rCredits account id of the sender
   * @param int $payee: rCredits account id of the other (0 for bank transfers, -1 for fees)
   * @param int $created: (int) creation date/time
   * @param int $completed: completion date/time (default same as created)
   */
  public static function addToAtom($txid, $amount = '', $payer = '', $payee = '', $completed = NULL, $created = REQUEST_TIME) {
    u\EXPECT(self::inAtom(), 'addToAtom outside atom');
    if ($payer) {
      $tid = $payee == 0 ? getUsdTid($payer) : 0; // user sequenced tx number for banking only
      $tx = compact(u\ray('txid tid amount payer payee created completed'));
    } else $tx = $txid;
    if (!isset($tx['completed'])) $tx['completed'] = $created;
    self::$atoms[] = $tx;
  }

  /**
   * Mark the atom complete by writing a record of each USD transaction to the r_usd table.
   * @param bool $success: if TRUE (the default), commit and return TRUE, else rollback and return FALSE
   */
  public static function commit($success = TRUE) {
    if (!$success) {self::rollback(); return FALSE;}
    
    $values = '';
    while (!is_object($one = array_pop(self::$atoms))) {
      extract($one);
      $values .= ($values ? ',' : '') . "('$txid', '$amount', '$payer', '$payee', '$created', '$completed')";
    }
    u\EXPECT(strpos($values, ';') === FALSE, 'sql insertion in usd commit'); // impossible, but verify
    if ($values) db\q("INSERT INTO r_usd (txid, amount, payer, payee, created, completed) VALUES $values");
    // Drupal automatically commits if we don't rollback (otherwise we would do a Drupal commit here)
    return TRUE;
  }
  
  /**
   * Rollback a list of transactions
   * If no $list is specified, rollback the most recent atom.
   * @param array $list: array of assocs of USD transaction details (defaults to most recent atom)
   * $list is specified when recovering from system failure during the daily (nightly) consistency checks
   */
  public static function rollback($list = array()) {
    if (!$list) {
      while (!is_object($one = array_pop(self::$atoms))) $list[] = $one;
      $one->rollback(); // got Drupal transaction object last (and removed it from list)
    }
    
    foreach ($list as $one) { // create a compensating usd transaction for each transaction in $list
      extract($one); // same fields as listed above in addToAtom: txid amount payer payee created completed
      $reverseNote = t('reversed Dwolla transaction #') . $txid;
      $grantNote = t('reimbursement of fee for ') . $reverseNote;

      $usA1 = new usd(r\acct($payer));
      $usA2 = new usd(r\acct($payee));
      if ($feeable = ($amount > DW_FEE_THRESHOLD)) r\queue('coverFee', compact(u\ray('txid payee')));

      $dw = $usA2->dwolla();

      self::beginAtom();
      self::addToAtom($one); // record original transaction
      
      if (!noDw($dw) and $txid = $dw->send($usA2->pin, $usA1->number, $amount, 'Dwolla', $reverseNote)) {
        self::addToAtom($txid, $amount, $payee, $payer);
        if ($feeable) r\queue('coverFee', u\ray('txid payee', $txid, $payer));
      } else { // failure (probably insufficient Dwolla balance) so reverse it in rCredits instead
        $info = u\ray('payer payee amount r for taking', $payee, $payer, 0, $amount, $reverseNote, FALSE);
        r\transact($info);
      }
      self::commit();
    }
  }
  
} // end of class

/**
 * Return TRUE if Dwolla is down
 * @param object $dw: the Dwolla request object or error message
 * @param string $err: the error message to return (set to NULL if no error OR Dwolla is down)
 */
function noDw($dw, &$err = NULL) {
  global $dwollaDown; 
  if (@$dwollaDown) return TRUE; // allows greater efficiency in extended outages
  if (is_object($dw) and u\abbreviates('Request failed. Server responded with:', $err = $dw->getError())) {
    $err = NULL;
    return TRUE;
  } else return FALSE;
}

/**
 * Set error to the Dwolla error, check for unknown errors.
 * @param mixed $dw: the dwolla REST object, an error string, or ''
 * @param string $err: (returned) the error message if any, else ''
 * @return: FALSE if there is an error, else TRUE
 */
function dwError($dw, &$err = '') {
  if (!$err = is_object($dw) ? $dw->getError() : $dw) return TRUE;
  $error = substr($err, 0, 255); // avoid "too long" error
  if (!db\exists('r_usderror', 'error=:error and NOT ok', compact('error'))) {
    $stack = debug_backtrace();
    $op = $stack[1]['function'];
    r\tellStaff('Unprecedented Dwolla error: @err in @op', compact('err', 'op'));
    $created = REQUEST_TIME;
    db\insert('r_usderror', compact(u\ray('error op created')));
  }
  $err = u\tt($err); // get long version, if any
  if (t\est()) t\output('In dwError: ' . $err);
  return FALSE;
}

/**
 * Redirect to the default page, with an error message or 'yes'
 * @param mixed $dw: the dwolla REST object, an error string, or ''
 */
function authReturn($dw = '') {
  dwError($dw, $err);
  return r\go('',  $err);
}
