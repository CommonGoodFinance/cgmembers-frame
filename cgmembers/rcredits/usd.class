<?php
namespace rCredits;
use rCredits as r;
use rCredits\Util as u;
use rCredits\Testing as t;

/**
 * @file
 * rCredits USD (official currency) account class
 *
 * This class has no awareness of the Drupal database
 * @todo? make $dw a usd object var?
 */

require_once __DIR__ . '/../dwolla/dwolla.php';
define('USD_NOTE_PREFIX', 'rC: '); // prefix USD transaction notes so we know they are ours
define('NO_DWOLLA', FALSE or t\EST());

class usd {
  var $acct; // the associated rCredits account
  var $type; // what type of official currency account (for example Dwolla, Ripple, or Bank)
  var $number; // the USD account number
  var $pin; // PIN for that account
  var $auth; // authorization token
  private static $atoms = array();

  /**
   * Get a dwolla object. Set the auth token, if appropriate.
   * @param bool $setToken: whether to set the auth token
   * @param string $redirectUri: where Dwolla should return to
   * @return: a dwolla object (usually received into $dw)
   */
  private function dwolla($setToken = TRUE, $redirectUri = 'usd-callback') {
    global $base_url;
    $redirectUri = "$base_url/$redirectUri/" . $this->acct->id;
    $dw = new \DwollaRestClient(DWOLLA_API_KEY, DWOLLA_API_SECRET, $redirectUri);
    if ($setToken) $dw->setToken(@$this->acct->secure['auth']);
    return $dw;
  }

  public static function format($n) {return preg_replace('/(\d{3})(\d{3})(\d{4})/', '$1-$2-$3', $n);}
  
  /**
   * Set error to the Dwolla error, check for unknown errors, and return FALSE.
   */
  function dwError($dw, &$error) {
    $error = is_object($dw) ? $dw->getError() : $dw;
    if (!r\dbExists('r_usderror', 'error=:error and NOT ok', compact('error'))) {
      $stack = debug_backtrace();
      $op = $stack[1]['function'];
      r\notifyStaff('Unprecedented Dwolla error: @error in @op', compact('error', 'op'));
      $created = REQUEST_TIME;
      r\dbInsert('r_usderror', compact(u\ray('error op created')));
    }
    return FALSE;
  }
  
  /**
   * Instantiate (and return) a new USD account object
   * @param acct $acct: the rCredits account that has this USD account
   */
  function __construct($acct) {
    $this->acct = $acct;
    $this->number = $acct->usdAccount;
    $secure = $acct->secure;
    foreach (u\ray('type pin auth') as $one) $this->$one = @$secure[$one];
  }
  
  /**
   * Handle updated usd information by requesting a new auth token from Dwolla
   * @return: does not return, but initiates callback to receive auth token
   */
  public function getAuth() {
    if (!$dw = $this->dwolla(FALSE, R_GET_AUTH_URI)) return FALSE; // tell Dwolla where to wake us up
	  header('Location: ' . $dw->getAuthUrl()); // request an auth token
    exit();
  }    

    /**
   * Return here from requesting an auth code, to get the final code.
   * @param int $uid: rCredits account id, passed in return uri
   */
  public static function getAuth2($uid) {
    global $base_url;
    $uri = "$base_url/account/usd/connected=";

    if (NO_DWOLLA) unset($_GET['error']);
    if (@$_GET['error']) return r\go($uri . $_GET['error_description']);

    $mya = r\acct();
    if ($uid != @$mya->id) {;
      $this->dwError('wrong user in getAuth2');
      r\go($uri . u\tt('wrong user'));
    }
    $usdAcct = new usd($mya);
    $dw = $usdAcct->dwolla(FALSE, R_GET_AUTH_URI); // URI must match the one in getAuth
    if (NO_DWOLLA) $authToken = \user_password(); else
    if (!$authToken = $dw->requestToken(@$_GET['code'])) return r\go($uri . $dw->getError());

    $secure = $mya->secure;
    $secure['auth'] = $authToken;
    $mya->update(compact('secure'));
//    print_r(compact('uid','base_url','uri','_GET','mya','usdAcct','dw','authToken','secure')); die();
    return r\go($uri . 'yes'); // tell user we were successful
  }
  
  /**
   * Return the account balance or its sufficiency
   * UNUSED  $usd->bal($want) - return FALSE=no/TRUE=yes/'?'=maybe (meaning there is a connected bank account)
   * UNUSED @param float $want: can the account give up this much money in a hypothetical immediate transaction?
   * UNUSED @param string $error: (RETURNED) an error message on failure
   * @return: current balance
   */
  function bal(&$error = NULL) {
    $dw = $this->dwolla();
    if (NO_DWOLLA and !(t\EST() and $this->number == DW_TESTER_ACCOUNT)) return $this->acct->usd;
    $result = $dw->balance();
    $this->dwError($dw, $error); // get error message, if any
    return $result;
  }

  /**
   * Transfer funds from this account to another.
   * @param float $amount: the amount to transfer
   * @param usd $other: the other account
   * @param string $notes: description of transaction (to be prefixed with "r: "), limited to 250-4 characters
   * @param bool $payerFee: the payer pays the transaction fee (if any) -- otherwise (default) the payee pays it
   * $param bool $direct: the funds must already be in the Dwolla account (no 3-day delay) (UNUSED for now)
   * @param string $error: (RETURNED) an error message on failure (UNUSED for now)
   * @return:
   *   success: Dwolla transaction ID string
   *   fail: FALSE
   *   maybe: '?' (UNUSED for now)
   */
  function send($amount, $other, $notes = R_DEFAULT_PURPOSE, $payerFee = FALSE, $direct = TRUE, &$error = NULL) {
    u\EXPECT(self::inAtom(), 'usd transfer outside atom');
    u\EXPECT($this->acct->hasBit(B_OK) and $other->acct->hasBit(B_OK), 'non rTraders in usd send');

    $source = $direct ? 'Dwolla' : 'ERROR'; // no delayed payments at present
    $notes = USD_NOTE_PREFIX . $notes;
    $dw = $this->dwolla();
    if (NO_DWOLLA and !(t\EST() and $this->number == DW_TESTER_ACCOUNT)) return \user_password();
//    if ($txid = $dw->send($this->pin, self::format(DW_TEST_ACCOUNT), $amount, $source, $notes, 0, $payerFee)) {
    if ($txid = $dw->send($this->pin, self::format($other->number), $amount, $source, $notes, 0, $payerFee)) {
      self::addToAtom($txid, $amount, $this->acct->id, $other->acct->id);
      return $txid;
    } else return $this->dwError($dw, $error);
  }
  
  /**
   * Handle callbacks from the USD institution
   * The calling institution is expected to be explicit in the callback info.
   */
  public static function callback() {
  }

  /**
   * Transfer funds from a Dwolla account to the connected bank account or vice versa.
   * @param float $amount: the amount to transfer to the bank (from the bank, if negative)
   * @param string $error: (returned) the error message, if any
   * @return: the transaction ID string (FALSE on failure)
   *
   * result:
array (
  'Id' => 2420668,
  'Amount' => 20,
  'Date' => '3/25/2013 10:23:59 PM',
  'Type' => 'deposit',
  'UserType' => 'Dwolla',
  'DestinationId' => '812-448-6052',
  'DestinationName' => 'William Spademan',
  'SourceId' => 'XXX1990',
  'SourceName' => 'Computer Practitioner',
  'ClearingDate' => '3/29/2013',
  'Status' => 'pending',
  'Notes' => NULL,
  'Fees' => NULL,
)
   */
  function bank($amount, &$error = NULL) {
    $dw = $this->dwolla();
    if (!$sources = $dw->fundingSources()) return $this->dwError($dw, $error);
    $function = $amount < 0 ? 'deposit' : 'withdraw';
    // debug("Transferring USD $amount from Dwolla account to the bank for account uid=" . $this->acct->id);
    self::beginAtom();
    if (!NO_DWOLLA)
    if (!$result = $dw->$function(@$sources[0]['Id'], $this->pin, abs($amount))) {
      self::rollback();
      return $this->dwError($dw, $error);
    }
    if (NO_DWOLLA) $txid = \user_password(); else
    $txid = $result['Id'];
    self::addToAtom($txid, $amount, $this->acct->id, 0, 0);
    self::commit();
    return $result;
  }

  /**
   * Call the callback for each transaction OUT of the account after a given date/time 
   * @param string $callback: function to call
   * @param int $start: earliest second to consider (defaults to day 1 of the Unix Epoch).
   * Passes to the callback function an assoc with complete transaction details, including transaction id
   */
  function each($callback, $start = 0) {
    $dw = $this->dwolla();
    $skip = 0; // how many transactions to skip, in call to $dw->listings()
    $atATime = 50; // arbitrary, up to 200 (Dwolla limit)
    while ($listings = $dw->listings(strftime('%d-%m-%Y', $start), 'money_sent', $atATime, $skip)) {
      foreach ($listings['Response'] as $one) {
        if (u\abbreviates(USD_NOTE_PREFIX, $one['notes'])) $callback($one); // handle rCredits PAYMENTS only
      }
      $skip += $atATime;
    }   
  }

// Atomic Data Transaction Handling for mixed rCredits/USD financial transactions
// Strategy: Allow inconsistent USD transfers for up to 24 hours after system failure.
// Record committed USD transactions in the r_usd table. 
// A compensating transaction is created at the end of the day, 
//    for any recent USD transfer that does not appear in that table.
// $atoms is a list of transaction IDs waiting to be committed. 
// A Drupal transaction object entry marks the start of a new nested level.
// For example, [$DBTX1, a, b, $DBTX2, c, d, e] has 2 transactions at the top level and 3 nested.
// commit() and rollback() must always be called explicitly, barring a system crash (don't just return to the caller)
  
  /**
   * Mark the beginning of a mixed USD/rCredits (possibly nested) database transaction.
   */
  public static function beginAtom() {return self::$atoms[] = \db_transaction();}
  
  /**
   * Say whether we are currently in an atom.
   */
  private static function inAtom() {return !empty(self::$atoms);}
  
  /**
   * Remember a Dwolla transaction to commit or rollback (passed as individual params or as an assoc)
   *   txid: the Dwolla transaction id
   *   amount: the amount of a Dwolla transaction or bank transfer (negative for a withdrawal)
   *   payer: rCredits account id of the sender
   *   payee: rCredits account id of the other (0 for bank transfers)
   *   created: (int) creation date/time
   *   completed: completion date/time (default same as created)
   */
  private static function addToAtom($txid, $amount = '', $payer = '', $payee = '', $completed = NULL, $created = REQUEST_TIME) {
    u\EXPECT(self::inAtom(), 'addToAtom outside atom');
    if ($payer) {
      if (!isset($completed)) $completed = $created;
      $one = compact(u\ray('txid amount payer payee created completed'));
    } else $one = $txid;
    self::$atoms[] = $one;
  }

  /**
   * Mark the atom complete by writing a record of each USD transaction to the r_usd table.
   */
  public static function commit() {
    $values = '';
    while (!is_object($one = array_pop(self::$atoms))) {
      extract($one);
      $values .= ($values ? ',' : '') . "('$txid', '$amount', '$payer', '$payee', '$created', '$completed')";
    }
    u\EXPECT(strpos($values, ';') === FALSE, 'sql insertion in usd commit'); // impossible, but verify
    if ($values) r\dbQ("INSERT INTO r_usd (txid, amount, payer, payee, created, completed) VALUES $values");
    // Drupal automatically commits if we don't rollback (otherwise we would do a Drupal commit here)
  }
  
  /**
   * Rollback a list of transactions
   * If no $list is specified, rollback the most recent atom.
   * @param array $list: array of assocs of USD transaction details (defaults to most recent atom)
   * $list is specified when recovering from system failure during the daily (nightly) consistency checks
   */
  public static function rollback($list = array()) {
    if (!$list) {
      while (!is_object($one = array_pop(self::$atoms))) $list[] = $one;
      $one->rollback(); // got Drupal transaction object last (and removed it from list)
    }
    $grantNote = t('reimbursement of Dwolla fee for reversed transaction');
    
    foreach ($list as $one) { // create a compensating usd transaction for each transaction in $list
      extract($one); // (see fields listed above in addToAtom)
      $usAcct1 = new usd(r\acct($payer));
      $usAcct2 = new usd(r\acct($payee));
  
      self::beginAtom();
      self::addToAtom($one); // record original transaction
      $txid = $one['transactionID'];
      $notes = "reversing Dwolla transaction #$txid";
      $dw = $usAcct1->dwolla();
      extract(u\just('Success Response', $dw->transaction($txid)));
      if (!@$Success) {self::rollback(); continue;}
      //$payerFee = FALSE; // don't know yet how to extract this from $Response['Fees'][0]['Type'] (?todo)
      $payerFee = R_FEE_FOR_CASH ? ($Response['Notes'] == USD_NOTE_PREFIX . 'cash') : FALSE;
      
      $dw = $usAcct2->dwolla();
      if (!$txid = $dw->send($usAcct2->pin, $usAcct1->number, $amount, 'Dwolla', $notes, 0, $payerFee)) {
        // failure (probably insufficient Dwolla balance).
        $info = u\assoc('payer payee amount for taking', $payee, $payer, $amount, $notes, FALSE);
        r\transact($info); // reverse it in rCredits instead (this should not have USD txid though)
        if ($amount > DWOLLA_FEE_THRESHOLD) be\fund($payerFee ? $payer : $payee, TX_GRANT, DWOLLA_FEE, $grantNote);
      } else {
        self::addToAtom($txid, $amount, $payee, $payer);
        if ($amount > DWOLLA_FEE_THRESHOLD) foreach (array($payer, $payee) as $one) be\fund($one, TX_GRANT, DWOLLA_FEE, $grantNote);
      }
      self::commit();
    }
  }
  
} // end of class
